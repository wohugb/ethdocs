{
    "docs": [
        {
            "location": "/", 
            "text": "\u4ee5\u592a\u574a\u5bb6\u56ed\u7248\u6587\u6863\n\n\n\n\n\u672c\u6587\u6863\u662f\u4ee5\u592a\u574a\u5fd7\u613f\u8005\u4e0d\u65ad\u52aa\u529b\u7684\u7ed3\u679c\u3002 \u867d\u7136\u5b83\u6ca1\u6709\u5f97\u5230\u57fa\u91d1\u4f1a\u7684\u6388\u6743\uff0c\u4f46\u6211\u4eec\u5e0c\u671b\u4f60\u4f1a\u89c9\u5f97\u5b83\u6709\u7528\u3002 \u6211\u4eec\u6b22\u8fce\u65b0\u7684\u8d21\u732e\u8005\u3002\n\n\n\u5185\u5bb9\n\n\n\n\nintroduction/index\n\n\nethereum-clients/index\n\n\nconnecting-to-clients/index\n\n\naccount-management\n\n\nether\n\n\nnetwork/index\n\n\nmining\n\n\ncontracts-and-transactions/index\n\n\nfrequently-asked-questions/frequently-asked-questions\n\n\nglossary\n\n\nabout\n\n\n\n\n\u6539\u5584\u6587\u4ef6\n\n\n\u8bf7\u53c2\u9605\n\u672c\u9875\n\u5e2e\u52a9\u6211\u4eec\u6539\u8fdb\u6587\u6863\u3002", 
            "title": "\u524d\u8a00"
        }, 
        {
            "location": "/#_1", 
            "text": "\u672c\u6587\u6863\u662f\u4ee5\u592a\u574a\u5fd7\u613f\u8005\u4e0d\u65ad\u52aa\u529b\u7684\u7ed3\u679c\u3002 \u867d\u7136\u5b83\u6ca1\u6709\u5f97\u5230\u57fa\u91d1\u4f1a\u7684\u6388\u6743\uff0c\u4f46\u6211\u4eec\u5e0c\u671b\u4f60\u4f1a\u89c9\u5f97\u5b83\u6709\u7528\u3002 \u6211\u4eec\u6b22\u8fce\u65b0\u7684\u8d21\u732e\u8005\u3002", 
            "title": "\u4ee5\u592a\u574a\u5bb6\u56ed\u7248\u6587\u6863"
        }, 
        {
            "location": "/#_2", 
            "text": "introduction/index  ethereum-clients/index  connecting-to-clients/index  account-management  ether  network/index  mining  contracts-and-transactions/index  frequently-asked-questions/frequently-asked-questions  glossary  about", 
            "title": "\u5185\u5bb9"
        }, 
        {
            "location": "/#_3", 
            "text": "\u8bf7\u53c2\u9605 \u672c\u9875 \u5e2e\u52a9\u6211\u4eec\u6539\u8fdb\u6587\u6863\u3002", 
            "title": "\u6539\u5584\u6587\u4ef6"
        }, 
        {
            "location": "/introduction/what-is-ethereum/", 
            "text": "Note that some information on this website may no longer be relevant or\nout-of-date. You can also refer to the \nEthereum\nwiki\n for the latest information.\n\n\nWhat is Ethereum?\n\n\nEthereum is an open blockchain platform that lets anyone build and use\ndecentralized applications that run on blockchain technology. Like\nBitcoin, no one controls or owns Ethereum -- it is an open-source\nproject built by many people around the world. But unlike the Bitcoin\nprotocol, Ethereum was designed to be adaptable and flexible. It is easy\nto create new applications on the Ethereum platform, and with the\n\nHomestead release\n, it is now safe for anyone to use\nthose applications.\n\n\nA next generation blockchain\n\n\nBlockchain technology is the technological basis of Bitcoin, first\ndescribed by its mysterious author Satoshi Nakamoto in his white paper\n\\\"Bitcoin: A Peer-to-Peer Electronic Cash System\\\", published in 2008.\nWhile the use of blockchains for more general uses was already discussed\nin the original paper, it was not until a few years later that\nblockchain technology emerged as a generic term. A blockchain is a\ndistributed computing architecture where every network node executes and\nrecords the same transactions, which are grouped into blocks. Only one\nblock can be added at a time, and every block contains a mathematical\nproof that it follows in sequence from the previous block. In this way,\nthe blockchain's \\\"distributed database\\\" is kept in consensus across\nthe whole network. Individual user interactions with the ledger\n(transactions) are secured by strong cryptography. Nodes that maintain\nand verify the network are incentivized by mathematically enforced\neconomic incentives coded into the protocol.\n\n\nIn Bitcoin\\'s case the distributed database is conceived of as a table\nof account balances, a ledger, and transactions are transfers of the\nbitcoin token to facilitate trustless finance between individuals. But\nas bitcoin began attracting greater attention from developers and\ntechnologists, novel projects began to use the bitcoin network for\npurposes other than transfers of value tokens. Many of these took the\nform of \\\"alt coins\\\" - separate blockchains with cryptocurrencies of\ntheir own which improved on the original bitcoin protocol to add new\nfeatures or capabilities. In late 2013, Ethereum\\'s inventor Vitalik\nButerin proposed that a single blockchain with the capability to be\nreprogrammed to perform any arbitrarily complex computation could\nsubsume these many other projects.\n\n\nIn 2014, Ethereum founders Vitalik Buterin, Gavin Wood and Jeffrey\nWilcke began work on a next-generation blockchain that had the ambitions\nto implement a general, fully trustless smart contract platform.\n\n\nEthereum Virtual Machine\n\n\nEthereum is a programmable blockchain. Rather than give users a set of\npre-defined operations (e.g. bitcoin transactions), Ethereum allows\nusers to create their own operations of any complexity they wish. In\nthis way, it serves as a platform for many different types of\ndecentralized blockchain applications, including but not limited to\ncryptocurrencies.\n\n\nEthereum in the narrow sense refers to a suite of protocols that define\na platform for decentralised applications. At the heart of it is the\n[Ethereum Virtual Machine (\\\"EVM\\\") \\\nthe-EVM>]{role=\"ref\"}, which can\nexecute code of arbitrary algorithmic complexity. In computer science\nterms, Ethereum is \\\"Turing complete\\\". Developers can create\napplications that run on the EVM using friendly programming languages\nmodelled on existing languages like JavaScript and Python.\n\n\nLike any blockchain, Ethereum also includes a peer-to-peer network\nprotocol. The Ethereum blockchain database is maintained and updated by\nmany nodes connected to the network. Each and every node of the network\nruns the EVM and executes the same instructions. For this reason,\nEthereum is sometimes described evocatively as a \\\"world computer\\\".\n\n\nThis massive parallelisation of computing across the entire Ethereum\nnetwork is not done to make computation more efficient. In fact, this\nprocess makes computation on Ethereum far slower and more expensive than\non a traditional \\\"computer\\\". Rather, every Ethereum node runs the EVM\nin order to maintain consensus across the blockchain. Decentralized\nconsensus gives Ethereum extreme levels of fault tolerance, ensures zero\ndowntime, and makes data stored on the blockchain forever unchangeable\nand censorship-resistant.\n\n\nThe Ethereum platform itself is featureless or value-agnostic. Similar\nto programming languages, it is up to entrepreneurs and developers to\ndecide what it should be used for. However, it is clear that certain\napplication types benefit more than others from Ethereum\\'s\ncapabilities. Specifically, ethereum is \nsuited for applications that\nautomate direct interaction between peers or facilitate coordinated\ngroup action across a network\n. For instance, applications for\ncoordinating peer-to-peer marketplaces, or the automation of complex\nfinancial contracts. Bitcoin allows for individuals to exchange cash\nwithout involving any middlemen like financial institutions, banks, or\ngovernments. Ethereum's impact may be more far-reaching. In theory,\nfinancial interactions or exchanges of any complexity could be carried\nout automatically and reliably using code running on Ethereum. Beyond\nfinancial applications, any environments where trust, security, and\npermanence are important -- for instance, asset-registries, voting,\ngovernance, and the internet of things -- could be massively impacted by\nthe Ethereum platform.\n\n\nHow does Ethereum work?\n\n\nEthereum incorporates many features and technologies that will be\nfamiliar to users of Bitcoin, while also introducing many modifications\nand innovations of its own.\n\n\nWhereas the Bitcoin blockchain was purely a list of transactions,\n[Ethereum\\'s basic unit is the account \\\nAccounts>]{role=\"ref\"}. The\nEthereum blockchain tracks the state of every account, and all state\ntransitions on the Ethereum blockchain are transfers of value and\ninformation between accounts. There are two types of accounts:\n\n\n\n\nExternally Owned Accounts (EOAs), which are controlled by private\n    keys\n\n\nContract Accounts, which are controlled by their contract code and\n    can only be \\\"activated\\\" by an EOA\n\n\n\n\nFor most users, the basic difference between these is that human users\ncontrol EOAs - because they can control the private keys which give\ncontrol over an EOA. Contract accounts, on the other hand, are governed\nby their internal code. If they are \\\"controlled\\\" by a human user, it\nis because they are \nprogrammed\n to be controlled by an EOA with a\ncertain address, which is in turn controlled by whoever holds the\nprivate keys that control that EOA. The popular term \\\"smart contracts\\\"\nrefers to code in a Contract Account -- programs that execute when a\ntransaction is sent to that account. Users can create new contracts by\ndeploying code to the blockchain.\n\n\nContract accounts only perform an operation when instructed to do so by\nan EOA. So it is not possible for a Contract account to be performing\nnative operations like random number generation or API calls -- it can\ndo these things only if prompted by an EOA. This is because Ethereum\nrequires nodes to be able to agree on the outcome of computation, which\nrequires a guarantee of strictly deterministic execution.\n\n\nLike in Bitcoin, users must pay small transaction fees to the network.\nThis protects the Ethereum blockchain from frivolous or malicious\ncomputational tasks, like DDoS attacks or infinite loops. The sender of\na transaction must pay for each step of the \\\"program\\\" they activated,\nincluding computation and memory storage. These fees are paid in amounts\nof Ethereum\\'s native value-token, ether.\n\n\nThese transaction fees are collected by the nodes that validate the\nnetwork. These \\\"miners\\\" are nodes in the Ethereum network that\nreceive, propagate, verify, and execute transactions. The miners then\ngroup the transactions -- which include many updates to the \\\"state\\\" of\naccounts in the Ethereum blockchain -- into what are called \\\"blocks\\\",\nand miners then compete with one another for \ntheir\n block to be the\nnext one to be added to the blockchain. Miners are rewarded with ether\nfor each successful block they mine. This provides the economic\nincentive for people to dedicate hardware and electricity to the\nEthereum network.\n\n\nJust as in the Bitcoin network, miners are tasked with solving a complex\nmathematical problem in order to successfully \\\"mine\\\" a block. This is\nknown as a \\\"Proof of Work\\\". Any computational problem that requires\norders of magnitude more resources to solve algorithmically than it\ntakes to verify the solution is a good candidate for proof of work. In\norder to discourage centralisation due to the use of specialised\nhardware (e.g. [ASICs](\nhttps://en.bitcoin.it/wiki/ASIC\n), ), as has\noccurred in the Bitcoin network, Ethereum chose a memory-hard\ncomputational problem. If the problem requires memory as well as CPU,\nthe ideal hardware is in fact the general computer. This makes\nEthereum\\'s Proof of Work ASIC-resistant, allowing a more decentralized\ndistribution of security than blockchains whose mining is dominated by\nspecialized hardware, like Bitcoin.\n\n\nLearn about Ethereum\n\n\n[to be extended]\n\n\nPR videos with some pathos:\n\n\n\n\nEthereum: the World\n    Computer\n\n\nEthereum -- your turn\n\n\n\n\nBlockchain and Ethereum 101\n\n\n\n\nExplain bitcoin like I\\'m\n    five\n -\n    an excellent introduction to blockchain technology and bitcoin to\n    the mildly techsavvy layperson.\n\n\nhttps://medium.com/@creole/7-a-simple-view-of-ethereum-e276f76c980b\n\n\nhttps://blog.chain.com/explaining-ethereum-fd043c7d602e\n\n\nExplain Ethereum to non-technical people Q\nA on\n    stackexchange\n\n\nReddit threads on ELI5-ing Ethereum:\n\n\n\n\n[1]\n\n\n[2]\n\n\n[3]\n\n\n[4]\n\n\n[5]\n\n\n[6]\n\n\n[7]\n\n\n[8]\n\n\n[9]\n\n\n[10]\n\n\n[11]\n\n\n[12]\n\n\n[13]\n\n\n[14]\n\n\n[15]\n\n\n[16]\n\n\n[17]\n\n\n[18]\n\n\n[19]\n\n\nVideos\n\n\n\n\nhttp://change.is/video/ethereum-the-world-computer-featuring-dr-gavin-wood\n\n\n\n\nInfographics\n\n\n\n\nEthereum explained...[to your\n    mother]\n\n\nhttp://decentral.ca/wp-content/uploads/2016/03/infographic.jpg\n\n\nhttps://medium.com/@angelomilan/ethereum-explained-to-my-mom-infographic-673e32054c1c#.n9kzhme6v\n\n\n\n\nComparison to alternatives\n\n\n\n\nNXT\n\n\nMaidSafe", 
            "title": "\u4ec0\u4e48\u662f\u4ee5\u592a\u574a\uff1f"
        }, 
        {
            "location": "/introduction/what-is-ethereum/#what-is-ethereum", 
            "text": "Ethereum is an open blockchain platform that lets anyone build and use\ndecentralized applications that run on blockchain technology. Like\nBitcoin, no one controls or owns Ethereum -- it is an open-source\nproject built by many people around the world. But unlike the Bitcoin\nprotocol, Ethereum was designed to be adaptable and flexible. It is easy\nto create new applications on the Ethereum platform, and with the Homestead release , it is now safe for anyone to use\nthose applications.", 
            "title": "What is Ethereum?"
        }, 
        {
            "location": "/introduction/what-is-ethereum/#a-next-generation-blockchain", 
            "text": "Blockchain technology is the technological basis of Bitcoin, first\ndescribed by its mysterious author Satoshi Nakamoto in his white paper\n\\\"Bitcoin: A Peer-to-Peer Electronic Cash System\\\", published in 2008.\nWhile the use of blockchains for more general uses was already discussed\nin the original paper, it was not until a few years later that\nblockchain technology emerged as a generic term. A blockchain is a\ndistributed computing architecture where every network node executes and\nrecords the same transactions, which are grouped into blocks. Only one\nblock can be added at a time, and every block contains a mathematical\nproof that it follows in sequence from the previous block. In this way,\nthe blockchain's \\\"distributed database\\\" is kept in consensus across\nthe whole network. Individual user interactions with the ledger\n(transactions) are secured by strong cryptography. Nodes that maintain\nand verify the network are incentivized by mathematically enforced\neconomic incentives coded into the protocol.  In Bitcoin\\'s case the distributed database is conceived of as a table\nof account balances, a ledger, and transactions are transfers of the\nbitcoin token to facilitate trustless finance between individuals. But\nas bitcoin began attracting greater attention from developers and\ntechnologists, novel projects began to use the bitcoin network for\npurposes other than transfers of value tokens. Many of these took the\nform of \\\"alt coins\\\" - separate blockchains with cryptocurrencies of\ntheir own which improved on the original bitcoin protocol to add new\nfeatures or capabilities. In late 2013, Ethereum\\'s inventor Vitalik\nButerin proposed that a single blockchain with the capability to be\nreprogrammed to perform any arbitrarily complex computation could\nsubsume these many other projects.  In 2014, Ethereum founders Vitalik Buterin, Gavin Wood and Jeffrey\nWilcke began work on a next-generation blockchain that had the ambitions\nto implement a general, fully trustless smart contract platform.", 
            "title": "A next generation blockchain"
        }, 
        {
            "location": "/introduction/what-is-ethereum/#ethereum-virtual-machine", 
            "text": "Ethereum is a programmable blockchain. Rather than give users a set of\npre-defined operations (e.g. bitcoin transactions), Ethereum allows\nusers to create their own operations of any complexity they wish. In\nthis way, it serves as a platform for many different types of\ndecentralized blockchain applications, including but not limited to\ncryptocurrencies.  Ethereum in the narrow sense refers to a suite of protocols that define\na platform for decentralised applications. At the heart of it is the\n[Ethereum Virtual Machine (\\\"EVM\\\") \\ the-EVM>]{role=\"ref\"}, which can\nexecute code of arbitrary algorithmic complexity. In computer science\nterms, Ethereum is \\\"Turing complete\\\". Developers can create\napplications that run on the EVM using friendly programming languages\nmodelled on existing languages like JavaScript and Python.  Like any blockchain, Ethereum also includes a peer-to-peer network\nprotocol. The Ethereum blockchain database is maintained and updated by\nmany nodes connected to the network. Each and every node of the network\nruns the EVM and executes the same instructions. For this reason,\nEthereum is sometimes described evocatively as a \\\"world computer\\\".  This massive parallelisation of computing across the entire Ethereum\nnetwork is not done to make computation more efficient. In fact, this\nprocess makes computation on Ethereum far slower and more expensive than\non a traditional \\\"computer\\\". Rather, every Ethereum node runs the EVM\nin order to maintain consensus across the blockchain. Decentralized\nconsensus gives Ethereum extreme levels of fault tolerance, ensures zero\ndowntime, and makes data stored on the blockchain forever unchangeable\nand censorship-resistant.  The Ethereum platform itself is featureless or value-agnostic. Similar\nto programming languages, it is up to entrepreneurs and developers to\ndecide what it should be used for. However, it is clear that certain\napplication types benefit more than others from Ethereum\\'s\ncapabilities. Specifically, ethereum is  suited for applications that\nautomate direct interaction between peers or facilitate coordinated\ngroup action across a network . For instance, applications for\ncoordinating peer-to-peer marketplaces, or the automation of complex\nfinancial contracts. Bitcoin allows for individuals to exchange cash\nwithout involving any middlemen like financial institutions, banks, or\ngovernments. Ethereum's impact may be more far-reaching. In theory,\nfinancial interactions or exchanges of any complexity could be carried\nout automatically and reliably using code running on Ethereum. Beyond\nfinancial applications, any environments where trust, security, and\npermanence are important -- for instance, asset-registries, voting,\ngovernance, and the internet of things -- could be massively impacted by\nthe Ethereum platform.", 
            "title": "Ethereum Virtual Machine"
        }, 
        {
            "location": "/introduction/what-is-ethereum/#how-does-ethereum-work", 
            "text": "Ethereum incorporates many features and technologies that will be\nfamiliar to users of Bitcoin, while also introducing many modifications\nand innovations of its own.  Whereas the Bitcoin blockchain was purely a list of transactions,\n[Ethereum\\'s basic unit is the account \\ Accounts>]{role=\"ref\"}. The\nEthereum blockchain tracks the state of every account, and all state\ntransitions on the Ethereum blockchain are transfers of value and\ninformation between accounts. There are two types of accounts:   Externally Owned Accounts (EOAs), which are controlled by private\n    keys  Contract Accounts, which are controlled by their contract code and\n    can only be \\\"activated\\\" by an EOA   For most users, the basic difference between these is that human users\ncontrol EOAs - because they can control the private keys which give\ncontrol over an EOA. Contract accounts, on the other hand, are governed\nby their internal code. If they are \\\"controlled\\\" by a human user, it\nis because they are  programmed  to be controlled by an EOA with a\ncertain address, which is in turn controlled by whoever holds the\nprivate keys that control that EOA. The popular term \\\"smart contracts\\\"\nrefers to code in a Contract Account -- programs that execute when a\ntransaction is sent to that account. Users can create new contracts by\ndeploying code to the blockchain.  Contract accounts only perform an operation when instructed to do so by\nan EOA. So it is not possible for a Contract account to be performing\nnative operations like random number generation or API calls -- it can\ndo these things only if prompted by an EOA. This is because Ethereum\nrequires nodes to be able to agree on the outcome of computation, which\nrequires a guarantee of strictly deterministic execution.  Like in Bitcoin, users must pay small transaction fees to the network.\nThis protects the Ethereum blockchain from frivolous or malicious\ncomputational tasks, like DDoS attacks or infinite loops. The sender of\na transaction must pay for each step of the \\\"program\\\" they activated,\nincluding computation and memory storage. These fees are paid in amounts\nof Ethereum\\'s native value-token, ether.  These transaction fees are collected by the nodes that validate the\nnetwork. These \\\"miners\\\" are nodes in the Ethereum network that\nreceive, propagate, verify, and execute transactions. The miners then\ngroup the transactions -- which include many updates to the \\\"state\\\" of\naccounts in the Ethereum blockchain -- into what are called \\\"blocks\\\",\nand miners then compete with one another for  their  block to be the\nnext one to be added to the blockchain. Miners are rewarded with ether\nfor each successful block they mine. This provides the economic\nincentive for people to dedicate hardware and electricity to the\nEthereum network.  Just as in the Bitcoin network, miners are tasked with solving a complex\nmathematical problem in order to successfully \\\"mine\\\" a block. This is\nknown as a \\\"Proof of Work\\\". Any computational problem that requires\norders of magnitude more resources to solve algorithmically than it\ntakes to verify the solution is a good candidate for proof of work. In\norder to discourage centralisation due to the use of specialised\nhardware (e.g. [ASICs]( https://en.bitcoin.it/wiki/ASIC ), ), as has\noccurred in the Bitcoin network, Ethereum chose a memory-hard\ncomputational problem. If the problem requires memory as well as CPU,\nthe ideal hardware is in fact the general computer. This makes\nEthereum\\'s Proof of Work ASIC-resistant, allowing a more decentralized\ndistribution of security than blockchains whose mining is dominated by\nspecialized hardware, like Bitcoin.", 
            "title": "How does Ethereum work?"
        }, 
        {
            "location": "/introduction/what-is-ethereum/#learn-about-ethereum", 
            "text": "[to be extended]", 
            "title": "Learn about Ethereum"
        }, 
        {
            "location": "/introduction/what-is-ethereum/#pr-videos-with-some-pathos", 
            "text": "Ethereum: the World\n    Computer  Ethereum -- your turn", 
            "title": "PR videos with some pathos:"
        }, 
        {
            "location": "/introduction/what-is-ethereum/#blockchain-and-ethereum-101", 
            "text": "Explain bitcoin like I\\'m\n    five  -\n    an excellent introduction to blockchain technology and bitcoin to\n    the mildly techsavvy layperson.  https://medium.com/@creole/7-a-simple-view-of-ethereum-e276f76c980b  https://blog.chain.com/explaining-ethereum-fd043c7d602e  Explain Ethereum to non-technical people Q A on\n    stackexchange  Reddit threads on ELI5-ing Ethereum:   [1]  [2]  [3]  [4]  [5]  [6]  [7]  [8]  [9]  [10]  [11]  [12]  [13]  [14]  [15]  [16]  [17]  [18]  [19]", 
            "title": "Blockchain and Ethereum 101"
        }, 
        {
            "location": "/introduction/what-is-ethereum/#videos", 
            "text": "http://change.is/video/ethereum-the-world-computer-featuring-dr-gavin-wood", 
            "title": "Videos"
        }, 
        {
            "location": "/introduction/what-is-ethereum/#infographics", 
            "text": "Ethereum explained...[to your\n    mother]  http://decentral.ca/wp-content/uploads/2016/03/infographic.jpg  https://medium.com/@angelomilan/ethereum-explained-to-my-mom-infographic-673e32054c1c#.n9kzhme6v", 
            "title": "Infographics"
        }, 
        {
            "location": "/introduction/what-is-ethereum/#comparison-to-alternatives", 
            "text": "NXT  MaidSafe", 
            "title": "Comparison to alternatives"
        }, 
        {
            "location": "/introduction/how-to-use-this-guide/", 
            "text": "How to use this guide?\n\n\nUsing Ethereum: The Basics\n\n\nThis section captures the basic ways in which a user would want to\nparticipate in the Ethereum project. First of all, to become a node in\nthe network, you need to run an Ethereum client. Multiple\nimplementations are listed in the section [sec:clients]{role=\"ref\"}\nwhich also gives you advice as to which clients to choose in various\nsetups. [sec:connecting-to-the-network]{role=\"ref\"} gives you basic\ninformation about networks, connectivity troubleshooting and blockchain\nsynchronization. Advanced network topics like setting up private chains\nis found in [test-networks]{role=\"ref\"}.", 
            "title": "\u5982\u4f55\u4f7f\u7528\u672c\u6307\u5357\uff1f"
        }, 
        {
            "location": "/introduction/how-to-use-this-guide/#how-to-use-this-guide", 
            "text": "", 
            "title": "How to use this guide?"
        }, 
        {
            "location": "/introduction/how-to-use-this-guide/#using-ethereum-the-basics", 
            "text": "This section captures the basic ways in which a user would want to\nparticipate in the Ethereum project. First of all, to become a node in\nthe network, you need to run an Ethereum client. Multiple\nimplementations are listed in the section [sec:clients]{role=\"ref\"}\nwhich also gives you advice as to which clients to choose in various\nsetups. [sec:connecting-to-the-network]{role=\"ref\"} gives you basic\ninformation about networks, connectivity troubleshooting and blockchain\nsynchronization. Advanced network topics like setting up private chains\nis found in [test-networks]{role=\"ref\"}.", 
            "title": "Using Ethereum: The Basics"
        }, 
        {
            "location": "/introduction/the-homestead-release/", 
            "text": "The Homestead Release\n\n\nHomestead is the second major version of the Ethereum platform and is\nthe first production release of Ethereum. It includes several protocol\nchanges and a networking change that provides the ability to do further\nnetwork upgrades. The first version of Ethereum, called the Frontier\nrelease, was essentially a beta release that allowed developers to\nlearn, experiment, and begin building Ethereum decentralized apps and\ntools.\n\n\nMilestones of the Ethereum development roadmap\n\n\nSee \nhere\n for the\nlatest information.\n\n\nIf you are running a node connected to the live network, it is important\nthat you upgrade to a compatible client. Such clients with their\nversions are listed under [Ethereum Clients]{role=\"ref\"}. Otherwise you\nwill end up on the wrong fork and will no longer be in sync with the\nrest of the network.\n\n\nOnce the Ethereum blockchain reaches block 1,150,000, the Ethereum\nnetwork will undergo a hardfork enabling a few major changes such as\nexplained in the following section.\n\n\nHomestead hard fork changes\n\n\nEthereum in the narrow formal sense is a suite of protocols. Homestead\ncomes with a few backward-incompatible protocol changes, and therefore\nwill require a hard fork. These changes that made their way through the\nprocess for\n[Ethereum Improvement Proposals \\\nEthereum Improvement Proposals>]{role=\"ref\"}\nand included are:\n\n\n\n\nEIP\n    2:\n\n\ncost for creating contracts via a transaction is increased from\n    21000 to 53000. Contract creation from a contract using the\n    \nCREATE\n opcode is unaffected.\n\n\ntransaction signatures whose s-value is greater than\n    \nsecp256k1n/2\n are now considered invalid\n\n\nIf contract creation does not have enough gas to pay for the\n    final gas fee for adding the contract code to the state, the\n    contract creation fails (ie. goes out-of-gas) rather than\n    leaving an empty contract.\n\n\nChange the difficulty adjustment algorithm\n\n\n\n\n\n\nEIP 7:\n    DELEGATECALL\n:\n    Add a new opcode, \nDELEGATECALL\n at \n0xf4\n, which is similar in idea\n    to \nCALLCODE\n, except that it propagates the sender and value from\n    the parent scope to the child scope, ie. the call created has the\n    same sender and value as the original call. This means contracts can\n    store pass through information while following msg.sender and\n    \nmsg.value\n from its parent contract. Great for contracts which\n    create contracts but don't repeat additional information which saves\n    gas. See \ncomments on EIP\n    7\n\n\nEIP 8: devp2p Forward Compatibility compliance with the Robustness\n    Principle\n\n    Changes to the RLPx Discovery Protocol and RLPx TCP transfer\n    protocol to ensure that all client software in use on the Ethereum\n    network can cope with future network protocol upgrades. For older\n    versions of an Ethereum client, updates to the network protocol\n    weren't being accepted by older clients and would refuse\n    communication if the hello packets didn't meet expectations. This\n    update means all future versions of the client will accept incoming\n    network upgrades and handshakes.\n\n\n\n\nThe changes have the following benefits:\n\n\n\n\nEIP-2/1 eliminates the excess incentive to create contracts via\n    transactions, where the cost is 21000, rather than contracts, where\n    the cost is 32000.\n\n\nEIP-2/1 also fixes the protocol \\\"bug\\\" that with the help of\n    suicide refunds, it is currently possible to make a simple ether\n    value transfer using only 11664 gas.\n\n\nEIP-2/2 fixes a transaction malleability concern (not a security\n    flaw, but a UI incovenience).\n\n\nEIP-2/3 creates a more intuitive \\\"success or fail\\\" distinction in\n    the result of a contract creation process, rather than the current\n    \\\"success, fail, or empty contract\\\" trichotomy\n\n\nEIP-2/4 eliminates the excess incentive to set the timestamp\n    difference to exactly 1 in order to create a block that has slightly\n    higher difficulty and that will thus be guaranteed to beat out any\n    possible forks. This guarantees to keep block time in the 10-20\n    range and according to simulations restores the target 15 second\n    blocktime (instead of the current effective 17s).\n\n\nEIP-7 makes it much easier for a contract to store another address\n    as a mutable source of code and \\'\\'pass through\\'\\' calls to it, as\n    the child code would execute in essentially the same environment\n    (except for reduced gas and increased callstack depth) as the\n    parent.\n\n\nEIP-8 makes sure that all client software in use on the Ethereum\n    network can cope with future network protocol upgrades.\n\n\n\n\nAdditional resources: - \nReddit discussion on Homestead\nRelease\n\n- [Ethereum Improvement Proposals]{role=\"ref\"}", 
            "title": "\u5bb6\u56ed\u7248"
        }, 
        {
            "location": "/introduction/the-homestead-release/#the-homestead-release", 
            "text": "Homestead is the second major version of the Ethereum platform and is\nthe first production release of Ethereum. It includes several protocol\nchanges and a networking change that provides the ability to do further\nnetwork upgrades. The first version of Ethereum, called the Frontier\nrelease, was essentially a beta release that allowed developers to\nlearn, experiment, and begin building Ethereum decentralized apps and\ntools.", 
            "title": "The Homestead Release"
        }, 
        {
            "location": "/introduction/the-homestead-release/#milestones-of-the-ethereum-development-roadmap", 
            "text": "See  here  for the\nlatest information.  If you are running a node connected to the live network, it is important\nthat you upgrade to a compatible client. Such clients with their\nversions are listed under [Ethereum Clients]{role=\"ref\"}. Otherwise you\nwill end up on the wrong fork and will no longer be in sync with the\nrest of the network.  Once the Ethereum blockchain reaches block 1,150,000, the Ethereum\nnetwork will undergo a hardfork enabling a few major changes such as\nexplained in the following section.", 
            "title": "Milestones of the Ethereum development roadmap"
        }, 
        {
            "location": "/introduction/the-homestead-release/#homestead-hard-fork-changes", 
            "text": "Ethereum in the narrow formal sense is a suite of protocols. Homestead\ncomes with a few backward-incompatible protocol changes, and therefore\nwill require a hard fork. These changes that made their way through the\nprocess for\n[Ethereum Improvement Proposals \\ Ethereum Improvement Proposals>]{role=\"ref\"}\nand included are:   EIP\n    2:  cost for creating contracts via a transaction is increased from\n    21000 to 53000. Contract creation from a contract using the\n     CREATE  opcode is unaffected.  transaction signatures whose s-value is greater than\n     secp256k1n/2  are now considered invalid  If contract creation does not have enough gas to pay for the\n    final gas fee for adding the contract code to the state, the\n    contract creation fails (ie. goes out-of-gas) rather than\n    leaving an empty contract.  Change the difficulty adjustment algorithm    EIP 7:\n    DELEGATECALL :\n    Add a new opcode,  DELEGATECALL  at  0xf4 , which is similar in idea\n    to  CALLCODE , except that it propagates the sender and value from\n    the parent scope to the child scope, ie. the call created has the\n    same sender and value as the original call. This means contracts can\n    store pass through information while following msg.sender and\n     msg.value  from its parent contract. Great for contracts which\n    create contracts but don't repeat additional information which saves\n    gas. See  comments on EIP\n    7  EIP 8: devp2p Forward Compatibility compliance with the Robustness\n    Principle \n    Changes to the RLPx Discovery Protocol and RLPx TCP transfer\n    protocol to ensure that all client software in use on the Ethereum\n    network can cope with future network protocol upgrades. For older\n    versions of an Ethereum client, updates to the network protocol\n    weren't being accepted by older clients and would refuse\n    communication if the hello packets didn't meet expectations. This\n    update means all future versions of the client will accept incoming\n    network upgrades and handshakes.   The changes have the following benefits:   EIP-2/1 eliminates the excess incentive to create contracts via\n    transactions, where the cost is 21000, rather than contracts, where\n    the cost is 32000.  EIP-2/1 also fixes the protocol \\\"bug\\\" that with the help of\n    suicide refunds, it is currently possible to make a simple ether\n    value transfer using only 11664 gas.  EIP-2/2 fixes a transaction malleability concern (not a security\n    flaw, but a UI incovenience).  EIP-2/3 creates a more intuitive \\\"success or fail\\\" distinction in\n    the result of a contract creation process, rather than the current\n    \\\"success, fail, or empty contract\\\" trichotomy  EIP-2/4 eliminates the excess incentive to set the timestamp\n    difference to exactly 1 in order to create a block that has slightly\n    higher difficulty and that will thus be guaranteed to beat out any\n    possible forks. This guarantees to keep block time in the 10-20\n    range and according to simulations restores the target 15 second\n    blocktime (instead of the current effective 17s).  EIP-7 makes it much easier for a contract to store another address\n    as a mutable source of code and \\'\\'pass through\\'\\' calls to it, as\n    the child code would execute in essentially the same environment\n    (except for reduced gas and increased callstack depth) as the\n    parent.  EIP-8 makes sure that all client software in use on the Ethereum\n    network can cope with future network protocol upgrades.   Additional resources: -  Reddit discussion on Homestead\nRelease \n- [Ethereum Improvement Proposals]{role=\"ref\"}", 
            "title": "Homestead hard fork changes"
        }, 
        {
            "location": "/introduction/web3/", 
            "text": "Web 3: A platform for decentralized apps\n\n\nMany have come to believe that an open, trustless blockchain platform\nlike Ethereum is perfectly suited to serve as the shared \\\"back end\\\" to\na decentralized, secure internet - Web 3.0. An internet where core\nservices like DNS and digital identity are decentralized, and where\nindividuals can engage in economic interactions with each other.\n\n\nAs intended by the Ethereum developers, Ethereum is a blank canvas and\nyou have the freedom to build whatever you want with it. The Ethereum\nprotocol is meant to be generalized so that the core features can be\ncombined in arbitrary ways. Ideally, dapp projects on Ethereum will\nleverage the Ethereum blockchain to build solutions that rely on\ndecentralized consensus to provide new products and services that were\nnot previously possible.\n\n\nEthereum is perhaps best described as an ecosystem: the core protocol is\nsupported by various pieces of infrastructure, code, and community that\ntogether make up the Ethereum project. Ethereum can also be understood\nby looking at the projects that use Ethereum. Already, there are a\nnumber of high-profile projects built on Ethereum such as Augur, Digix,\nMaker, and many more (see [dapps]{role=\"ref\"}). In addition, there are\ndevelopment teams that build open source components that anyone can use.\nWhile each of these organizations are separate from the Ethereum\nFoundation and have their own goals, they undoubtedly benefit the\noverall Ethereum ecosystem.\n\n\nFurther Watching/Reading:\n\n\n\n\nVitalik Buterin - TNABC 2015:\n    \nhttps://www.youtube.com/watch?v=Fjhe0MVRHO4\n\n\nGavin Wood - DEVCON 1 - Ethereum for Dummies:\n    \nhttps://www.youtube.com/watch?v=U_LK0t_qaPo\n\n\nEthereum London Meetup (best detailed here):\n    \nhttps://www.youtube.com/watch?v=GJGIeSCgskc\n\n\n\n\nSmart contracts\n\n\nby Alex:\n\n\nWould you enter in a contract with someone you\\'ve never met? Would you\nagree to lend money to some farmer in Ethiopia? Would you become an\ninvestor in a minority-run newspaper in a war zone? Would you go to the\nhassle of writing up a legal binding contract for a \\$5 dollar purchase\nover the internet?\n\n\nThe answer is no for most of these questions, the reason being that a\ncontract requires a large infrastructure: sometimes you need a working\ntrust relationship between the two parties, sometimes you rely on a\nworking legal system, police force and lawyer costs.\n\n\nIn Ethereum you don\\'t need any of that: if all the requisites to the\ncontract can be put in the blockchain then they will, in a trustless\nenvironment for almost no cost.\n\n\nInstead of thinking of moving your current contracts to the blockchain,\nthink of all the thousand little contracts that you would never agree to\nsimply because they weren\\'t economically feasible or there was not\nenough legal protection..\n\n\nDAO\n\n\nHere is just one example: imagine you own a small business with your\nfriends. Lawyers and accountants are expensive, and trusting a single\npartner to oversee the books can be a source of tension (even an\nopportunity for fraud). Complying strictly with a system in which more\nthan one partner oversees the books can be trying and is subject to\nfraud whenever the protocol isn\\'t followed exactly.\n\n\nUsing a smart contract, ownership in your company and terms for the\ndisbursal of funds can be specified at the outset. The smart contract\ncan be written such that it is only changeable given the approval of a\nmajority of owners. Smart contracts like these will likely be available\nas open source software, so you won\\'t even need to hire your own\nprogrammer instead of an accountant/lawyer.\n\n\nA smart contract like this scales instantly. A couple of teenagers can\nsplit revenue from a lemonade stand just as transparently as a sovereign\nwealth fund can disburse funds to the hundred million citizens who are\nentitled to it. In both cases the price of this transparency is likely\nto be fractions of a penny per dollar.", 
            "title": "Web 3"
        }, 
        {
            "location": "/introduction/web3/#web-3-a-platform-for-decentralized-apps", 
            "text": "Many have come to believe that an open, trustless blockchain platform\nlike Ethereum is perfectly suited to serve as the shared \\\"back end\\\" to\na decentralized, secure internet - Web 3.0. An internet where core\nservices like DNS and digital identity are decentralized, and where\nindividuals can engage in economic interactions with each other.  As intended by the Ethereum developers, Ethereum is a blank canvas and\nyou have the freedom to build whatever you want with it. The Ethereum\nprotocol is meant to be generalized so that the core features can be\ncombined in arbitrary ways. Ideally, dapp projects on Ethereum will\nleverage the Ethereum blockchain to build solutions that rely on\ndecentralized consensus to provide new products and services that were\nnot previously possible.  Ethereum is perhaps best described as an ecosystem: the core protocol is\nsupported by various pieces of infrastructure, code, and community that\ntogether make up the Ethereum project. Ethereum can also be understood\nby looking at the projects that use Ethereum. Already, there are a\nnumber of high-profile projects built on Ethereum such as Augur, Digix,\nMaker, and many more (see [dapps]{role=\"ref\"}). In addition, there are\ndevelopment teams that build open source components that anyone can use.\nWhile each of these organizations are separate from the Ethereum\nFoundation and have their own goals, they undoubtedly benefit the\noverall Ethereum ecosystem.  Further Watching/Reading:   Vitalik Buterin - TNABC 2015:\n     https://www.youtube.com/watch?v=Fjhe0MVRHO4  Gavin Wood - DEVCON 1 - Ethereum for Dummies:\n     https://www.youtube.com/watch?v=U_LK0t_qaPo  Ethereum London Meetup (best detailed here):\n     https://www.youtube.com/watch?v=GJGIeSCgskc", 
            "title": "Web 3: A platform for decentralized apps"
        }, 
        {
            "location": "/introduction/web3/#smart-contracts", 
            "text": "by Alex:  Would you enter in a contract with someone you\\'ve never met? Would you\nagree to lend money to some farmer in Ethiopia? Would you become an\ninvestor in a minority-run newspaper in a war zone? Would you go to the\nhassle of writing up a legal binding contract for a \\$5 dollar purchase\nover the internet?  The answer is no for most of these questions, the reason being that a\ncontract requires a large infrastructure: sometimes you need a working\ntrust relationship between the two parties, sometimes you rely on a\nworking legal system, police force and lawyer costs.  In Ethereum you don\\'t need any of that: if all the requisites to the\ncontract can be put in the blockchain then they will, in a trustless\nenvironment for almost no cost.  Instead of thinking of moving your current contracts to the blockchain,\nthink of all the thousand little contracts that you would never agree to\nsimply because they weren\\'t economically feasible or there was not\nenough legal protection..", 
            "title": "Smart contracts"
        }, 
        {
            "location": "/introduction/web3/#dao", 
            "text": "Here is just one example: imagine you own a small business with your\nfriends. Lawyers and accountants are expensive, and trusting a single\npartner to oversee the books can be a source of tension (even an\nopportunity for fraud). Complying strictly with a system in which more\nthan one partner oversees the books can be trying and is subject to\nfraud whenever the protocol isn\\'t followed exactly.  Using a smart contract, ownership in your company and terms for the\ndisbursal of funds can be specified at the outset. The smart contract\ncan be written such that it is only changeable given the approval of a\nmajority of owners. Smart contracts like these will likely be available\nas open source software, so you won\\'t even need to hire your own\nprogrammer instead of an accountant/lawyer.  A smart contract like this scales instantly. A couple of teenagers can\nsplit revenue from a lemonade stand just as transparently as a sovereign\nwealth fund can disburse funds to the hundred million citizens who are\nentitled to it. In both cases the price of this transparency is likely\nto be fractions of a penny per dollar.", 
            "title": "DAO"
        }, 
        {
            "location": "/introduction/history-of-ethereum/", 
            "text": "History of Ethereum\n\n\nFor a recent historical account, see \nTaylor Gerring\\'s\nblogpost\n\n\nInception\n\n\nEthereum was initially described by Vitalik Buterin in late 2013 as a\nresult of his research and work in the Bitcoin community. Shortly\nthereafter, Vitalik published the \nEthereum white\npaper\n, where he\ndescribes in detail the technical design and rationale for the Ethereum\nprotocol and smart contracts architecture. In January 2014, Ethereum was\nformally announced by Vitalik at the The North American Bitcoin\nConference in Miami, Florida, USA.\n\n\nAround that time, Vitalik also started working with Dr. Gavin Wood and\ntogether co-founded Ethereum. By April 2014, Gavin published the\n\nEthereum Yellow Paper\n that\nwould serve as the technical specification for the Ethereum Virtual\nMachine (EVM). By following the detailed specification in the Yellow\nPaper, the Ethereum client has been implemented in seven programming\nlanguages (C++, Go, Python, Java, JavaScript, Haskell, Rust), and has\nresulted in better software overall.\n\n\n\n\nEthereum launches Cryptocurrency 2.0\n    network\n -\n    Coindesk article of 2014 Jan on the beginnings\n\n\nEthereum announcement on\n    bitcointalk\n\n    Vitalik\\'s original announcement to the bitcoin community. Forum\n    thread with 5000 replies.\n\n\n\n\nThe Ethereum Foundation and the ether presale\n\n\nIn addition to developing the software for Ethereum, the ability to\nlaunch a new cryptocurrency and blockchain requires a massive\nbootstrapping effort in order to assemble the resources needed to get it\nup and running. To kickstart a large network of developers, miners,\ninvestors, and other stakeholders, Ethereum announced its plan to\nconduct a presale of ether tokens, the currency unit of Ethereum. The\nlegal and financial complexities of raising funds through a presale led\nto the creation of several legal entities, including the\n[Ethereum Foundation (Stiftung Ethereum) \\\nfoundation>]{role=\"ref\"}\nestablished June 2014 in Zug, Switzerland.\n\n\nBeginning in July 2014, Ethereum distributed the initial allocation of\nether via a 42-day public ether presale, netting 31,591 bitcoins, worth\n\\$18,439,086 at that time, in exchange for about 60,102,216 ether. The\nresults of the sale were initially used to pay back mounting legal debts\nand also for the months of developer effort that had yet to be\ncompensated, and to finance the ongoing development of the Ethereum.\n\n\n\n\nLaunching the ether\n    sale\n -\n    original official announcement on the Ethereum blog\n\n\nConcise information-rich stats page about the\n    presale\n by (since then inactive)\n    \nEther.Fund\n\n\nOverview: Ethereum's initial public\n    sale\n -\n    Blogpost by slacknation - all stats about the ether presale\n\n\nTerms and Conditions of the\n    Presale\n\n\n\n\nETH/DEV and Ethereum development\n\n\nFollowing the successful ether presale, Ethereum development was\nformalized under a non-for-profit organization called ETH DEV, which\nmanages the development of Ethereum under contract from Ethereum Suisse\n-- with Vitalik Buterin, Gavin Wood, and Jeffrey Wilcke as the 3\ndirectors of the organization. Developer interest in Ethereum grew\nsteadily throughout 2014 and the ETH DEV team delivered a series of\nproof-of-concept (PoC) releases for the development community to\nevaluate. Frequent posts by ETH DEV team on the \nthe Ethereum\nblog\n also kept the excitement and momentum\naround Ethereum going. Increasing traffic and growing user-base on both\nthe Ethereum forum and the ethereum subreddit testified that the\nplatform is attracting a fast-growing and devoted developer community.\nThis trend has been continuing to this very day.\n\n\nDEVCON-0\n\n\nIn November 2014, ETH DEV organized the \nDEVCON-0\nevent\n, which\nbrought together Ethereum developers from around the world to Berlin to\nmeet and discuss a diverse range of Ethereum technology topics. Several\nof the presentations and sessions at DEVcon-0 would later drive\nimportant initiatives to make Ethereum more reliable, more secure, and\nmore scalable. Overall, the event galvanized developers as they\ncontinued to work towards the launch of Ethereum.\n\n\n\n\nDEVCON-0 talks youtube\n    playlist\n\n\nDEVCON-0 reddit\n    post\n\n\nGav\\'s DEV update mentioning\n    DEVCON-0\n\n\nDEVcon-0 recap blog\n    post\n\n\n\n\nDEVgrants program\n\n\nIn April 2015, \nthe DEVgrants\nprogram\n was\nannounced, which is a program that offers funding for contributions both\nto the Ethereum platform, and to projects based on Ethereum. Hundreds of\ndevelopers were already contributing their time and thinking to Ethereum\nprojects and in open source projects. This program served to reward and\nsupport those developers for their contributions. The DEVgrants program\ncontinues to operate today and funding of the program was recently\nrenewed in January 2016.\n\n\n\n\nDEVgrants initial\n    announcement\n\n\nAnnouncement of new funding at\n    DEVCON-1\n\n\nDEVgrants public gitter room\n\n\nDEVgrants talk at DEVCON-1 by Wendell Davis on\n    YouTube\n\n\n\n\nOlympic testnet, bug bounty and security audit {#olympic-testnet}\n\n\nThroughout 2014 and 2015 development went through a series of proof of\nconcept releases leading to the 9th POC open testnet, called Olympic.\nThe developer community was \ninvited to test the limits of the\nnetwork\n\nand a substantial prize fund was allocated to award those holding\nvarious records or having success in breaking the system in some way or\nother. The \nrewards were\nannounced\n\nofficially a month after the live release.\n\n\nIn early 2015, an \nEthereum Bounty Program\n\nwas launched, offering BTC rewards for finding vulnerabilities in any\npart of the Ethereum software stack. This has undoubtedly contributed to\nthe reliability and security of Ethereum and the confidence of the\nEthereum community in the technology. The bounty program is currently\nstill active and there is no end date planned.\n\n\nThe Ethereum security audit began at the end of 2014 and continued\nthrough the first half of 2015. Ethereum engaged multiple third party\nsoftware security firms to conduct an end-to-end audit of all\nprotocol-critical components (Ethereum VM, networking, Proof of Work).\nThe audits uncovered security issues that were addressed and tested\nagain and as a result ultimately led to a more secure platform.\n\n\n\n\nOlympic testnet\n    prerelease\n -\n    Vitalik\\'s blogpost detailing olympic rewards\n\n\nOlympic rewards\n    announced\n -\n    Vitalik\\'s blogpost detailing the winners and prizes\n\n\nBug bounty program\n    launch\n\n\nEthereum Bounty Program website\n\n\nLeast Authority audit\n    blogpost\n -\n    with links to the audit report\n\n\nDeja Vu audit\n    blogpost\n\n\n\n\nThe Ethereum Frontier launch {#frontier-launch}\n\n\nThe Ethereum Frontier network launched on July 30th, 2015, and\ndevelopers began writing smart contracts and decentralized apps to\ndeploy on the live Ethereum network. In addition, miners began to join\nthe Ethereum network to help secure the Ethereum blockchain and earn\nether from mining blocks. Even though the Frontier release is the first\nmilestone in the Ethereum project and was intended for use by developers\nas a beta version, it turned out to be more capable and reliable than\nanyone expected, and developers have rushed in to build solutions and\nimprove the Ethereum ecosystem.\n\n\nSee also:\n\n\n\n\nOriginal announcement of the release\n    scheme\n\n    by Vinay Gupta\n\n\nFrontier is\n    coming\n -\n    Frontier launch announcement by Stephan Tual\n\n\nFrontier launch final\n    steps\n -\n    Follow-up post to announcement\n\n\nEthereum goes live with Frontier\n    launch\n\n\nThe frontier\n    website\n\n\n\n\nDEVCON-1\n\n\nThe second developers\\' conference\n\nDEVCON-1\n took place in the city of\nLondon at the beginning of November 2015. The 5-day event featured more\nthan 100 presentations, panel discussions and lightning talks, attracted\nmore than 400 participants, a mix of developers, entrepreneurs,\nthinkers, and business executives. The talks were all recorded and are\n\nfreely\navailable\n\n\nThe presence of large companies like UBS, IBM and Microsoft clearly\nindicated enterprise interest in the technology. Microsoft announced\nthat it would offer \nEthereum on its new Blockchain as a\nService\n\noffering on the Microsoft Azure cloud platform. In conjunction with\nDEVCON-1, this announcement will be remembered as the moment when\nblockchain technology became mainstream, with Ethereum at the center of\nit.\n\n\n\n\nDEVCON-1 talks Youtube\n    playlist\n\n\nDEVCON-1 website\n full listing of\n    presentations with links to the slides if available.\n\n\n\n\nHistory resources\n\n\n\n\na simple graphical timeline", 
            "title": "\u4ee5\u592a\u7f51\u7684\u5386\u53f2"
        }, 
        {
            "location": "/introduction/history-of-ethereum/#history-of-ethereum", 
            "text": "For a recent historical account, see  Taylor Gerring\\'s\nblogpost", 
            "title": "History of Ethereum"
        }, 
        {
            "location": "/introduction/history-of-ethereum/#inception", 
            "text": "Ethereum was initially described by Vitalik Buterin in late 2013 as a\nresult of his research and work in the Bitcoin community. Shortly\nthereafter, Vitalik published the  Ethereum white\npaper , where he\ndescribes in detail the technical design and rationale for the Ethereum\nprotocol and smart contracts architecture. In January 2014, Ethereum was\nformally announced by Vitalik at the The North American Bitcoin\nConference in Miami, Florida, USA.  Around that time, Vitalik also started working with Dr. Gavin Wood and\ntogether co-founded Ethereum. By April 2014, Gavin published the Ethereum Yellow Paper  that\nwould serve as the technical specification for the Ethereum Virtual\nMachine (EVM). By following the detailed specification in the Yellow\nPaper, the Ethereum client has been implemented in seven programming\nlanguages (C++, Go, Python, Java, JavaScript, Haskell, Rust), and has\nresulted in better software overall.   Ethereum launches Cryptocurrency 2.0\n    network  -\n    Coindesk article of 2014 Jan on the beginnings  Ethereum announcement on\n    bitcointalk \n    Vitalik\\'s original announcement to the bitcoin community. Forum\n    thread with 5000 replies.", 
            "title": "Inception"
        }, 
        {
            "location": "/introduction/history-of-ethereum/#the-ethereum-foundation-and-the-ether-presale", 
            "text": "In addition to developing the software for Ethereum, the ability to\nlaunch a new cryptocurrency and blockchain requires a massive\nbootstrapping effort in order to assemble the resources needed to get it\nup and running. To kickstart a large network of developers, miners,\ninvestors, and other stakeholders, Ethereum announced its plan to\nconduct a presale of ether tokens, the currency unit of Ethereum. The\nlegal and financial complexities of raising funds through a presale led\nto the creation of several legal entities, including the\n[Ethereum Foundation (Stiftung Ethereum) \\ foundation>]{role=\"ref\"}\nestablished June 2014 in Zug, Switzerland.  Beginning in July 2014, Ethereum distributed the initial allocation of\nether via a 42-day public ether presale, netting 31,591 bitcoins, worth\n\\$18,439,086 at that time, in exchange for about 60,102,216 ether. The\nresults of the sale were initially used to pay back mounting legal debts\nand also for the months of developer effort that had yet to be\ncompensated, and to finance the ongoing development of the Ethereum.   Launching the ether\n    sale  -\n    original official announcement on the Ethereum blog  Concise information-rich stats page about the\n    presale  by (since then inactive)\n     Ether.Fund  Overview: Ethereum's initial public\n    sale  -\n    Blogpost by slacknation - all stats about the ether presale  Terms and Conditions of the\n    Presale", 
            "title": "The Ethereum Foundation and the ether presale"
        }, 
        {
            "location": "/introduction/history-of-ethereum/#ethdev-and-ethereum-development", 
            "text": "Following the successful ether presale, Ethereum development was\nformalized under a non-for-profit organization called ETH DEV, which\nmanages the development of Ethereum under contract from Ethereum Suisse\n-- with Vitalik Buterin, Gavin Wood, and Jeffrey Wilcke as the 3\ndirectors of the organization. Developer interest in Ethereum grew\nsteadily throughout 2014 and the ETH DEV team delivered a series of\nproof-of-concept (PoC) releases for the development community to\nevaluate. Frequent posts by ETH DEV team on the  the Ethereum\nblog  also kept the excitement and momentum\naround Ethereum going. Increasing traffic and growing user-base on both\nthe Ethereum forum and the ethereum subreddit testified that the\nplatform is attracting a fast-growing and devoted developer community.\nThis trend has been continuing to this very day.", 
            "title": "ETH/DEV and Ethereum development"
        }, 
        {
            "location": "/introduction/history-of-ethereum/#devcon-0", 
            "text": "In November 2014, ETH DEV organized the  DEVCON-0\nevent , which\nbrought together Ethereum developers from around the world to Berlin to\nmeet and discuss a diverse range of Ethereum technology topics. Several\nof the presentations and sessions at DEVcon-0 would later drive\nimportant initiatives to make Ethereum more reliable, more secure, and\nmore scalable. Overall, the event galvanized developers as they\ncontinued to work towards the launch of Ethereum.   DEVCON-0 talks youtube\n    playlist  DEVCON-0 reddit\n    post  Gav\\'s DEV update mentioning\n    DEVCON-0  DEVcon-0 recap blog\n    post", 
            "title": "DEVCON-0"
        }, 
        {
            "location": "/introduction/history-of-ethereum/#devgrants-program", 
            "text": "In April 2015,  the DEVgrants\nprogram  was\nannounced, which is a program that offers funding for contributions both\nto the Ethereum platform, and to projects based on Ethereum. Hundreds of\ndevelopers were already contributing their time and thinking to Ethereum\nprojects and in open source projects. This program served to reward and\nsupport those developers for their contributions. The DEVgrants program\ncontinues to operate today and funding of the program was recently\nrenewed in January 2016.   DEVgrants initial\n    announcement  Announcement of new funding at\n    DEVCON-1  DEVgrants public gitter room  DEVgrants talk at DEVCON-1 by Wendell Davis on\n    YouTube", 
            "title": "DEVgrants program"
        }, 
        {
            "location": "/introduction/history-of-ethereum/#olympic-testnet-bug-bounty-and-security-audit-olympic-testnet", 
            "text": "Throughout 2014 and 2015 development went through a series of proof of\nconcept releases leading to the 9th POC open testnet, called Olympic.\nThe developer community was  invited to test the limits of the\nnetwork \nand a substantial prize fund was allocated to award those holding\nvarious records or having success in breaking the system in some way or\nother. The  rewards were\nannounced \nofficially a month after the live release.  In early 2015, an  Ethereum Bounty Program \nwas launched, offering BTC rewards for finding vulnerabilities in any\npart of the Ethereum software stack. This has undoubtedly contributed to\nthe reliability and security of Ethereum and the confidence of the\nEthereum community in the technology. The bounty program is currently\nstill active and there is no end date planned.  The Ethereum security audit began at the end of 2014 and continued\nthrough the first half of 2015. Ethereum engaged multiple third party\nsoftware security firms to conduct an end-to-end audit of all\nprotocol-critical components (Ethereum VM, networking, Proof of Work).\nThe audits uncovered security issues that were addressed and tested\nagain and as a result ultimately led to a more secure platform.   Olympic testnet\n    prerelease  -\n    Vitalik\\'s blogpost detailing olympic rewards  Olympic rewards\n    announced  -\n    Vitalik\\'s blogpost detailing the winners and prizes  Bug bounty program\n    launch  Ethereum Bounty Program website  Least Authority audit\n    blogpost  -\n    with links to the audit report  Deja Vu audit\n    blogpost", 
            "title": "Olympic testnet, bug bounty and security audit {#olympic-testnet}"
        }, 
        {
            "location": "/introduction/history-of-ethereum/#the-ethereum-frontier-launch-frontier-launch", 
            "text": "The Ethereum Frontier network launched on July 30th, 2015, and\ndevelopers began writing smart contracts and decentralized apps to\ndeploy on the live Ethereum network. In addition, miners began to join\nthe Ethereum network to help secure the Ethereum blockchain and earn\nether from mining blocks. Even though the Frontier release is the first\nmilestone in the Ethereum project and was intended for use by developers\nas a beta version, it turned out to be more capable and reliable than\nanyone expected, and developers have rushed in to build solutions and\nimprove the Ethereum ecosystem.  See also:   Original announcement of the release\n    scheme \n    by Vinay Gupta  Frontier is\n    coming  -\n    Frontier launch announcement by Stephan Tual  Frontier launch final\n    steps  -\n    Follow-up post to announcement  Ethereum goes live with Frontier\n    launch  The frontier\n    website", 
            "title": "The Ethereum Frontier launch {#frontier-launch}"
        }, 
        {
            "location": "/introduction/history-of-ethereum/#devcon-1", 
            "text": "The second developers\\' conference DEVCON-1  took place in the city of\nLondon at the beginning of November 2015. The 5-day event featured more\nthan 100 presentations, panel discussions and lightning talks, attracted\nmore than 400 participants, a mix of developers, entrepreneurs,\nthinkers, and business executives. The talks were all recorded and are freely\navailable  The presence of large companies like UBS, IBM and Microsoft clearly\nindicated enterprise interest in the technology. Microsoft announced\nthat it would offer  Ethereum on its new Blockchain as a\nService \noffering on the Microsoft Azure cloud platform. In conjunction with\nDEVCON-1, this announcement will be remembered as the moment when\nblockchain technology became mainstream, with Ethereum at the center of\nit.   DEVCON-1 talks Youtube\n    playlist  DEVCON-1 website  full listing of\n    presentations with links to the slides if available.", 
            "title": "DEVCON-1"
        }, 
        {
            "location": "/introduction/history-of-ethereum/#history-resources", 
            "text": "a simple graphical timeline", 
            "title": "History resources"
        }, 
        {
            "location": "/introduction/community/", 
            "text": "Community\n\n\nPlease choose your forum wisely when starting a discussion or asking a\nquestion, help keep our various forums clean and tidy.\n\n\nReddit\n\n\nThe \nEthereum subreddit\n is the most\ninclusive Ethereum forum, where most of the community discussion is\nhappening and where core devs are also active. This is your forum of\nchoice for generic discussion of news, media coverage, announcements,\nbrainstorming. In general all things Ethereum relevant to the wider\ncommunity.\n\n\nStrictly no price discussion.\n\n\nAlso, this is not the ideal place to ask for hands-on help or post\nquestions you expect there are clear immediate answers to (use\n[gitter-rooms]{role=\"ref\"} and [stack-exchange]{role=\"ref\"} for these,\nrespectively).\n\n\nRead the \nEthereum subreddit\nrules\n\nbefore posting.\n\n\nFurther specialised subreddits:\n\n\n\n\n/r/EthTrader\n - Ether trading,\n    price and market\n\n\n/r/EtherMining\n - Ether\n    mining discussion\n\n\n/r/Ethmarket\n - Marketplace\n    for individuals looking to exchange goods and services for Ether\n\n\n/r/Ethinvestor\n - News and\n    prospects for Ethereum investors. Following the long term trends in\n    the Ethereum marketplace.\n\n\n/r/ethereumism/\n - A bit\n    more ism, ostic, ical, ist and tinfoil hats, pyramids and crystal\n    ball type of views - the ethereal side of Ethereum\n\n\n\n\nStack Exchange\n\n\nThe \nEthereum Stack Exchange\n is\npart of the StackExchange network of Q\nA communities. StackExchange is a\nfree Q\nA site where all the questions and answers are preserved for\nposterity.\n\n\nThis is the best place to ask technical questions. Help your fellow\netherians by answering questions and collect reputation points.\n\n\nGitter Rooms\n\n\nGitter is our forum of choice for daily chat. It is the virtual\ncoworking space where devs hang out, so it is where you can get quick\nhelp and a bit of handholding if needed.\n\n\nGitter uses Github accounts, offers Github integration (notification of\npull requests etc), private channels, provides markdown formatting, and\nmore.\n\n\nMost Gitter channels are organised around particular repositories, or\ngeneric topics like research or governance. Please choose the\nappropriate room and keep discussions on topic.\n\n\nSee \nthe full list of gitter rooms for the Ethereum\norganisation\n. Below is the list\nof active public channels:\n\n\n\n\ngo-ethereum\n - about geth\n    (and tools related to the go implementation)\n\n\ncpp-ethereum\n - about eth\n    (and tools related to the C++ implementation)\n\n\nweb3.js\n - about web3.js,\n    Ethereum JavaScript API library\n\n\nSolidity\n - The Solidity\n    Contract-Oriented Programming Language\n\n\nserpent\n - The Serpent language\n    for contract development\n\n\nmist\n - GUI dapp browser, official\n    wallet app\n\n\nlight-client\n - about\n    light client and the LES protocol\n\n\nresearch\n - Ethereum research\n\n\ngovernance\n - about dev\n    governance\n\n\nwhisper\n - anonymous datagram\n    publishing\n\n\nswarm\n - decentralised content\n    storage and distribution network\n\n\nEIPs\n - discussion of\n    _Ethereum Improvement Proposals (EIPs)\n\n\nethereumjs-lib\n - a\n    JavaScript library of core Ethereum functions\n\n\ndevp2p\n - \u00d0\u039eV\\'s p2p network\n    protocol \n framework\n\n\n\n\nEthereum Improvement Proposals (EIPs) {#Ethereum Improvement Proposals}\n\n\nThe EIP scheme aims to be a framework and largely informal business\nprocess coordinating improvements to the protocols. People should first\npropose their idea as an issue or pull request to the EIPs repository.\nAfter basic filtering, the proposal will receive a number and is\npublished in draft form. For an EIP to become Active it will require the\nmutual consent of the community. Those proposing changes should consider\nthat ultimately consent may rest with the consensus of the Ethereum\nusers. For discussion of EIPs, use the \ngitter channel for EIP\ndiscussions\n.\n\n\n\n\nEIP guidelines and sample\n    EIP\n\n\nEIP\n    template\n\n\nEIP repository and README\n\n\ngitter channel for EIP\n    discussions\n\n\n\n\nMeetups\n\n\n\n\nDirectory hosted on Meetup\n\n\nMeetup channel on Ethereum\n    Forum\n\n\n\n\nObsolete\n\n\nSkype\n\n\nSome community discussion fora still use skype rooms, but we would like\nto move away from that and encourage people to use\n\ngitter\n or \nslack\n.\n\n\nEthereum Forum\n\n\nStephan Tual\\'s legendary \nEthereum Forum\n\nis no longer maintained and likely to be decommissioned soon. We\nencourage people to use one of the recommended alternatives listed\nabove.", 
            "title": "\u793e\u533a"
        }, 
        {
            "location": "/introduction/community/#community", 
            "text": "Please choose your forum wisely when starting a discussion or asking a\nquestion, help keep our various forums clean and tidy.", 
            "title": "Community"
        }, 
        {
            "location": "/introduction/community/#reddit", 
            "text": "The  Ethereum subreddit  is the most\ninclusive Ethereum forum, where most of the community discussion is\nhappening and where core devs are also active. This is your forum of\nchoice for generic discussion of news, media coverage, announcements,\nbrainstorming. In general all things Ethereum relevant to the wider\ncommunity.  Strictly no price discussion.  Also, this is not the ideal place to ask for hands-on help or post\nquestions you expect there are clear immediate answers to (use\n[gitter-rooms]{role=\"ref\"} and [stack-exchange]{role=\"ref\"} for these,\nrespectively).  Read the  Ethereum subreddit\nrules \nbefore posting.  Further specialised subreddits:   /r/EthTrader  - Ether trading,\n    price and market  /r/EtherMining  - Ether\n    mining discussion  /r/Ethmarket  - Marketplace\n    for individuals looking to exchange goods and services for Ether  /r/Ethinvestor  - News and\n    prospects for Ethereum investors. Following the long term trends in\n    the Ethereum marketplace.  /r/ethereumism/  - A bit\n    more ism, ostic, ical, ist and tinfoil hats, pyramids and crystal\n    ball type of views - the ethereal side of Ethereum", 
            "title": "Reddit"
        }, 
        {
            "location": "/introduction/community/#stack-exchange", 
            "text": "The  Ethereum Stack Exchange  is\npart of the StackExchange network of Q A communities. StackExchange is a\nfree Q A site where all the questions and answers are preserved for\nposterity.  This is the best place to ask technical questions. Help your fellow\netherians by answering questions and collect reputation points.", 
            "title": "Stack Exchange"
        }, 
        {
            "location": "/introduction/community/#gitter-rooms", 
            "text": "Gitter is our forum of choice for daily chat. It is the virtual\ncoworking space where devs hang out, so it is where you can get quick\nhelp and a bit of handholding if needed.  Gitter uses Github accounts, offers Github integration (notification of\npull requests etc), private channels, provides markdown formatting, and\nmore.  Most Gitter channels are organised around particular repositories, or\ngeneric topics like research or governance. Please choose the\nappropriate room and keep discussions on topic.  See  the full list of gitter rooms for the Ethereum\norganisation . Below is the list\nof active public channels:   go-ethereum  - about geth\n    (and tools related to the go implementation)  cpp-ethereum  - about eth\n    (and tools related to the C++ implementation)  web3.js  - about web3.js,\n    Ethereum JavaScript API library  Solidity  - The Solidity\n    Contract-Oriented Programming Language  serpent  - The Serpent language\n    for contract development  mist  - GUI dapp browser, official\n    wallet app  light-client  - about\n    light client and the LES protocol  research  - Ethereum research  governance  - about dev\n    governance  whisper  - anonymous datagram\n    publishing  swarm  - decentralised content\n    storage and distribution network  EIPs  - discussion of\n    _Ethereum Improvement Proposals (EIPs)  ethereumjs-lib  - a\n    JavaScript library of core Ethereum functions  devp2p  - \u00d0\u039eV\\'s p2p network\n    protocol   framework", 
            "title": "Gitter Rooms"
        }, 
        {
            "location": "/introduction/community/#ethereum-improvement-proposals-eips-ethereum-improvement-proposals", 
            "text": "The EIP scheme aims to be a framework and largely informal business\nprocess coordinating improvements to the protocols. People should first\npropose their idea as an issue or pull request to the EIPs repository.\nAfter basic filtering, the proposal will receive a number and is\npublished in draft form. For an EIP to become Active it will require the\nmutual consent of the community. Those proposing changes should consider\nthat ultimately consent may rest with the consensus of the Ethereum\nusers. For discussion of EIPs, use the  gitter channel for EIP\ndiscussions .   EIP guidelines and sample\n    EIP  EIP\n    template  EIP repository and README  gitter channel for EIP\n    discussions", 
            "title": "Ethereum Improvement Proposals (EIPs) {#Ethereum Improvement Proposals}"
        }, 
        {
            "location": "/introduction/community/#meetups", 
            "text": "Directory hosted on Meetup  Meetup channel on Ethereum\n    Forum", 
            "title": "Meetups"
        }, 
        {
            "location": "/introduction/community/#obsolete", 
            "text": "", 
            "title": "Obsolete"
        }, 
        {
            "location": "/introduction/community/#skype", 
            "text": "Some community discussion fora still use skype rooms, but we would like\nto move away from that and encourage people to use gitter  or  slack .", 
            "title": "Skype"
        }, 
        {
            "location": "/introduction/community/#ethereum-forum", 
            "text": "Stephan Tual\\'s legendary  Ethereum Forum \nis no longer maintained and likely to be decommissioned soon. We\nencourage people to use one of the recommended alternatives listed\nabove.", 
            "title": "Ethereum Forum"
        }, 
        {
            "location": "/introduction/foundation/", 
            "text": "The Ethereum Foundation {#foundation}\n\n\nThe Ethereum Foundation is a non-profit organization registered in\nSwitzerland, and has the purpose of managing the funds that were raised\nfrom the ether Sale in order to best serve the Ethereum and\ndecentralized technology ecosystem.\n\n\nFounded July 2014 in Switzerland, Stiftung Ethereum's mission is the\npromotion of developments of new technologies and applications,\nespecially in the fields of new open and decentralized software\narchitectures.\n\n\nIt is the aim that decentralized and open technologies will be\ndeveloped, nurtured, promoted and maintained. A dominating, but not\nexclusive, focus is set on the promotion of the development of the\nEthereum Protocol and the relevant technology to it as well as the\npromotion and support of applications using the Ethereum technology or\nprotocol. Stiftung Ethereum will additionally support and advocate for a\ndecentralized Internet in a variety of forms.\n\n\nFind out about more about the \nFoundation Management Team on the\nwebsite\n\n\nEthereum Foundation\\'s faces to the community\n\n\n\n\nOfficial Homestead website\n - main entrypoint\n\n\nReddit\n - see\n    [community]{role=\"ref\"}\n\n\nBlog\n\n\nTwitter\n\n\nYoutube\n\n\nFacebook\n - largely\n    unused\n\n\nEmail\n - use if you must\n\n\n\n\nOfficial communication from the Ethereum foundation most often comes in\nthe form of a comprehensive blogpost on the \nEthereum\nblog\n. Some of the posts there are\ntechnical, some organisational, some personal. All blog posts are\nannounced on \nTwitter\n and\n\nReddit\n.\n\n\nThe foundation \nYoutube\nchannel\n hosts our videos,\nincluding all talks of the developers conferences DEVCON0 and DEVCON1.\n\n\nFor community discussion forums, see [community]{role=\"ref\"}.", 
            "title": "\u4ee5\u592a\u574a\u57fa\u91d1\u4f1a"
        }, 
        {
            "location": "/introduction/foundation/#the-ethereum-foundation-foundation", 
            "text": "The Ethereum Foundation is a non-profit organization registered in\nSwitzerland, and has the purpose of managing the funds that were raised\nfrom the ether Sale in order to best serve the Ethereum and\ndecentralized technology ecosystem.  Founded July 2014 in Switzerland, Stiftung Ethereum's mission is the\npromotion of developments of new technologies and applications,\nespecially in the fields of new open and decentralized software\narchitectures.  It is the aim that decentralized and open technologies will be\ndeveloped, nurtured, promoted and maintained. A dominating, but not\nexclusive, focus is set on the promotion of the development of the\nEthereum Protocol and the relevant technology to it as well as the\npromotion and support of applications using the Ethereum technology or\nprotocol. Stiftung Ethereum will additionally support and advocate for a\ndecentralized Internet in a variety of forms.  Find out about more about the  Foundation Management Team on the\nwebsite", 
            "title": "The Ethereum Foundation {#foundation}"
        }, 
        {
            "location": "/introduction/foundation/#ethereum-foundations-faces-to-the-community", 
            "text": "Official Homestead website  - main entrypoint  Reddit  - see\n    [community]{role=\"ref\"}  Blog  Twitter  Youtube  Facebook  - largely\n    unused  Email  - use if you must   Official communication from the Ethereum foundation most often comes in\nthe form of a comprehensive blogpost on the  Ethereum\nblog . Some of the posts there are\ntechnical, some organisational, some personal. All blog posts are\nannounced on  Twitter  and Reddit .  The foundation  Youtube\nchannel  hosts our videos,\nincluding all talks of the developers conferences DEVCON0 and DEVCON1.  For community discussion forums, see [community]{role=\"ref\"}.", 
            "title": "Ethereum Foundation\\'s faces to the community"
        }, 
        {
            "location": "/introduction/contributors/", 
            "text": "Contributors\n\n\nThis documentation was built collectively by the Ethereum community as\npart of a project called the \nHomestead Documentation\nInitiative\n\nwhich was coordinated by:\n\n\n\n\nViktor Tr\u00f3n (\\\"zelig\\\")\n\n\nHudson Jameson (\\\"Souptacular\\\")\n\n\n\n\nWe would like to thank everybody who helped in this effort for \ntheir\ncontributions\n:\n\n\n\n\nRicardo de Azevedo Brandao\n\n\nSantanu Barai\n\n\nBrooks Boyd\n\n\nRJ Catalano\n\n\nJoseph Chow\n\n\nKeri Clowes\n\n\nFran\u00e7ois Deppierraz\n\n\nBertie Dinneen\n\n\nGregg Dourgarian\n\n\nRaghav Dua\n\n\nErik Edrosa\n\n\nAndrey Fedorov\n\n\nRocky Fikki\n\n\nAlex Fisher\n\n\nEnrique Fynn\n\n\nArno Gaboury\n\n\nTaylor Gerring\n\n\nDave Hoover\n\n\nJo\u00ebl Hubert\n\n\nMakoto Inoue\n\n\nKeith Irwin\n\n\nMatthias K\u00e4ppler\n\n\nBas van Kervel\n\n\nMichael Kilday\n\n\nChandra Kumar\n\n\nGuangmian Kung\n\n\nHugh Lang\n\n\nYann Levreau\n\n\nRoman Mandeleil\n\n\nK\u00e9vin Maschtaler\n\n\nAndrew Mazzola\n\n\nDominik Miszkiewicz\n\n\nJohn Mooney\n\n\nSteven Natera\n\n\nChris Peel\n\n\nCraig Polley\n\n\nColm Ragu\n\n\nLaurent Raufaste\n\n\nChristian Reitwiessner\n\n\nJosh Stark\n\n\nScott Stevenson\n\n\nBob Summerwill\n\n\nAlex van de Sande\n\n\nPaul Schmitzer\n\n\nAfri Schoedon\n\n\nSudeep Singh\n\n\nConor Svensson\n\n\nGiacomo Tazzari\n\n\nBen Tannenbaum\n\n\nDean Alain Vernon\n\n\nDaniel Weinmann\n\n\nPaul Worrall\n\n\nHaoyu Yang\n\n\nLuca Zeug\n\n\nWeiyang Zhu\n\n\nWill Zeng\n\n\n\n\nAnd these pseudonymous contributors:\n\n\n\n\n12v\n\n\nana0\n\n\nc0d3inj3cT\n\n\nijcoe6ru\n\n\nLucaTony\n\n\nmadhancr\n\n\nmista66\n\n\nmWo\n\n\nOmkara\n\n\ntflux99\n\n\nTim H\n\n\nxyzether", 
            "title": "\u8d21\u732e\u8005"
        }, 
        {
            "location": "/introduction/contributors/#contributors", 
            "text": "This documentation was built collectively by the Ethereum community as\npart of a project called the  Homestead Documentation\nInitiative \nwhich was coordinated by:   Viktor Tr\u00f3n (\\\"zelig\\\")  Hudson Jameson (\\\"Souptacular\\\")   We would like to thank everybody who helped in this effort for  their\ncontributions :   Ricardo de Azevedo Brandao  Santanu Barai  Brooks Boyd  RJ Catalano  Joseph Chow  Keri Clowes  Fran\u00e7ois Deppierraz  Bertie Dinneen  Gregg Dourgarian  Raghav Dua  Erik Edrosa  Andrey Fedorov  Rocky Fikki  Alex Fisher  Enrique Fynn  Arno Gaboury  Taylor Gerring  Dave Hoover  Jo\u00ebl Hubert  Makoto Inoue  Keith Irwin  Matthias K\u00e4ppler  Bas van Kervel  Michael Kilday  Chandra Kumar  Guangmian Kung  Hugh Lang  Yann Levreau  Roman Mandeleil  K\u00e9vin Maschtaler  Andrew Mazzola  Dominik Miszkiewicz  John Mooney  Steven Natera  Chris Peel  Craig Polley  Colm Ragu  Laurent Raufaste  Christian Reitwiessner  Josh Stark  Scott Stevenson  Bob Summerwill  Alex van de Sande  Paul Schmitzer  Afri Schoedon  Sudeep Singh  Conor Svensson  Giacomo Tazzari  Ben Tannenbaum  Dean Alain Vernon  Daniel Weinmann  Paul Worrall  Haoyu Yang  Luca Zeug  Weiyang Zhu  Will Zeng   And these pseudonymous contributors:   12v  ana0  c0d3inj3cT  ijcoe6ru  LucaTony  madhancr  mista66  mWo  Omkara  tflux99  Tim H  xyzether", 
            "title": "Contributors"
        }, 
        {
            "location": "/clients/choosing-a-client/", 
            "text": "Choosing a client {#sec:clients}\n\n\nWhy are there multiple Ethereum clients?\n\n\nFrom the earliest days of the project there have been multiple client\nimplementations across a range of different operating systems. That\nclient diversity is a huge win for the ecosystem as a whole. It lets us\nverify that the protocol (specified in the \nYellow\nPaper\n) is unambiguous. It\nkeeps the door open for new innovation. It keeps us all honest. However,\nit can be very confusing for end-users, because there is no universal\n\\\"Ethereum Installer\\\" for them to use.\n\n\nAs of September 2016, the leading implementations are\n[go-ethereum]{role=\"ref\"} and [Parity]{role=\"ref\"}.\n\n\n\n\nClient                          Language     Developers                                     Latest release\n\n\n\n\n[go-ethereum]{role=\"ref\"}       Go           \nEthereum                                      [go-ethereum-v1.4.18](https://github.com/ethereum/go-ethereum/releases/tag/v1.4.18)\n                                               Foundation\n   \n\n\n[Parity]{role=\"ref\"}            Rust         \nEthcore\n                 \nParity-v1.4.0\n\n\n[cpp-ethereum]{role=\"ref\"}      C++          \nEthereum                                      [cpp-ethereum-v1.3.0](https://github.com/bobsummerwill/cpp-ethereum/releases/tag/v1.3.0)\n                                               Foundation\n   \n\n\n[pyethapp]{role=\"ref\"}          Python       \nEthereum                                      [pyethapp-v1.5.0](https://github.com/ethereum/pyethapp/releases/tag/v1.5.0)\n                                               Foundation\n   \n\n\n[ethereumjs-lib]{role=\"ref\"}    Javascript   \nEthereum                                      [ethereumjs-lib-v3.0.0](https://github.com/ethereumjs/ethereumjs-lib/releases/tag/v3.0.0)\n                                               Foundation\n   \n\n\n[Ethereum\\(J\\)]{role=\"ref\"}   Java         \n\\\\\nether.camp\\>\n    \nethereumJ-v1.3.1\n\n\n[ruby-ethereum]{role=\"ref\"}     Ruby         \nJan Xie\n            \nruby-ethereum-v0.9.6\n\n\n[ethereumH]{role=\"ref\"}         Haskell      \nBlockApps\n         no Homestead release yet\n\n\n\n\nWhat should I install on my desktop/laptop?\n\n\nMost users will likely just install \nMist / Ethereum\nWallet\n and that will be enough for\ntheir needs.\n\n\nThe Ethereum Wallet is a \\\"single dapp\\\" deployment of the \nMist\nBrowser\n which will be the centerpiece of the Metropolis phase of\ndevelopment, which comes after Homestead.\n\n\nMist comes with bundled [go-ethereum]{role=\"ref\"} and\n[cpp-ethereum]{role=\"ref\"} binaries and if you are not running a\ncommand-line Ethereum client when Mist starts then it will start syncing\nthe blockchain using one of the bundled clients (defaulting to\n\ngeth\n). If you want to use Parity with Mist, or to run Mist against a\nprivate network, just start your node before Mist, and Mist will connect\nto your node rather than starting one itself.\n\n\nWork is underway to add Parity and other clients as \\\"first-class\nentities\\\" to Mist too.\n\n\nIf you want to interact with Ethereum on the command-line, and to take\nadvantage of the Javascript console then you will want to install one of\nthe client applications directly, as well as Mist. Follow the links in\nthe table above for further instructions.\n\n\nIf you want to do mining then Mist will not be sufficient. Check out the\n[mining]{role=\"ref\"} section.\n\n\nWhat should I install on my mobile/tablet?\n\n\nWe are at the very beginning of our support for mobile devices. The Go\nteam are publishing experimental iOS and Android libraries, which some\ndevelopers are using to start bootstrapping mobile applications, but\nthere are not yet any mobile Ethereum clients available.\n\n\nThe main hinderance to the use of Ethereum on mobile devices is that the\nLight Client support is still incomplete. The work which has been done\nis off in a private branch, and is only available for the Go client.\ndoublethinkco will be starting development of Light Client for the C++\nclient in the coming months, following grant funding.\n\n\nCheck out \nStatus.im\n, who were initially using\n\nethereumj-personal\n\nbased on [Ethereum(J)]{role=\"ref\"}, but have recently flipped to Geth\ncross-builds with Light Client.\n\n\nWhat should I install on my SBC?\n\n\nYou have some choice here depending on your skill level, and what you\nare looking to do.\n\n\n\n\nDownload a fully prepared image(link to page with detailed download\n    \n install instructions)\n\n\nIf you are new to Ethereum AND SBC boards such as the Raspberry\n    Pi then this is for you! Simply download the image specific to\n    the dev board you are working with, burn it to an SD card, boot\n    your device, and run Ethereum!\n\n\n\n\n\n\nDownload a pre-compiled application(link to page with detailed\n    download \n install instructions)\n\n\nIf you already have an SBC running and have a specific,\n    preferred OS or setup that you want to keep, then this is your\n    best option! Depending on the platform, you can simply download\n    the apropriate executable, and with minimal linking of libraries\n    and setting of PATH you can have Ethereum running in your\n    existing environment!\n\n\n\n\n\n\nBuild from source using customizable scripts(link to page with more\n    detail and individual SBC links to \nhttps://github.com/ethembedded\n)\n\n\nLooking to perform a custom install? We have scripts available\n    to compile from source \\\"on device\\\". Our scripts contain\n    auto-install of dependencies as well as the client itself. This\n    will allow you to install a specific version of the Ethereum\n    client(i.e.-\\\"develop\\\", \\\"master\\\", etc.), compile your own\n    forked version of a client, and generally play around with the\n    intracacies of the build process.\n\n\n\n\n\n\n\n\nInteracting with Clients\n\n\nIn order to interact with Ethereum clients programatically, please refer\nto the [Connecting to Clients]{role=\"ref\"} section.", 
            "title": "\u9009\u62e9\u4e00\u4e2a\u5ba2\u6237\u7aef"
        }, 
        {
            "location": "/clients/choosing-a-client/#choosing-a-client-secclients", 
            "text": "", 
            "title": "Choosing a client {#sec:clients}"
        }, 
        {
            "location": "/clients/choosing-a-client/#why-are-there-multiple-ethereum-clients", 
            "text": "From the earliest days of the project there have been multiple client\nimplementations across a range of different operating systems. That\nclient diversity is a huge win for the ecosystem as a whole. It lets us\nverify that the protocol (specified in the  Yellow\nPaper ) is unambiguous. It\nkeeps the door open for new innovation. It keeps us all honest. However,\nit can be very confusing for end-users, because there is no universal\n\\\"Ethereum Installer\\\" for them to use.  As of September 2016, the leading implementations are\n[go-ethereum]{role=\"ref\"} and [Parity]{role=\"ref\"}.   Client                          Language     Developers                                     Latest release   [go-ethereum]{role=\"ref\"}       Go            Ethereum                                      [go-ethereum-v1.4.18](https://github.com/ethereum/go-ethereum/releases/tag/v1.4.18)\n                                               Foundation      [Parity]{role=\"ref\"}            Rust          Ethcore                   Parity-v1.4.0  [cpp-ethereum]{role=\"ref\"}      C++           Ethereum                                      [cpp-ethereum-v1.3.0](https://github.com/bobsummerwill/cpp-ethereum/releases/tag/v1.3.0)\n                                               Foundation      [pyethapp]{role=\"ref\"}          Python        Ethereum                                      [pyethapp-v1.5.0](https://github.com/ethereum/pyethapp/releases/tag/v1.5.0)\n                                               Foundation      [ethereumjs-lib]{role=\"ref\"}    Javascript    Ethereum                                      [ethereumjs-lib-v3.0.0](https://github.com/ethereumjs/ethereumjs-lib/releases/tag/v3.0.0)\n                                               Foundation      [Ethereum\\(J\\)]{role=\"ref\"}   Java          \\\\ ether.camp\\>      ethereumJ-v1.3.1  [ruby-ethereum]{role=\"ref\"}     Ruby          Jan Xie              ruby-ethereum-v0.9.6  [ethereumH]{role=\"ref\"}         Haskell       BlockApps          no Homestead release yet", 
            "title": "Why are there multiple Ethereum clients?"
        }, 
        {
            "location": "/clients/choosing-a-client/#what-should-i-install-on-my-desktoplaptop", 
            "text": "Most users will likely just install  Mist / Ethereum\nWallet  and that will be enough for\ntheir needs.  The Ethereum Wallet is a \\\"single dapp\\\" deployment of the  Mist\nBrowser  which will be the centerpiece of the Metropolis phase of\ndevelopment, which comes after Homestead.  Mist comes with bundled [go-ethereum]{role=\"ref\"} and\n[cpp-ethereum]{role=\"ref\"} binaries and if you are not running a\ncommand-line Ethereum client when Mist starts then it will start syncing\nthe blockchain using one of the bundled clients (defaulting to geth ). If you want to use Parity with Mist, or to run Mist against a\nprivate network, just start your node before Mist, and Mist will connect\nto your node rather than starting one itself.  Work is underway to add Parity and other clients as \\\"first-class\nentities\\\" to Mist too.  If you want to interact with Ethereum on the command-line, and to take\nadvantage of the Javascript console then you will want to install one of\nthe client applications directly, as well as Mist. Follow the links in\nthe table above for further instructions.  If you want to do mining then Mist will not be sufficient. Check out the\n[mining]{role=\"ref\"} section.", 
            "title": "What should I install on my desktop/laptop?"
        }, 
        {
            "location": "/clients/choosing-a-client/#what-should-i-install-on-my-mobiletablet", 
            "text": "We are at the very beginning of our support for mobile devices. The Go\nteam are publishing experimental iOS and Android libraries, which some\ndevelopers are using to start bootstrapping mobile applications, but\nthere are not yet any mobile Ethereum clients available.  The main hinderance to the use of Ethereum on mobile devices is that the\nLight Client support is still incomplete. The work which has been done\nis off in a private branch, and is only available for the Go client.\ndoublethinkco will be starting development of Light Client for the C++\nclient in the coming months, following grant funding.  Check out  Status.im , who were initially using ethereumj-personal \nbased on [Ethereum(J)]{role=\"ref\"}, but have recently flipped to Geth\ncross-builds with Light Client.", 
            "title": "What should I install on my mobile/tablet?"
        }, 
        {
            "location": "/clients/choosing-a-client/#what-should-i-install-on-my-sbc", 
            "text": "You have some choice here depending on your skill level, and what you\nare looking to do.   Download a fully prepared image(link to page with detailed download\n      install instructions)  If you are new to Ethereum AND SBC boards such as the Raspberry\n    Pi then this is for you! Simply download the image specific to\n    the dev board you are working with, burn it to an SD card, boot\n    your device, and run Ethereum!    Download a pre-compiled application(link to page with detailed\n    download   install instructions)  If you already have an SBC running and have a specific,\n    preferred OS or setup that you want to keep, then this is your\n    best option! Depending on the platform, you can simply download\n    the apropriate executable, and with minimal linking of libraries\n    and setting of PATH you can have Ethereum running in your\n    existing environment!    Build from source using customizable scripts(link to page with more\n    detail and individual SBC links to  https://github.com/ethembedded )  Looking to perform a custom install? We have scripts available\n    to compile from source \\\"on device\\\". Our scripts contain\n    auto-install of dependencies as well as the client itself. This\n    will allow you to install a specific version of the Ethereum\n    client(i.e.-\\\"develop\\\", \\\"master\\\", etc.), compile your own\n    forked version of a client, and generally play around with the\n    intracacies of the build process.", 
            "title": "What should I install on my SBC?"
        }, 
        {
            "location": "/clients/choosing-a-client/#interacting-with-clients", 
            "text": "In order to interact with Ethereum clients programatically, please refer\nto the [Connecting to Clients]{role=\"ref\"} section.", 
            "title": "Interacting with Clients"
        }, 
        {
            "location": "/clients/cpp-ethereum/", 
            "text": "cpp-ethereum\n\n\n{width=\"200px\" height=\"200px\"}\n\n\n{width=\"200px\"\nheight=\"200px\"}\n\n\nQuick Start\n\n\n\n\nWelcome to the Ethereum C++ project :-)\n\n\nThe GitHub repository for this project is\n    \nethereum/cpp-ethereum\n\n\nAutomation runs on\n    \nAppveyor\n\n    and\n    \nTravisCI\n.\n\n\nWe have instructions for [Installing binaries]{role=\"ref\"} and\n    [Building from source]{role=\"ref\"}.\n\n\nMost project communication happens in our\n    \nUser\n and\n    \nDeveloper\n\n    Gitter channels.\n\n\nIssues are tracked in our \nGithub issue\n    tracker\n.\n\n\ncpp-ethereum is extremely portable and is used on a\n    [very broad range of platforms \\\ncpp-ethereum-portability>]{role=\"ref\"}.\n\n\n\n\nDetails\n\n\n::: {.toctree}\ncurrent-status.rst building-from-source/index.rst\ninstalling-binaries/index.rst contributing.rst architecture.rst\nportability.rst running.rst\n:::", 
            "title": "cpp-ethereum"
        }, 
        {
            "location": "/clients/cpp-ethereum/#cpp-ethereum", 
            "text": "{width=\"200px\" height=\"200px\"}  {width=\"200px\"\nheight=\"200px\"}", 
            "title": "cpp-ethereum"
        }, 
        {
            "location": "/clients/cpp-ethereum/#quick-start", 
            "text": "Welcome to the Ethereum C++ project :-)  The GitHub repository for this project is\n     ethereum/cpp-ethereum  Automation runs on\n     Appveyor \n    and\n     TravisCI .  We have instructions for [Installing binaries]{role=\"ref\"} and\n    [Building from source]{role=\"ref\"}.  Most project communication happens in our\n     User  and\n     Developer \n    Gitter channels.  Issues are tracked in our  Github issue\n    tracker .  cpp-ethereum is extremely portable and is used on a\n    [very broad range of platforms \\ cpp-ethereum-portability>]{role=\"ref\"}.", 
            "title": "Quick Start"
        }, 
        {
            "location": "/clients/cpp-ethereum/#details", 
            "text": "::: {.toctree}\ncurrent-status.rst building-from-source/index.rst\ninstalling-binaries/index.rst contributing.rst architecture.rst\nportability.rst running.rst\n:::", 
            "title": "Details"
        }, 
        {
            "location": "/clients/go-ethereum/", 
            "text": "go-ethereum\n\n\nThe go-ethereum client is commonly referred to as \ngeth\n, which is the\nthe command line interface for running a full ethereum node implemented\nin Go. By installing and running geth, you can take part in the ethereum\nfrontier live network and:\n\n\n\n\nmine real ether\n\n\ntransfer funds between addresses\n\n\ncreate contracts and send transactions\n\n\nexplore block history\n\n\nand much much more\n\n\n\n\nLinks:\n\n\n\n\nWebsite: \nhttp://ethereum.github.io/go-ethereum/\n\n\nGitHub: \nhttps://github.com/ethereum/go-ethereum\n\n\nWiki: \nhttps://github.com/ethereum/go-ethereum/wiki/geth\n\n\nGitter: \nhttps://gitter.im/ethereum/go-ethereum", 
            "title": "go-ethereum"
        }, 
        {
            "location": "/clients/go-ethereum/#go-ethereum", 
            "text": "The go-ethereum client is commonly referred to as  geth , which is the\nthe command line interface for running a full ethereum node implemented\nin Go. By installing and running geth, you can take part in the ethereum\nfrontier live network and:   mine real ether  transfer funds between addresses  create contracts and send transactions  explore block history  and much much more   Links:   Website:  http://ethereum.github.io/go-ethereum/  GitHub:  https://github.com/ethereum/go-ethereum  Wiki:  https://github.com/ethereum/go-ethereum/wiki/geth  Gitter:  https://gitter.im/ethereum/go-ethereum", 
            "title": "go-ethereum"
        }, 
        {
            "location": "/clients/pyethapp/", 
            "text": "pyethapp\n\n\npyethapp\n is the python-based client implementing the Ethereum\ncryptoeconomic state machine. The python implementation aims to provide\nan easily hackable and extendable codebase.\n\n\npyethapp leverages two ethereum core components to implement the client:\n\n\n\n\npyethereum\n - the core\n    library, featuring the blockchain, the ethereum virtual machine,\n    mining\n\n\npydevp2p\n - the p2p\n    networking library, featuring node discovery for and transport of\n    multiple services over multiplexed and encrypted connections\n\n\n\n\nLinks:\n\n\n\n\nGitHub: \nhttps://github.com/ethereum/pyethapp\n\n\nWiki: \nhttps://github.com/ethereum/pyethapp/wiki/Getting-Started\n\n\nGitter chat: \nhttps://gitter.im/ethereum/pyethapp", 
            "title": "pyethapp"
        }, 
        {
            "location": "/clients/pyethapp/#pyethapp", 
            "text": "pyethapp  is the python-based client implementing the Ethereum\ncryptoeconomic state machine. The python implementation aims to provide\nan easily hackable and extendable codebase.  pyethapp leverages two ethereum core components to implement the client:   pyethereum  - the core\n    library, featuring the blockchain, the ethereum virtual machine,\n    mining  pydevp2p  - the p2p\n    networking library, featuring node discovery for and transport of\n    multiple services over multiplexed and encrypted connections   Links:   GitHub:  https://github.com/ethereum/pyethapp  Wiki:  https://github.com/ethereum/pyethapp/wiki/Getting-Started  Gitter chat:  https://gitter.im/ethereum/pyethapp", 
            "title": "pyethapp"
        }, 
        {
            "location": "/clients/ethereumjs-lib/", 
            "text": "ethereumjs-lib\n\n\nethereumjs-lib\n is the javascript library of core\n\nEthereum\n functions as described in the \nYellow\nPaper\n. This is a simple\nmeta-module that provides the following modules. Most JS modules are\ntracked in \nethereumjs\n\n\n\n\nVM\n - The Ethereum\n    virtual machine and state processing functions\n\n\nBlockchain\n -\n    Blockchain managment\n\n\nBlock\n - Block\n    Schema definition and validation\n\n\nTransaction\n -\n    Transaction Schema definition and validation\n\n\nAccount\n -\n    Account Schema definition and validation\n\n\nrlp\n - Recursive Length Prefix\n    serialization\n\n\nTrie\n -\n    Modified Merkle Patricia Tree\n\n\nEthash\n - Ethereum\\'s Proof\n    of Work algorithm\n\n\nutils\n -\n    Miscellaneous helper functions\n\n\ndevp2p\n - The networking\n    protocol\n\n\ndevp2p-dpt\n - The\n    disputed peer table\n\n\n\n\nLinks:\n\n\n\n\nGitHub: \nhttps://github.com/ethereumjs/ethereumjs-lib\n\n\nJoin the Gitter chat: \nhttps://gitter.im/ethereum/ethereumjs-lib", 
            "title": "ethereumjs-lib"
        }, 
        {
            "location": "/clients/ethereumjs-lib/#ethereumjs-lib", 
            "text": "ethereumjs-lib  is the javascript library of core Ethereum  functions as described in the  Yellow\nPaper . This is a simple\nmeta-module that provides the following modules. Most JS modules are\ntracked in  ethereumjs   VM  - The Ethereum\n    virtual machine and state processing functions  Blockchain  -\n    Blockchain managment  Block  - Block\n    Schema definition and validation  Transaction  -\n    Transaction Schema definition and validation  Account  -\n    Account Schema definition and validation  rlp  - Recursive Length Prefix\n    serialization  Trie  -\n    Modified Merkle Patricia Tree  Ethash  - Ethereum\\'s Proof\n    of Work algorithm  utils  -\n    Miscellaneous helper functions  devp2p  - The networking\n    protocol  devp2p-dpt  - The\n    disputed peer table   Links:   GitHub:  https://github.com/ethereumjs/ethereumjs-lib  Join the Gitter chat:  https://gitter.im/ethereum/ethereumjs-lib", 
            "title": "ethereumjs-lib"
        }, 
        {
            "location": "/clients/ethereumj/", 
            "text": "Ethereum(J) {#Ethereum(J)}\n\n\nEthereum(J)\n is a pure-Java implementation of the Ethereum protocol.\nIt is provided as a library that can be embedded in any Java/Scala\nproject and to provide full support for Ethereum protocol and\nsub-services. Ethereum(J) was first developed by \nRoman\nMandeleil\n and is now sponsored by\n\n\\\nether.camp> \\\nhttp://www.ether.camp>\n.\n\n\nEthereum(J) supports CPU mining. It is currently implemented in pure\nJava and can be used in private and test networks. You may even mine on\nthe live Ethereum network, even though it is not economically feasible.\n\n\nLinks:\n\n\n\n\nBlog: \nhttp://ethereumj.io/\n\n\nGitHub: \nhttps://github.com/ethereum/ethereumj\n\n\nGitter chat: \nhttps://gitter.im/ethereum/ethereumj", 
            "title": "ethereum(j)"
        }, 
        {
            "location": "/clients/ethereumj/#ethereumj-ethereum40j41", 
            "text": "Ethereum(J)  is a pure-Java implementation of the Ethereum protocol.\nIt is provided as a library that can be embedded in any Java/Scala\nproject and to provide full support for Ethereum protocol and\nsub-services. Ethereum(J) was first developed by  Roman\nMandeleil  and is now sponsored by \\ ether.camp> \\ http://www.ether.camp> .  Ethereum(J) supports CPU mining. It is currently implemented in pure\nJava and can be used in private and test networks. You may even mine on\nthe live Ethereum network, even though it is not economically feasible.  Links:   Blog:  http://ethereumj.io/  GitHub:  https://github.com/ethereum/ethereumj  Gitter chat:  https://gitter.im/ethereum/ethereumj", 
            "title": "Ethereum(J) {#Ethereum(J)}"
        }, 
        {
            "location": "/clients/ethereumh/", 
            "text": "ethereumH {#ethereumH}\n\n\nThis package provides a tool written in Haskell to allow you to connect\nto the Ethereum blockchain\n\n\nLinks:\n\n\n\n\nGitHub: \nhttps://github.com/blockapps/ethereumH\n\n\nBlockApps: \nhttp://www.blockapps.net/", 
            "title": "ethereumH"
        }, 
        {
            "location": "/clients/ethereumh/#ethereumh-ethereumh", 
            "text": "This package provides a tool written in Haskell to allow you to connect\nto the Ethereum blockchain  Links:   GitHub:  https://github.com/blockapps/ethereumH  BlockApps:  http://www.blockapps.net/", 
            "title": "ethereumH {#ethereumH}"
        }, 
        {
            "location": "/clients/parity/", 
            "text": "Parity {#Parity}\n\n\nParity\n claims to be the world\\'s fastest and lightest Ethereum\nclient. It is written in the Rust language, which offers improved\nreliability, performance, and code clarity. Parity is being developed by\n\nParity Technologies (f.k.a. Ethcore)\n, which\nwas founded by several members of the Ethereum Foundation.\n\n\n\n\nWebsite: \nhttps://parity.io/\n\n\nGitHub: \nhttps://github.com/paritytech/parity\n\n\nGitter chat: \nhttps://gitter.im/paritytech/parity\n\n\n\n\nArch Linux packages are maintained by \nAfri\nSchoedon\n.\n\n\n\n\nhttps://www.archlinux.org/packages/community/x86_64/parity/\n\n\n\n\nSome people have reported success with Parity on Raspberry Pi 2.", 
            "title": "parity"
        }, 
        {
            "location": "/clients/parity/#parity-parity", 
            "text": "Parity  claims to be the world\\'s fastest and lightest Ethereum\nclient. It is written in the Rust language, which offers improved\nreliability, performance, and code clarity. Parity is being developed by Parity Technologies (f.k.a. Ethcore) , which\nwas founded by several members of the Ethereum Foundation.   Website:  https://parity.io/  GitHub:  https://github.com/paritytech/parity  Gitter chat:  https://gitter.im/paritytech/parity   Arch Linux packages are maintained by  Afri\nSchoedon .   https://www.archlinux.org/packages/community/x86_64/parity/   Some people have reported success with Parity on Raspberry Pi 2.", 
            "title": "Parity {#Parity}"
        }, 
        {
            "location": "/clients/ruby-ethereum/", 
            "text": "ruby-ethereum\n\n\nruby-ethereum\n is an implementation of the\n[Ethereum Virtual Machine \\\nthe-EVM>]{role=\"ref\"} written in Ruby.\n\n\nLinks:\n\n\n\n\nGitHub: \nhttps://github.com/janx/ruby-ethereum\n\n\nGem: \nhttps://rubygems.org/gems/ruby-ethereum\n\n\n\n\nRelated:\n\n\n\n\nruby-serpent\n: Ruby binding\n    to the \nEthereum\n    Serpent\n compiler.\n\n\n[ethereum-ruby]{role=\"ref\"}: a pure-Ruby JSON-RPC wrapper for\n    communicating with an Ethereum node.", 
            "title": "ruby-ethereum"
        }, 
        {
            "location": "/clients/ruby-ethereum/#ruby-ethereum", 
            "text": "ruby-ethereum  is an implementation of the\n[Ethereum Virtual Machine \\ the-EVM>]{role=\"ref\"} written in Ruby.  Links:   GitHub:  https://github.com/janx/ruby-ethereum  Gem:  https://rubygems.org/gems/ruby-ethereum   Related:   ruby-serpent : Ruby binding\n    to the  Ethereum\n    Serpent  compiler.  [ethereum-ruby]{role=\"ref\"}: a pure-Ruby JSON-RPC wrapper for\n    communicating with an Ethereum node.", 
            "title": "ruby-ethereum"
        }, 
        {
            "location": "/connecting-to-clients/", 
            "text": "Connecting to Ethereum Clients {#Connecting to Clients}\n\n\nEthereum clients expose a number of methods over\n\nJSON-RPC\n for\ninteracting with them from within an application. However, interacting\ndirectly over JSON-RPC passes on a number of burdens to the application\ndevelopers, such as:\n\n\n\n\n\n\nJSON-RPC protocol implementation\n\n\nBinary format encoding/decoding for creating and interacting with\n    smart contracts\n\n\n256 bit numeric types\n\n\nAdmin command support - e.g. create/manage addresses, sign\n    transactions\n\n\n\n\n\n\nA number of libraries have been written to help address these issues,\nallowing application developers to focus on their applications, instead\nof the underlying plumbing to interact with Ethereum clients and the\nwider ecosystem.\n\n\n\n\nLibrary                       Language     Project Page\n\n\n\n\n[web3.js]{role=\"ref\"}         JavaScript   \nhttps://github.com/ethereum/web3.js\n\n\n[web3j]{role=\"ref\"}           Java         \nhttps://github.com/web3j/web3j\n\n\n[Nethereum]{role=\"ref\"}       C# .NET     \nhttps://github.com/Nethereum/Nethereum\n\n\n[ethereum-ruby]{role=\"ref\"}   Ruby         \nhttps://github.com/DigixGlobal/ethereum-ruby\n\n\n[web3.py]{role=\"ref\"}         Python       \nhttps://github.com/ethereum/web3.py\n\n\n\n\nInformation on each library is provided in the following sections:\n\n\n::: {.toctree}\nweb3.js/index.rst web3j/index.rst nethereum/index.rst\nethereum-ruby/index.rst web3.py/index.rst\n:::\n\n\nFor an overview of creating and interacting with smart contracts and\ntransactions via the web3.js library, please refer to the section\n[Accessing Contracts and Transactions]{role=\"ref\"}.", 
            "title": "\u7b80\u4ecb"
        }, 
        {
            "location": "/connecting-to-clients/#connecting-to-ethereum-clients-connecting-to-clients", 
            "text": "Ethereum clients expose a number of methods over JSON-RPC  for\ninteracting with them from within an application. However, interacting\ndirectly over JSON-RPC passes on a number of burdens to the application\ndevelopers, such as:    JSON-RPC protocol implementation  Binary format encoding/decoding for creating and interacting with\n    smart contracts  256 bit numeric types  Admin command support - e.g. create/manage addresses, sign\n    transactions    A number of libraries have been written to help address these issues,\nallowing application developers to focus on their applications, instead\nof the underlying plumbing to interact with Ethereum clients and the\nwider ecosystem.   Library                       Language     Project Page   [web3.js]{role=\"ref\"}         JavaScript    https://github.com/ethereum/web3.js  [web3j]{role=\"ref\"}           Java          https://github.com/web3j/web3j  [Nethereum]{role=\"ref\"}       C# .NET      https://github.com/Nethereum/Nethereum  [ethereum-ruby]{role=\"ref\"}   Ruby          https://github.com/DigixGlobal/ethereum-ruby  [web3.py]{role=\"ref\"}         Python        https://github.com/ethereum/web3.py   Information on each library is provided in the following sections:  ::: {.toctree}\nweb3.js/index.rst web3j/index.rst nethereum/index.rst\nethereum-ruby/index.rst web3.py/index.rst\n:::  For an overview of creating and interacting with smart contracts and\ntransactions via the web3.js library, please refer to the section\n[Accessing Contracts and Transactions]{role=\"ref\"}.", 
            "title": "Connecting to Ethereum Clients {#Connecting to Clients}"
        }, 
        {
            "location": "/connecting-to-clients/web3.js/", 
            "text": "web3.js\n\n\nweb3.js\n\n\nThis is the Ethereum compatible \nJavaScript\nAPI\n which\nimplements the \nGeneric JSON\nRPC\n spec. It\\'s\navailable on npm as a node module, for bower and component as an\nembeddable js and as a meteor.js package.\n\n\nLinks:\n\n\n\n\nGitHub: \nhttps://github.com/ethereum/web3.js/\n\n\nWiki: \nhttps://github.com/ethereum/wiki/wiki/JavaScript-API\n\n\nGitter: \nhttps://gitter.im/ethereum/web3.js\n\n\nNPM module: \nhttps://www.npmjs.com/package/web3", 
            "title": "web3.js"
        }, 
        {
            "location": "/connecting-to-clients/web3.js/#web3js", 
            "text": "web3.js  This is the Ethereum compatible  JavaScript\nAPI  which\nimplements the  Generic JSON\nRPC  spec. It\\'s\navailable on npm as a node module, for bower and component as an\nembeddable js and as a meteor.js package.  Links:   GitHub:  https://github.com/ethereum/web3.js/  Wiki:  https://github.com/ethereum/wiki/wiki/JavaScript-API  Gitter:  https://gitter.im/ethereum/web3.js  NPM module:  https://www.npmjs.com/package/web3", 
            "title": "web3.js"
        }, 
        {
            "location": "/connecting-to-clients/web3j/", 
            "text": "web3j\n\n\nweb3j\n\n\nweb3j is a lightweight Java library for integrating with clients (nodes)\non the Ethereum network.\n\n\nCore features:\n\n\n:   -   Interaction with Ethereum clients over JSON-RPC via Java types\n    -   Supports all JSON-RPC method types\n    -   Supports all Geth and Parity methods for managing accounts and\n        signing transactions\n    -   Sending of client requests both asynchronously and synchronously\n    -   Auto-generation of Java smart contract function wrappers from\n        Solidity ABI files\n\n\nCurrently, the [go-ethereum]{role=\"ref\"} and [Parity]{role=\"ref\"}\nclients are supported.\n\n\nLinks:\n\n\n\n\nGitHub: \nhttps://github.com/web3j/web3j\n\n\nWebsite: \nhttp://web3j.io\n\n\nWiki: \nhttps://github.com/web3j/web3j/wiki\n\n\nGitter: \nhttps://gitter.im/web3j/web3j", 
            "title": "web3j"
        }, 
        {
            "location": "/connecting-to-clients/web3j/#web3j", 
            "text": "web3j  web3j is a lightweight Java library for integrating with clients (nodes)\non the Ethereum network.  Core features:  :   -   Interaction with Ethereum clients over JSON-RPC via Java types\n    -   Supports all JSON-RPC method types\n    -   Supports all Geth and Parity methods for managing accounts and\n        signing transactions\n    -   Sending of client requests both asynchronously and synchronously\n    -   Auto-generation of Java smart contract function wrappers from\n        Solidity ABI files  Currently, the [go-ethereum]{role=\"ref\"} and [Parity]{role=\"ref\"}\nclients are supported.  Links:   GitHub:  https://github.com/web3j/web3j  Website:  http://web3j.io  Wiki:  https://github.com/web3j/web3j/wiki  Gitter:  https://gitter.im/web3j/web3j", 
            "title": "web3j"
        }, 
        {
            "location": "/connecting-to-clients/nethereum/", 
            "text": "Nethereum {#Nethereum}\n\n\nNethereum\n\n\nNethereum is the .Net integration library for Ethereum, it allows you to\ninteract with Ethereum clients like [go-ethereum]{role=\"ref\"},\n[cpp-ethereum]{role=\"ref\"} or [Parity]{role=\"ref\"} using RPC.\n\n\nThe library has very similar functionality as the Javascript Etherum\nWeb3 RPC Client Library.\n\n\nAll the JSON RPC/IPC methods are implemented as they appear in new\nversions of the clients.\n\n\nThe geth client is the one that is closely supported and tested,\nincluding its management extensions for admin, personal, debugging,\nminer.\n\n\nInteraction with contracts has been simplified for deployment, function\ncalling, transaction and event filtering and decoding of topics.\n\n\nThe library has been tested in all the platforms .Net Core, Mono, Linux,\niOS, Android, Raspberry PI, Xbox and of course Windows.\n\n\nLinks:\n\n\n\n\nGitHub: \nhttps://github.com/Nethereum/Nethereum\n\n\nWebsite: \nhttp://nethereum.com\n\n\nDocumentation: \nhttps://nethereum.readthedocs.io/en/latest/\n\n\nGitter: \nhttps://gitter.im/Nethereum/Nethereum", 
            "title": "Nethereum"
        }, 
        {
            "location": "/connecting-to-clients/nethereum/#nethereum-nethereum", 
            "text": "Nethereum  Nethereum is the .Net integration library for Ethereum, it allows you to\ninteract with Ethereum clients like [go-ethereum]{role=\"ref\"},\n[cpp-ethereum]{role=\"ref\"} or [Parity]{role=\"ref\"} using RPC.  The library has very similar functionality as the Javascript Etherum\nWeb3 RPC Client Library.  All the JSON RPC/IPC methods are implemented as they appear in new\nversions of the clients.  The geth client is the one that is closely supported and tested,\nincluding its management extensions for admin, personal, debugging,\nminer.  Interaction with contracts has been simplified for deployment, function\ncalling, transaction and event filtering and decoding of topics.  The library has been tested in all the platforms .Net Core, Mono, Linux,\niOS, Android, Raspberry PI, Xbox and of course Windows.  Links:   GitHub:  https://github.com/Nethereum/Nethereum  Website:  http://nethereum.com  Documentation:  https://nethereum.readthedocs.io/en/latest/  Gitter:  https://gitter.im/Nethereum/Nethereum", 
            "title": "Nethereum {#Nethereum}"
        }, 
        {
            "location": "/connecting-to-clients/ethereum-ruby/", 
            "text": "ethereum-ruby\n\n\nethereum-ruby\n is a pure-Ruby JSON-RPC wrapper for communicating with\nan Ethereum node. To use this library you will need to have a running\nEthereum node with IPC support enabled (default). Currently, the\n[go-ethereum]{role=\"ref\"} client is supported.\n\n\nLinks:\n\n\n\n\nGitHub: \nhttps://github.com/DigixGlobal/ethereum-ruby", 
            "title": "ethereum-ruby"
        }, 
        {
            "location": "/connecting-to-clients/ethereum-ruby/#ethereum-ruby", 
            "text": "ethereum-ruby  is a pure-Ruby JSON-RPC wrapper for communicating with\nan Ethereum node. To use this library you will need to have a running\nEthereum node with IPC support enabled (default). Currently, the\n[go-ethereum]{role=\"ref\"} client is supported.  Links:   GitHub:  https://github.com/DigixGlobal/ethereum-ruby", 
            "title": "ethereum-ruby"
        }, 
        {
            "location": "/account-management/", 
            "text": "\u5e10\u6237\u7ba1\u7406\n\n\n\u5e10\u53f7\n\n\nAccounts play a central role in Ethereum. There are two types of\naccounts: \nexternally owned accounts\n (EOAs) and \ncontract accounts\n.\nHere we focus on externally owned accounts, which will be referred to\nsimply as \naccounts\n. Contract accounts will be referred to as\n\ncontracts\n and are\n[discussed in detail in Contracts \n]. This\ngeneric notion of account subsuming both externally owned accounts and\ncontracts is justified in that these entities are so called \nstate\nobjects\n. These entities have a state: accounts have balance and\ncontracts have both balance and contract storage. The state of all\naccounts is the state of the Ethereum network which is updated with\nevery block and which the network really needs to reach a consensus\nabout. Accounts are essential for users to interact with the Ethereum\nblockchain via transactions.\n\n\nIf we restrict Ethereum to only externally owned accounts and allow only\ntransactions between them, we arrive at an altcoin system that is\nless powerful than bitcoin itself and can only be used to transfer\nether.\n\n\nAccounts represent identities of external agents (e.g., human personas,\nmining nodes or automated agents). Accounts use public key cryptography\nto sign transaction so that the EVM can securely validate the identity\nof a transaction sender.\n\n\n\u5bc6\u94a5\u6587\u4ef6\n\n\nEvery account is defined by a pair of keys, a private key and public\nkey. Accounts are indexed by their \naddress\n which is derived from the\npublic key by taking the last 20 bytes. Every private key/address pair\nis encoded in a \nkeyfile\n. Keyfiles are JSON text files which you can\nopen and view in any text editor. The critical component of the keyfile,\nyour account's private key, is always encrypted, and it is encrypted\nwith the password you enter when you create the account. Keyfiles are\nfound in the \nkeystore\n subdirectory of your Ethereum node's data\ndirectory. Make sure you backup your keyfiles regularly! See the section\n[backup-and-restore-accounts] for more information.\n\n\nCreating a key is tantamount to creating an account.\n\n\n\n\nYou don't need to tell anybody else you're doing it\n\n\nYou don't need to synchronize with the blockchain\n\n\nYou don't need to run a client\n\n\nYou don't even need to be connected to the internet\n\n\n\n\nOf course your new account will not contain any Ether. But it'll be\nyours and you can be certain that without your key and your password,\nnobody else can ever access it.\n\n\nIt is safe to transfer the entire directory or any individual keyfile\nbetween Ethereum nodes.\n\n\n::: {.warning}\n::: {.admonition-title}\nWarning\n:::\n\n\nNote that in case you are adding keyfiles to your node from a different\nnode, the order of accounts may change. So make sure you do not rely or\nchange the index in your scripts or code snippets.\n:::\n\n\n\u521b\u5efa\u4e00\u4e2a\u5e10\u6237\n\n\n::: {.warning}\n::: {.admonition-title}\nWarning\n:::\n\n\nIn order to send transactions from an account, including sending ether,\nyou must have BOTH the keyfile and the password. Be absolutely sure to\nhave a copy of your keyfile AND remember the password for that keyfile,\nand store them both as securely as possible. There are no escape routes\nhere; lose the keyfile or forget your password and all your ether is\ngone. It is NOT possible to access your account without a password and\nthere is no \nforgot my password\n option here. Do not forget it.\n:::\n\n\n\u8fd0\u884c \ngeth account new\n\n\nOnce you have the geth client installed, creating an account is merely a\ncase of executing the \ngeth account new\n command in a terminal.\n\n\nNote that you do not have to run the geth client or sync up with the\nblockchain to use the \ngeth account\n command.\n\n\n$ geth account new\n\n  Your new account is locked with a password. Please give a password. Do not forget this password.\n  Passphrase:\n  Repeat Passphrase:\n  Address: \n{\n168bc315a2ee09042d83d7c5811b533620531f67\n}\n\n\n\n\n\nFor non-interactive use you supply a plaintext password file as argument\nto the \n--password\n flag. The data in the file consists of the raw bytes\nof the password optionally followed by a single newline.\n\n\n$ geth --password /path/to/password account new\n\n\n\n\n::: {.warning}\n::: {.admonition-title}\nWarning\n:::\n\n\nUsing the \n--password\n flag is meant to be used only for testing or\nautomation in trusted environments. It is a bad idea to save your\npassword to file or expose it in any other way. If you do use the\n\n--password\n flag with a password file, make sure the file is not\nreadable or even listable for anyone but you. You can achieve this in\nMac/Linux systems with:\n:::\n\n\ntouch /path/to/password\nchmod \n600\n /path/to/password\ncat \n /path/to/password\n\nI \ntype\n my pass\n\n\n\n\nTo list all the accounts with keyfiles currently in your \nkeystore\n\nfolder use the \nlist\n subcommand of the \ngeth account\n command:\n\n\n$ geth account list\n\naccount \n#0: {a94f5374fce5edbc8e2a8697c15331677e6ebf0b}\n\naccount \n#1: {c385233b188811c9f355d4caec14df86d6248235}\n\naccount \n#2: {7f444580bfef4b9bc7e14eb7fb2a029336b07c9d}\n\n\n\n\n\n\u5bc6\u94a5\u6587\u4ef6\u7684\u6587\u4ef6\u540d\u683c\u5f0f\u4e3a\u201cUTC  -  \n  -  \n`\u3002 \u4e0a\u5e02\u65f6\u7684\u8d26\u6237\u987a\u5e8f\u662f\u5b57\u5178\u5f0f\u7684\uff0c\u4f46\u4f5c\u4e3a\u65f6\u95f4\u6233\u683c\u5f0f\u7684\u7ed3\u679c\uff0c\u5b83\u5b9e\u9645\u4e0a\u662f\u521b\u5efa\u7684\u987a\u5e8f\u3002\n\n\n\u4f7f\u7528geth\u63a7\u5236\u53f0\n\n\n\u4e3a\u4e86\u4f7f\u7528geth\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5e10\u6237\uff0c\u6211\u4eec\u5fc5\u987b\u9996\u5148\u5728\u63a7\u5236\u53f0\u6a21\u5f0f\u4e0b\u542f\u52a8geth\uff08\u6216\u8005\u4f60\u53ef\u4ee5\u7528\ngeth attach\n\u628a\u4e00\u4e2a\u63a7\u5236\u53f0\u9644\u52a0\u5230\u4e00\u4e2a\u5df2\u7ecf\u8fd0\u884c\u7684\u5b9e\u4f8b\u4e0a\uff09\uff1a\n\n\n geth console \n2\n file_to_log_output\ninstance: Geth/v1.4.0-unstable/linux/go1.5.1\ncoinbase: coinbase: \n[\nobject Object\n]\n\nat block: \n865174\n \n(\nMon, \n18\n Jan \n2016\n \n02\n:58:53 GMT\n)\n\ndatadir: /home/USERNAME/.ethereum\n\n\n\n\n\u63a7\u5236\u53f0\u5141\u8bb8\u60a8\u901a\u8fc7\u53d1\u51fa\u547d\u4ee4\u4e0e\u672c\u5730\u8282\u70b9\u8fdb\u884c\u4ea4\u4e92\u3002,\u4f8b\u5982\uff0c\u5c1d\u8bd5\u547d\u4ee4\u5217\u51fa\u60a8\u7684\u5e10\u6237\uff1a\n\n\n \neth\n.\naccounts\n\n\n\n{\n\n\ncode\n:\n \n-\n32000\n,\n\n\nmessage\n:\n \nno keys in store\n\n\n}\n\n\n\n\n\nThis shows that you have no accounts. You can also create an account\nfrom the console:\n\n\n \npersonal\n.\nnewAccount\n()\n\n\nPassphrase\n:\n\n\nRepeat\n \npassphrase\n:\n\n\n0xb2f69ddf70297958e582a0cc98bce43294f1007d\n\n\n\n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\nRemember to use a strong and randomly generated password.\n:::\n\n\nWe just created our first account. If we try to list our accounts again\nwe can see our new account:\n\n\n \neth\n.\naccounts\n\n\n[\n0xb2f69ddf70297958e582a0cc98bce43294f1007d\n]\n\n\n\n\n\n\u4f7f\u7528\u8584\u96fe\u4ee5\u592a\u574a\u94b1\u5305\n\n\nFor the command line averse, there is now a GUI-based option for\ncreating accounts: The \"official\" Mist Ethereum wallet. The Mist\nEthereum wallet, and its parent Mist project, are being developed under\nthe auspices of the Ethereum Foundation, hence the \"official\" status.\nVersions of the wallet app are available for Linux, Mac OS X, and\nWindows.\n\n\n::: {.warning}\n::: {.admonition-title}\nWarning\n:::\n\n\nThe Mist wallet is beta software. Please beware and use it at your own\nrisk.\n:::\n\n\nCreating an account using the GUI Mist Ethereum wallet couldn't be\neasier. In fact, your first account is created during the installation\nof the app.\n\n\n\n\nDownload the latest version of the wallet\n    app\n for your operating\n    system. Opening the Wallet App will kick off syncing a full copy of\n    the Ethereum blockchain on your computer, since you will in effect\n    be running a full geth node.\n\n\nUnzip the downloaded folder and run the Ethereum-Wallet executable file.\n\n\n\n\n{.align-center width=\"436px\"\nheight=\"352px\"}\n\n\n\n\nWait for the blockchain to fully sync, then follow the instructions\n    on the screen and your first account will be created.\n\n\nWhen you launch the Mist Ethereum wallet for the first time, you\n    will see the account you created during the installation process. By\n    default it will be named MAIN ACCOUNT (ETHERBASE).\n\n\n\n\n{.align-center width=\"512px\"\nheight=\"469px\"}\n\n\n\n\nCreating additional accounts is easy; just click on ADD ACCOUNT in the app's main screen and enter the required password.\n\n\n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\nThe Mist wallet is still in active development, so details of the steps outlined above may change with upgrades.\n\n\n\u5728\u96fe\u4e2d\u521b\u5efa\u591a\u91cd\u7b7e\u540d\u94b1\u5305\n\n\nThe Mist Ethereum wallet has an option to secure your wallet balance\nwith a multisig wallet. The advantage of using a multisig wallet is that\nit requires authorization from more than one account to withdraw larger\namounts from your balance. Before you can create a multisig wallet,\nyou'll need to create more than one account.\n\n\nIt's very easy to create account files in Mist. In the 'Accounts'\nsection click 'Add Account'. Pick a strong yet easy-to-remember\npassword (remember there is no password recovery option), confirm it,\nand your account is created. Create at least 2 accounts. Secondary\naccounts can be created on separate computers running Mist if you prefer\n(and theoretically make your multisig more secure doing it this way).\nYou only need the public keys (your deposit addresses) of your secondary\naccounts when creating the multisig wallet (copy/paste them, do not ever\ntype them by hand). Your primary account will be needed to create the\nmultisig wallet contract, so it must be on the computer you are creating\nthe multisig wallet on.\n\n\nNow that you have your accounts setup, be safe and back them up (if your\ncomputer crashes, you will lose your balance if you do not have a\nbackup). Click 'Backup' in the top menu. Choose the 'keystore'\nfolder, opposite-click on it / choose 'copy' (do NOT choose 'cut',\nthat would be very bad). Navigate to your desktop, opposite-click in a\nblank area and choose 'paste'. You may want to rename this new copy of\nthe 'keystore' folder to something like\n'Ethereum-keystore-backup-year-month-day' so you have quick\nrecognition of it later. At this point you can then add the folder\ncontents to a zip / rar file (and even password-protect the archive with\nanother strong yet easy-to-remember password if backing up online), copy\nit to a USB Drive, burn it to a CD / DVD, or upload it to online storage\n(Dropbox / Google Drive / etc).\n\n\nYou now should add approximately no less than 0.02 ETH to your primary\naccount (the account you will initiate creation of a multisig wallet\nwith). This is required for the transaction fee when you create the\nmultisig wallet contract. An additional 1 ETH (or more) is also needed,\nbecause Mist currently requires this to assure wallet contract\ntransactions have enough 'gas' to execute properly...so no less than\nabout 1.02 ETH total for starters.\n\n\nYou will be entering the full addresses of all the accounts you are\nattaching to this multisig wallet, when you create it. I recommend\ncopying / pasting each address into a plain text editor (notepad / kedit\n/ etc), after going to each account's details page in Mist, and\nchoosing 'copy address' from the right-side column of buttons. Never\ntype an address by hand, or you run a very high risk of typos and could\nlose your balance sending transactions to the wrong address.\n\n\nWe are now ready to create the multisig wallet. Under 'Wallet\nContracts', select 'Add Wallet Contract'. Give it a name, select the\nprimary account owner, and choose 'Multisignature Wallet Contract'.\nYou will see something like this appear:\n\n\nThis is a joint account controlled by X owners. You can send up to X\nether per day. Any transaction over that daily limit requires the\nconfirmation of X owners.\n\n\nSet whatever amount of owners (accounts) you are attaching to this\nmultisig wallet, whatever you want for a daily withdrawal limit (that\nonly requires one account to withdraw that amount), and how many owners\n(accounts) are required to approve any withdrawal amount over the daily\nlimit.\n\n\nNow add the addresses of the accounts that you copied / pasted into your\ntext editor earlier, confirm all your settings are correct, and click\n'Create' at the bottom. You will then need to enter your password to\nsend the transaction. In the 'Wallet Contracts' section it should show\nyour new wallet, and say 'creating'.\n\n\nWhen wallet creation is complete, you should see your contract address\non the screen. Select the entire address, copy / paste it into a new\ntext file in your text editor, and save the text file to your desktop as\n'Ethereum-Wallet-Address.txt', or whatever you want to name it.\n\n\nNow all you need to do is backup the 'Ethereum-Wallet-Address.txt'\nfile the same way you backed up your account files, and then you are\nready to load your new multisig wallet with ETH using this address.\n\n\nIf you are restoring from backup, simply copy the files inside the\n'Ethereum-keystore-backup' folder over into the 'keystore' folder\nmentioned in the first section of this walkthrough. FYI, you may need to\ncreate the 'keystore' folder if it's a brand new install of Mist on a\nmachine it was never installed on before (the first time you create an\naccount is when this folder is created). As for restoring a multisig\nwallet, instead of choosing 'Multisignature Wallet Contract' like we\ndid before when creating it, we merely choose 'Import Wallet' instead.\n\n\nTroubleshooting:\n\n\n\n\nMist won't sync. One solution that works well is syncing your PC\n    hardware clock with an NTP server so the time is exactly\n    correct...then reboot.\n\n\nMist starts after syncing, but is a blank white screen. Chances are\n    you are running the xorg video drivers on a Linux-based OS\n    (Ubuntu, Linux Mint, etc). Try installing the manufacturer's video\n    driver instead.\n\n\nWrong password notice. This seems to be a false notice on\n    occasion on current Mist versions. Restart Mist and the problem\n    should go away (if you indeed entered the correct password).\n\n\n\n\n\u4f7f\u7528Eth\n\n\nEvery option related to key management available using geth can be used\nthe same way in eth.\n\n\nBelow are account related options:\n\n\n \neth\n \naccount\n \nlist\n  \n// List all keys available in wallet.\n\n\n \neth\n \naccount\n \nnew\n   \n// Create a new key and add it to the wallet.\n\n\n \neth\n \naccount\n \nupdate\n \n[\nuuid\n|\naddress\n \n,\n \n...\n \n]\n  \n// Decrypt and re-encrypt given keys.\n\n\n \neth\n \naccount\n \nimport\n \n[\nuuid\n|\nfile\n|\nsecret\n-\nhex\n]\n \n// Import keys from given source and place in wallet.\n\n\n\n\n\nBelow are wallet related option:\n\n\n \neth\n \nwallet\n \nimport\n \nfile\n \n//Import a presale wallet.\n\n\n\n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\nthe 'account import' option can only be used to import generic key\nfile. the 'wallet import' option can only be used to import a presale\nwallet.\n:::\n\n\nIt is also possible to access keys management from the integrated\nconsole (using the built-in console or geth attach):\n\n\n \nweb3\n.\npersonal\n\n\n{\n\n  \nlistAccounts\n:\n \n[],\n\n  \ngetListAccounts\n:\n \nfunction\n(\ncallback\n),\n\n  \nlockAccount\n:\n \nfunction\n(),\n\n  \nnewAccount\n:\n \nfunction\n(),\n\n  \nunlockAccount\n:\n \nfunction\n()\n\n\n}\n\n\n\n\n\n\u4f7f\u7528EthKey\uff08\u4e0d\u5efa\u8bae\u4f7f\u7528\uff09\n\n\nEthkey is a CLI tool of the C++ implementation that allows you to\ninteract with the Ethereum wallet. With it you can list, inspect,\ncreate, delete and modify keys and inspect, create and sign\ntransactions.\n\n\nWe will assume you have not yet run a client such as eth or anything in\nthe Aleth series of clients. If you have, you can skip this section. To\ncreate a wallet, run \nethkey\n with the \ncreatewallet\n command:\n\n\n ethkey createwallet\n\n\n\n\nPlease enter a MASTER passphrase to protect your key store (make it\nstrong!): You'll be asked for a master passphrase. This protects\nyour privacy and acts as a default password for any keys. You'll need\nto confirm it by entering the same text again.\n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\nUse a strong randomly generated password.\n:::\n\n\nWe can list the keys within the wallet simply by using the list command:\n\n\n ethkey list\n\nNo keys found.\n\n\n\n\nWe haven't yet created any keys, and it's telling us so! Let's create\none.\n\n\nTo create a key, we use the \nnew\n command. To use it we must pass a name\n- this is the name we'll give to this account in the wallet. Let's\ncall it test:\n\n\n ethkey new \ntest\n\n\n\n\n\nEnter a passphrase with which to secure this account (or nothing to use\nthe master passphrase). It will prompt you to enter a passphrase to\nprotect this key. If you just press enter, it'll use the default\nmaster passphrase. Typically this means you won't need to enter the\npassphrase for the key when you want to use the account (since it\nremembers the master passphrase). In general, you should try to use a\ndifferent passphrase for each key since it prevents one compromised\npassphrase from giving access to other accounts. However, out of\nconvenience you might decide that for low-security accounts to use the\nsame passphrase.\n\n\nHere, let's give it the incredibly imaginative passphrase of 123.\n(Never ever use simple passwords like this for anything else than\nephemeral test accounts). Once you enter a passphrase, it'll ask you to\nconfirm it by entering again. Enter 123 a second time. Because you gave\nit its own passphrase, it'll also ask you to provide a hint for this\npassword which will be displayed to you whenever it asks you to enter\nit. The hint is stored in the wallet and is itself protected by the\nmaster passphrase. Enter the truly awful hint of 321 backwards.\n\n\n ethkey new \ntest\n\n\nEnter a passphrase with which to secure this account \n(\nor nothing to use the master passphrase\n)\n:\nPlease confirm the passphrase by entering it again:\nEnter a hint to \nhelp\n you remember this passphrase: \n321\n backwards\nCreated key 055dde03-47ff-dded-8950-0fe39b1fa101\n  Name: \ntest\n\n  Password hint: \n321\n backwards\n  ICAP: XE472EVKU3CGMJF2YQ0J9RO1Y90BC0LDFZ\n  Raw hex: 0092e965928626f8880629cec353d3fd7ca5974f\n\n\n\n\nAll normal (aka direct) ICAP addresses begin with XE so you should be\nable to recognize them easily. Notice also that the key has another\nidentifier after Created key. This is known as the UUID. This is a\nunique identifier for the key that has absolutely nothing to do with the\naccount itself. Knowing it does nothing to help an attacker discover who\nyou are on the network. It also happens to be the filename for the key,\nwhich you can find in either \\~/.web3/keys (Mac or Linux) or\n\\$HOME/AppData/Web3/keys (Windows). Now let's make sure it worked\nproperly by listing the keys in the wallet:\n\n\n ethkey list\n055dde03-47ff-dded-8950-0fe39b1fa101 0092e965\u2026 XE472EVKU3CGMJF2YQ0J9RO1Y90BC0LDFZ  \ntest\n\n\n\n\n\nIt reports one key on each line (for a total of one key here). In this\ncase our key is stored in a file 055dde... and has an ICAP address\nbeginning XE472EVK.... Not especially easy things to remember so rather\nhelpful that it has its proper name, test, too.\n\n\n\u5bfc\u5165\u60a8\u7684\u9884\u552e\u94b1\u5305\n\n\n\u4f7f\u7528\u8584\u96fe\u4ee5\u592a\u574a\u94b1\u5305\n\n\nImporting your presale wallet using the GUI Mist Ethereum wallet is very\neasy. In fact, you will be asked if you want to import your presale\nwallet during the installation of the app.\n\n\n::: {.warning}\n::: {.admonition-title}\nWarning\n:::\n\n\nMist wallet is beta software. Beware and use it at your own risk.\n:::\n\n\nInstructions for installing the Mist Ethereum wallet are given in the\nsection\n[Creating an account: Using Mist Ethereum wallet \n].\n\n\nSimply drag-and-drop your \n.json\n presale wallet file into the\ndesignated area and enter your password to import your presale account.\n\n\n{.align-center\nwidth=\"436px\" height=\"352px\"}\n\n\nIf you choose not to import your presale wallet during installation of\nthe app, you can import it at any time by selecting the \nAccounts\n menu\nin the app's menu bar and then selecting \nImport Pre-sale Accounts\n.\n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\nThe Mist wallet is still in active development, so details of the steps\noutlined above may change with upgrades.\n:::\n\n\n\u4f7f\u7528geth\n\n\nIf you have a standalone installation of geth, importing your presale\nwallet is accomplished by executing the following command in a terminal:\n\n\ngeth wallet import /path/to/my/presale-wallet.json\n\n\n\n\nYou will be prompted to enter your password.\n\n\n\u66f4\u65b0\u4e00\u4e2a\u5e10\u6237\n\n\nYou are able to upgrade your keyfile to the latest keyfile format and/or\nupgrade your keyfile password.\n\n\n\u4f7f\u7528geth\n\n\nYou can update an existing account on the command line with the \nupdate\n\nsubcommand with the account address or index as parameter. Remember that\nthe account index reflects the order of creation (lexicographic order of\nkeyfile names containing the creation time).\n\n\ngeth account update b0047c606f3af7392e073ed13253f8f4710b08b6\n\n\n\n\nor\n\n\ngeth account update \n2\n\n\n\n\n\nFor example:\n\n\n$ geth account update a94f5374fce5edbc8e2a8697c15331677e6ebf0b\n\nUnlocking account a94f5374fce5edbc8e2a8697c15331677e6ebf0b \n|\n Attempt \n1\n/3\nPassphrase:\n0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b\naccount \na94f5374fce5edbc8e2a8697c15331677e6ebf0b\n unlocked.\nPlease give a new password. Do not forget this password.\nPassphrase:\nRepeat Passphrase:\n0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b\n\n\n\n\nThe account is saved in the newest version in encrypted format, you are\nprompted for a passphrase to unlock the account and another to save the\nupdated file. This same command can be used to migrate an account of a\ndeprecated format to the newest format or change the password for an\naccount.\n\n\nFor non-interactive use the passphrase can be specified with the\n\n--password\n flag:\n\n\ngeth --password \npasswordfile\n account update a94f5374fce5edbc8e2a8697c15331677e6ebf0bs\n\n\n\n\nSince only one password can be given, only format update can be\nperformed, changing your password is only possible interactively.\n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\naccount update has the side effect that the order of your accounts may\nchange. After a successful update, all previous formats/versions of that\nsame key will be removed!\n:::\n\n\n\u5907\u4efd\u548c\u6062\u590d\u5e10\u6237\n\n\n\u624b\u52a8\u5907\u4efd/\u6062\u590d\n\n\nYou must have an account's keyfile to be able to send any transaction\nfrom that account. Keyfiles are found in the keystore subdirectory of\nyour Ethereum node's data directory. The default data directory\nlocations are platform specific:\n\n\n\n\nWindows: \n%appdata%\\Ethereum\\keystore\n\n\nLinux: \n~/.ethereum/keystore\n\n\nMac: \n~/Library/Ethereum/keystore\n\n\n\n\nTo backup your keyfiles (accounts), copy either the individual keyfiles\nwithin the \nkeystore\n subdirectory or copy the entire \nkeystore\n folder.\n\n\nTo restore your keyfiles (accounts), copy the keyfiles back into the\n\nkeystore\n subdirectory, where they were originally.\n\n\n\u5bfc\u5165\u672a\u52a0\u5bc6\u7684\u79c1\u94a5\n\n\nImporting an unencrypted private key is supported by \ngeth\n\n\ngeth account import /path/to/\nkeyfile\n\n\n\n\n\nThis command imports an unencrypted private key from the plain text file\n\nkeyfile\n and creates a new account and prints the address. The\nkeyfile is assumed to contain an unencrypted private key as canonical EC\nraw bytes encoded into hex. The account is saved in encrypted format,\nyou are prompted for a passphrase. You must remember this passphrase to\nunlock your account in the future.\n\n\nAn example where the data directory is specified. If the \n--datadir\n\nflag is not used, the new account will be created in the default data\ndirectory, i.e., the keyfile will be placed in the \nkeystore\n\nsubdirectory of the data directory.\n\n\n$ geth --datadir /someOtherEthDataDir  account import ./key.prv\nThe new account will be encrypted with a passphrase.\nPlease enter a passphrase now.\nPassphrase:\nRepeat Passphrase:\nAddress: \n{\n7f444580bfef4b9bc7e14eb7fb2a029336b07c9d\n}\n\n\n\n\n\nFor non-interactive use the passphrase can be specified with the\n\n--password\n flag:\n\n\ngeth --password \npasswordfile\n account import \nkeyfile\n\n\n\n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\nSince you can directly copy your encrypted accounts to another Ethereum\ninstance, this import/export mechanism is not needed when you transfer\nan account between nodes.\n:::\n\n\n::: {.warning}\n::: {.admonition-title}\nWarning\n:::\n\n\nWhen you copy keys into an existing node's \nkeystore\n, the order of\naccounts you are used to may change. Therefore you make sure you either\ndo not rely on the account order or double-check and update the indexes\nused in your scripts.\n:::", 
            "title": "\u8d26\u53f7"
        }, 
        {
            "location": "/account-management/#_1", 
            "text": "", 
            "title": "\u5e10\u6237\u7ba1\u7406"
        }, 
        {
            "location": "/account-management/#_2", 
            "text": "Accounts play a central role in Ethereum. There are two types of\naccounts:  externally owned accounts  (EOAs) and  contract accounts .\nHere we focus on externally owned accounts, which will be referred to\nsimply as  accounts . Contract accounts will be referred to as contracts  and are\n[discussed in detail in Contracts  ]. This\ngeneric notion of account subsuming both externally owned accounts and\ncontracts is justified in that these entities are so called  state\nobjects . These entities have a state: accounts have balance and\ncontracts have both balance and contract storage. The state of all\naccounts is the state of the Ethereum network which is updated with\nevery block and which the network really needs to reach a consensus\nabout. Accounts are essential for users to interact with the Ethereum\nblockchain via transactions.  If we restrict Ethereum to only externally owned accounts and allow only\ntransactions between them, we arrive at an altcoin system that is\nless powerful than bitcoin itself and can only be used to transfer\nether.  Accounts represent identities of external agents (e.g., human personas,\nmining nodes or automated agents). Accounts use public key cryptography\nto sign transaction so that the EVM can securely validate the identity\nof a transaction sender.", 
            "title": "\u5e10\u53f7"
        }, 
        {
            "location": "/account-management/#_3", 
            "text": "Every account is defined by a pair of keys, a private key and public\nkey. Accounts are indexed by their  address  which is derived from the\npublic key by taking the last 20 bytes. Every private key/address pair\nis encoded in a  keyfile . Keyfiles are JSON text files which you can\nopen and view in any text editor. The critical component of the keyfile,\nyour account's private key, is always encrypted, and it is encrypted\nwith the password you enter when you create the account. Keyfiles are\nfound in the  keystore  subdirectory of your Ethereum node's data\ndirectory. Make sure you backup your keyfiles regularly! See the section\n[backup-and-restore-accounts] for more information.  Creating a key is tantamount to creating an account.   You don't need to tell anybody else you're doing it  You don't need to synchronize with the blockchain  You don't need to run a client  You don't even need to be connected to the internet   Of course your new account will not contain any Ether. But it'll be\nyours and you can be certain that without your key and your password,\nnobody else can ever access it.  It is safe to transfer the entire directory or any individual keyfile\nbetween Ethereum nodes.  ::: {.warning}\n::: {.admonition-title}\nWarning\n:::  Note that in case you are adding keyfiles to your node from a different\nnode, the order of accounts may change. So make sure you do not rely or\nchange the index in your scripts or code snippets.\n:::", 
            "title": "\u5bc6\u94a5\u6587\u4ef6"
        }, 
        {
            "location": "/account-management/#_4", 
            "text": "::: {.warning}\n::: {.admonition-title}\nWarning\n:::  In order to send transactions from an account, including sending ether,\nyou must have BOTH the keyfile and the password. Be absolutely sure to\nhave a copy of your keyfile AND remember the password for that keyfile,\nand store them both as securely as possible. There are no escape routes\nhere; lose the keyfile or forget your password and all your ether is\ngone. It is NOT possible to access your account without a password and\nthere is no  forgot my password  option here. Do not forget it.\n:::", 
            "title": "\u521b\u5efa\u4e00\u4e2a\u5e10\u6237"
        }, 
        {
            "location": "/account-management/#geth-account-new", 
            "text": "Once you have the geth client installed, creating an account is merely a\ncase of executing the  geth account new  command in a terminal.  Note that you do not have to run the geth client or sync up with the\nblockchain to use the  geth account  command.  $ geth account new\n\n  Your new account is locked with a password. Please give a password. Do not forget this password.\n  Passphrase:\n  Repeat Passphrase:\n  Address:  { 168bc315a2ee09042d83d7c5811b533620531f67 }   For non-interactive use you supply a plaintext password file as argument\nto the  --password  flag. The data in the file consists of the raw bytes\nof the password optionally followed by a single newline.  $ geth --password /path/to/password account new  ::: {.warning}\n::: {.admonition-title}\nWarning\n:::  Using the  --password  flag is meant to be used only for testing or\nautomation in trusted environments. It is a bad idea to save your\npassword to file or expose it in any other way. If you do use the --password  flag with a password file, make sure the file is not\nreadable or even listable for anyone but you. You can achieve this in\nMac/Linux systems with:\n:::  touch /path/to/password\nchmod  600  /path/to/password\ncat   /path/to/password I  type  my pass  To list all the accounts with keyfiles currently in your  keystore \nfolder use the  list  subcommand of the  geth account  command:  $ geth account list\n\naccount  #0: {a94f5374fce5edbc8e2a8697c15331677e6ebf0b} \naccount  #1: {c385233b188811c9f355d4caec14df86d6248235} \naccount  #2: {7f444580bfef4b9bc7e14eb7fb2a029336b07c9d}   \u5bc6\u94a5\u6587\u4ef6\u7684\u6587\u4ef6\u540d\u683c\u5f0f\u4e3a\u201cUTC  -     -   `\u3002 \u4e0a\u5e02\u65f6\u7684\u8d26\u6237\u987a\u5e8f\u662f\u5b57\u5178\u5f0f\u7684\uff0c\u4f46\u4f5c\u4e3a\u65f6\u95f4\u6233\u683c\u5f0f\u7684\u7ed3\u679c\uff0c\u5b83\u5b9e\u9645\u4e0a\u662f\u521b\u5efa\u7684\u987a\u5e8f\u3002", 
            "title": "\u8fd0\u884c geth account new"
        }, 
        {
            "location": "/account-management/#geth", 
            "text": "\u4e3a\u4e86\u4f7f\u7528geth\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5e10\u6237\uff0c\u6211\u4eec\u5fc5\u987b\u9996\u5148\u5728\u63a7\u5236\u53f0\u6a21\u5f0f\u4e0b\u542f\u52a8geth\uff08\u6216\u8005\u4f60\u53ef\u4ee5\u7528 geth attach \u628a\u4e00\u4e2a\u63a7\u5236\u53f0\u9644\u52a0\u5230\u4e00\u4e2a\u5df2\u7ecf\u8fd0\u884c\u7684\u5b9e\u4f8b\u4e0a\uff09\uff1a   geth console  2  file_to_log_output\ninstance: Geth/v1.4.0-unstable/linux/go1.5.1\ncoinbase: coinbase:  [ object Object ] \nat block:  865174   ( Mon,  18  Jan  2016   02 :58:53 GMT ) \ndatadir: /home/USERNAME/.ethereum  \u63a7\u5236\u53f0\u5141\u8bb8\u60a8\u901a\u8fc7\u53d1\u51fa\u547d\u4ee4\u4e0e\u672c\u5730\u8282\u70b9\u8fdb\u884c\u4ea4\u4e92\u3002,\u4f8b\u5982\uff0c\u5c1d\u8bd5\u547d\u4ee4\u5217\u51fa\u60a8\u7684\u5e10\u6237\uff1a    eth . accounts  {  code :   - 32000 ,  message :   no keys in store  }   This shows that you have no accounts. You can also create an account\nfrom the console:    personal . newAccount ()  Passphrase :  Repeat   passphrase :  0xb2f69ddf70297958e582a0cc98bce43294f1007d   ::: {.note}\n::: {.admonition-title}\nNote\n:::  Remember to use a strong and randomly generated password.\n:::  We just created our first account. If we try to list our accounts again\nwe can see our new account:    eth . accounts  [ 0xb2f69ddf70297958e582a0cc98bce43294f1007d ]", 
            "title": "\u4f7f\u7528geth\u63a7\u5236\u53f0"
        }, 
        {
            "location": "/account-management/#_5", 
            "text": "For the command line averse, there is now a GUI-based option for\ncreating accounts: The \"official\" Mist Ethereum wallet. The Mist\nEthereum wallet, and its parent Mist project, are being developed under\nthe auspices of the Ethereum Foundation, hence the \"official\" status.\nVersions of the wallet app are available for Linux, Mac OS X, and\nWindows.  ::: {.warning}\n::: {.admonition-title}\nWarning\n:::  The Mist wallet is beta software. Please beware and use it at your own\nrisk.\n:::  Creating an account using the GUI Mist Ethereum wallet couldn't be\neasier. In fact, your first account is created during the installation\nof the app.   Download the latest version of the wallet\n    app  for your operating\n    system. Opening the Wallet App will kick off syncing a full copy of\n    the Ethereum blockchain on your computer, since you will in effect\n    be running a full geth node.  Unzip the downloaded folder and run the Ethereum-Wallet executable file.   {.align-center width=\"436px\"\nheight=\"352px\"}   Wait for the blockchain to fully sync, then follow the instructions\n    on the screen and your first account will be created.  When you launch the Mist Ethereum wallet for the first time, you\n    will see the account you created during the installation process. By\n    default it will be named MAIN ACCOUNT (ETHERBASE).   {.align-center width=\"512px\"\nheight=\"469px\"}   Creating additional accounts is easy; just click on ADD ACCOUNT in the app's main screen and enter the required password.   ::: {.note}\n::: {.admonition-title}\nNote\n:::  The Mist wallet is still in active development, so details of the steps outlined above may change with upgrades.", 
            "title": "\u4f7f\u7528\u8584\u96fe\u4ee5\u592a\u574a\u94b1\u5305"
        }, 
        {
            "location": "/account-management/#_6", 
            "text": "The Mist Ethereum wallet has an option to secure your wallet balance\nwith a multisig wallet. The advantage of using a multisig wallet is that\nit requires authorization from more than one account to withdraw larger\namounts from your balance. Before you can create a multisig wallet,\nyou'll need to create more than one account.  It's very easy to create account files in Mist. In the 'Accounts'\nsection click 'Add Account'. Pick a strong yet easy-to-remember\npassword (remember there is no password recovery option), confirm it,\nand your account is created. Create at least 2 accounts. Secondary\naccounts can be created on separate computers running Mist if you prefer\n(and theoretically make your multisig more secure doing it this way).\nYou only need the public keys (your deposit addresses) of your secondary\naccounts when creating the multisig wallet (copy/paste them, do not ever\ntype them by hand). Your primary account will be needed to create the\nmultisig wallet contract, so it must be on the computer you are creating\nthe multisig wallet on.  Now that you have your accounts setup, be safe and back them up (if your\ncomputer crashes, you will lose your balance if you do not have a\nbackup). Click 'Backup' in the top menu. Choose the 'keystore'\nfolder, opposite-click on it / choose 'copy' (do NOT choose 'cut',\nthat would be very bad). Navigate to your desktop, opposite-click in a\nblank area and choose 'paste'. You may want to rename this new copy of\nthe 'keystore' folder to something like\n'Ethereum-keystore-backup-year-month-day' so you have quick\nrecognition of it later. At this point you can then add the folder\ncontents to a zip / rar file (and even password-protect the archive with\nanother strong yet easy-to-remember password if backing up online), copy\nit to a USB Drive, burn it to a CD / DVD, or upload it to online storage\n(Dropbox / Google Drive / etc).  You now should add approximately no less than 0.02 ETH to your primary\naccount (the account you will initiate creation of a multisig wallet\nwith). This is required for the transaction fee when you create the\nmultisig wallet contract. An additional 1 ETH (or more) is also needed,\nbecause Mist currently requires this to assure wallet contract\ntransactions have enough 'gas' to execute properly...so no less than\nabout 1.02 ETH total for starters.  You will be entering the full addresses of all the accounts you are\nattaching to this multisig wallet, when you create it. I recommend\ncopying / pasting each address into a plain text editor (notepad / kedit\n/ etc), after going to each account's details page in Mist, and\nchoosing 'copy address' from the right-side column of buttons. Never\ntype an address by hand, or you run a very high risk of typos and could\nlose your balance sending transactions to the wrong address.  We are now ready to create the multisig wallet. Under 'Wallet\nContracts', select 'Add Wallet Contract'. Give it a name, select the\nprimary account owner, and choose 'Multisignature Wallet Contract'.\nYou will see something like this appear:  This is a joint account controlled by X owners. You can send up to X\nether per day. Any transaction over that daily limit requires the\nconfirmation of X owners.  Set whatever amount of owners (accounts) you are attaching to this\nmultisig wallet, whatever you want for a daily withdrawal limit (that\nonly requires one account to withdraw that amount), and how many owners\n(accounts) are required to approve any withdrawal amount over the daily\nlimit.  Now add the addresses of the accounts that you copied / pasted into your\ntext editor earlier, confirm all your settings are correct, and click\n'Create' at the bottom. You will then need to enter your password to\nsend the transaction. In the 'Wallet Contracts' section it should show\nyour new wallet, and say 'creating'.  When wallet creation is complete, you should see your contract address\non the screen. Select the entire address, copy / paste it into a new\ntext file in your text editor, and save the text file to your desktop as\n'Ethereum-Wallet-Address.txt', or whatever you want to name it.  Now all you need to do is backup the 'Ethereum-Wallet-Address.txt'\nfile the same way you backed up your account files, and then you are\nready to load your new multisig wallet with ETH using this address.  If you are restoring from backup, simply copy the files inside the\n'Ethereum-keystore-backup' folder over into the 'keystore' folder\nmentioned in the first section of this walkthrough. FYI, you may need to\ncreate the 'keystore' folder if it's a brand new install of Mist on a\nmachine it was never installed on before (the first time you create an\naccount is when this folder is created). As for restoring a multisig\nwallet, instead of choosing 'Multisignature Wallet Contract' like we\ndid before when creating it, we merely choose 'Import Wallet' instead.  Troubleshooting:   Mist won't sync. One solution that works well is syncing your PC\n    hardware clock with an NTP server so the time is exactly\n    correct...then reboot.  Mist starts after syncing, but is a blank white screen. Chances are\n    you are running the xorg video drivers on a Linux-based OS\n    (Ubuntu, Linux Mint, etc). Try installing the manufacturer's video\n    driver instead.  Wrong password notice. This seems to be a false notice on\n    occasion on current Mist versions. Restart Mist and the problem\n    should go away (if you indeed entered the correct password).", 
            "title": "\u5728\u96fe\u4e2d\u521b\u5efa\u591a\u91cd\u7b7e\u540d\u94b1\u5305"
        }, 
        {
            "location": "/account-management/#eth", 
            "text": "Every option related to key management available using geth can be used\nthe same way in eth.  Below are account related options:    eth   account   list    // List all keys available in wallet.    eth   account   new     // Create a new key and add it to the wallet.    eth   account   update   [ uuid | address   ,   ...   ]    // Decrypt and re-encrypt given keys.    eth   account   import   [ uuid | file | secret - hex ]   // Import keys from given source and place in wallet.   Below are wallet related option:    eth   wallet   import   file   //Import a presale wallet.   ::: {.note}\n::: {.admonition-title}\nNote\n:::  the 'account import' option can only be used to import generic key\nfile. the 'wallet import' option can only be used to import a presale\nwallet.\n:::  It is also possible to access keys management from the integrated\nconsole (using the built-in console or geth attach):    web3 . personal  { \n   listAccounts :   [], \n   getListAccounts :   function ( callback ), \n   lockAccount :   function (), \n   newAccount :   function (), \n   unlockAccount :   function ()  }", 
            "title": "\u4f7f\u7528Eth"
        }, 
        {
            "location": "/account-management/#ethkey", 
            "text": "Ethkey is a CLI tool of the C++ implementation that allows you to\ninteract with the Ethereum wallet. With it you can list, inspect,\ncreate, delete and modify keys and inspect, create and sign\ntransactions.  We will assume you have not yet run a client such as eth or anything in\nthe Aleth series of clients. If you have, you can skip this section. To\ncreate a wallet, run  ethkey  with the  createwallet  command:   ethkey createwallet  Please enter a MASTER passphrase to protect your key store (make it\nstrong!): You'll be asked for a master passphrase. This protects\nyour privacy and acts as a default password for any keys. You'll need\nto confirm it by entering the same text again.  ::: {.note}\n::: {.admonition-title}\nNote\n:::  Use a strong randomly generated password.\n:::  We can list the keys within the wallet simply by using the list command:   ethkey list\n\nNo keys found.  We haven't yet created any keys, and it's telling us so! Let's create\none.  To create a key, we use the  new  command. To use it we must pass a name\n- this is the name we'll give to this account in the wallet. Let's\ncall it test:   ethkey new  test   Enter a passphrase with which to secure this account (or nothing to use\nthe master passphrase). It will prompt you to enter a passphrase to\nprotect this key. If you just press enter, it'll use the default\nmaster passphrase. Typically this means you won't need to enter the\npassphrase for the key when you want to use the account (since it\nremembers the master passphrase). In general, you should try to use a\ndifferent passphrase for each key since it prevents one compromised\npassphrase from giving access to other accounts. However, out of\nconvenience you might decide that for low-security accounts to use the\nsame passphrase.  Here, let's give it the incredibly imaginative passphrase of 123.\n(Never ever use simple passwords like this for anything else than\nephemeral test accounts). Once you enter a passphrase, it'll ask you to\nconfirm it by entering again. Enter 123 a second time. Because you gave\nit its own passphrase, it'll also ask you to provide a hint for this\npassword which will be displayed to you whenever it asks you to enter\nit. The hint is stored in the wallet and is itself protected by the\nmaster passphrase. Enter the truly awful hint of 321 backwards.   ethkey new  test \n\nEnter a passphrase with which to secure this account  ( or nothing to use the master passphrase ) :\nPlease confirm the passphrase by entering it again:\nEnter a hint to  help  you remember this passphrase:  321  backwards\nCreated key 055dde03-47ff-dded-8950-0fe39b1fa101\n  Name:  test \n  Password hint:  321  backwards\n  ICAP: XE472EVKU3CGMJF2YQ0J9RO1Y90BC0LDFZ\n  Raw hex: 0092e965928626f8880629cec353d3fd7ca5974f  All normal (aka direct) ICAP addresses begin with XE so you should be\nable to recognize them easily. Notice also that the key has another\nidentifier after Created key. This is known as the UUID. This is a\nunique identifier for the key that has absolutely nothing to do with the\naccount itself. Knowing it does nothing to help an attacker discover who\nyou are on the network. It also happens to be the filename for the key,\nwhich you can find in either \\~/.web3/keys (Mac or Linux) or\n\\$HOME/AppData/Web3/keys (Windows). Now let's make sure it worked\nproperly by listing the keys in the wallet:   ethkey list\n055dde03-47ff-dded-8950-0fe39b1fa101 0092e965\u2026 XE472EVKU3CGMJF2YQ0J9RO1Y90BC0LDFZ   test   It reports one key on each line (for a total of one key here). In this\ncase our key is stored in a file 055dde... and has an ICAP address\nbeginning XE472EVK.... Not especially easy things to remember so rather\nhelpful that it has its proper name, test, too.", 
            "title": "\u4f7f\u7528EthKey\uff08\u4e0d\u5efa\u8bae\u4f7f\u7528\uff09"
        }, 
        {
            "location": "/account-management/#_7", 
            "text": "", 
            "title": "\u5bfc\u5165\u60a8\u7684\u9884\u552e\u94b1\u5305"
        }, 
        {
            "location": "/account-management/#_8", 
            "text": "Importing your presale wallet using the GUI Mist Ethereum wallet is very\neasy. In fact, you will be asked if you want to import your presale\nwallet during the installation of the app.  ::: {.warning}\n::: {.admonition-title}\nWarning\n:::  Mist wallet is beta software. Beware and use it at your own risk.\n:::  Instructions for installing the Mist Ethereum wallet are given in the\nsection\n[Creating an account: Using Mist Ethereum wallet  ].  Simply drag-and-drop your  .json  presale wallet file into the\ndesignated area and enter your password to import your presale account.  {.align-center\nwidth=\"436px\" height=\"352px\"}  If you choose not to import your presale wallet during installation of\nthe app, you can import it at any time by selecting the  Accounts  menu\nin the app's menu bar and then selecting  Import Pre-sale Accounts .  ::: {.note}\n::: {.admonition-title}\nNote\n:::  The Mist wallet is still in active development, so details of the steps\noutlined above may change with upgrades.\n:::", 
            "title": "\u4f7f\u7528\u8584\u96fe\u4ee5\u592a\u574a\u94b1\u5305"
        }, 
        {
            "location": "/account-management/#geth_1", 
            "text": "If you have a standalone installation of geth, importing your presale\nwallet is accomplished by executing the following command in a terminal:  geth wallet import /path/to/my/presale-wallet.json  You will be prompted to enter your password.", 
            "title": "\u4f7f\u7528geth"
        }, 
        {
            "location": "/account-management/#_9", 
            "text": "You are able to upgrade your keyfile to the latest keyfile format and/or\nupgrade your keyfile password.", 
            "title": "\u66f4\u65b0\u4e00\u4e2a\u5e10\u6237"
        }, 
        {
            "location": "/account-management/#geth_2", 
            "text": "You can update an existing account on the command line with the  update \nsubcommand with the account address or index as parameter. Remember that\nthe account index reflects the order of creation (lexicographic order of\nkeyfile names containing the creation time).  geth account update b0047c606f3af7392e073ed13253f8f4710b08b6  or  geth account update  2   For example:  $ geth account update a94f5374fce5edbc8e2a8697c15331677e6ebf0b\n\nUnlocking account a94f5374fce5edbc8e2a8697c15331677e6ebf0b  |  Attempt  1 /3\nPassphrase:\n0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b\naccount  a94f5374fce5edbc8e2a8697c15331677e6ebf0b  unlocked.\nPlease give a new password. Do not forget this password.\nPassphrase:\nRepeat Passphrase:\n0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b  The account is saved in the newest version in encrypted format, you are\nprompted for a passphrase to unlock the account and another to save the\nupdated file. This same command can be used to migrate an account of a\ndeprecated format to the newest format or change the password for an\naccount.  For non-interactive use the passphrase can be specified with the --password  flag:  geth --password  passwordfile  account update a94f5374fce5edbc8e2a8697c15331677e6ebf0bs  Since only one password can be given, only format update can be\nperformed, changing your password is only possible interactively.  ::: {.note}\n::: {.admonition-title}\nNote\n:::  account update has the side effect that the order of your accounts may\nchange. After a successful update, all previous formats/versions of that\nsame key will be removed!\n:::", 
            "title": "\u4f7f\u7528geth"
        }, 
        {
            "location": "/account-management/#_10", 
            "text": "", 
            "title": "\u5907\u4efd\u548c\u6062\u590d\u5e10\u6237"
        }, 
        {
            "location": "/account-management/#_11", 
            "text": "You must have an account's keyfile to be able to send any transaction\nfrom that account. Keyfiles are found in the keystore subdirectory of\nyour Ethereum node's data directory. The default data directory\nlocations are platform specific:   Windows:  %appdata%\\Ethereum\\keystore  Linux:  ~/.ethereum/keystore  Mac:  ~/Library/Ethereum/keystore   To backup your keyfiles (accounts), copy either the individual keyfiles\nwithin the  keystore  subdirectory or copy the entire  keystore  folder.  To restore your keyfiles (accounts), copy the keyfiles back into the keystore  subdirectory, where they were originally.", 
            "title": "\u624b\u52a8\u5907\u4efd/\u6062\u590d"
        }, 
        {
            "location": "/account-management/#_12", 
            "text": "Importing an unencrypted private key is supported by  geth  geth account import /path/to/ keyfile   This command imports an unencrypted private key from the plain text file keyfile  and creates a new account and prints the address. The\nkeyfile is assumed to contain an unencrypted private key as canonical EC\nraw bytes encoded into hex. The account is saved in encrypted format,\nyou are prompted for a passphrase. You must remember this passphrase to\nunlock your account in the future.  An example where the data directory is specified. If the  --datadir \nflag is not used, the new account will be created in the default data\ndirectory, i.e., the keyfile will be placed in the  keystore \nsubdirectory of the data directory.  $ geth --datadir /someOtherEthDataDir  account import ./key.prv\nThe new account will be encrypted with a passphrase.\nPlease enter a passphrase now.\nPassphrase:\nRepeat Passphrase:\nAddress:  { 7f444580bfef4b9bc7e14eb7fb2a029336b07c9d }   For non-interactive use the passphrase can be specified with the --password  flag:  geth --password  passwordfile  account import  keyfile   ::: {.note}\n::: {.admonition-title}\nNote\n:::  Since you can directly copy your encrypted accounts to another Ethereum\ninstance, this import/export mechanism is not needed when you transfer\nan account between nodes.\n:::  ::: {.warning}\n::: {.admonition-title}\nWarning\n:::  When you copy keys into an existing node's  keystore , the order of\naccounts you are used to may change. Therefore you make sure you either\ndo not rely on the account order or double-check and update the indexes\nused in your scripts.\n:::", 
            "title": "\u5bfc\u5165\u672a\u52a0\u5bc6\u7684\u79c1\u94a5"
        }, 
        {
            "location": "/ether/", 
            "text": "Ether\n\n\n\u4ec0\u4e48\u662fether?\n\n\nEther is the name of the currency used within Ethereum. It is used to\npay for computation within the EVM. This is done indirectly by\npurchasing gas for ether as explained in _gas.\n\n\n\u8ba1\u4ef7\n\n\nEthereum has a metric system of denominations used as units of ether.\nEach denomination has its own unique name (some bear the family name of\nseminal figures playing a role in evolution of computer science and\ncryptoeconomics). The smallest denomination aka \nbase unit\n of ether is\ncalled Wei. Below is a list of the named denominations and their value\nin Wei. Following a common (although somewhat ambiguous) pattern, ether\nalso designates a unit (of 1e18 or one quintillion Wei) of the currency.\nNote that the currency is not called Ethereum as many mistakenly think,\nnor is Ethereum a unit.\n\n\n\n\n\n\n\n\n\u5355\u5143\n\n\nwei \u503c\n\n\nwei\n\n\n\n\n\n\n\n\n\n\nwei\n\n\n1 wei\n\n\n1\n\n\n\n\n\n\nKwei (babbage)\n\n\n1e3 wei\n\n\n1,000\n\n\n\n\n\n\nMwei (lovelace)\n\n\n1e6 wei\n\n\n1,000,000\n\n\n\n\n\n\nGwei (shannon)\n\n\n1e9 wei\n\n\n1,000,000,000\n\n\n\n\n\n\nmicroether (szabo)\n\n\n1e12 wei\n\n\n1,000,000,000,000\n\n\n\n\n\n\n**milliether\n\n\n1e15 wei\n\n\n1,000,000,000,000,000\n\n\n\n\n\n\n(finney)**\n\n\n\n\n\n\n\n\n\n\nether\n\n\n1e18 wei\n\n\n1,000,000,000,000,000,000\n\n\n\n\n\n\n\n\nEther supply\n\n\n\n\nhttps://blog.ethereum.org/2014/04/10/the-issuance-model-in-ethereum/\n\n\nhttps://www.reddit.com/r/ethereum/comments/44zy88/clarification_on_ether_supply_and_cost_of_gas/\n\n\nhttps://www.reddit.com/r/ethereum/comments/45vj4g/question_about_scarcity_of_ethereum_and_its/\n\n\nhttps://www.reddit.com/r/ethtrader/comments/48yqg6/is_there_a_cap_like_with_btc_with_how_many_ether/\n\n\n\n\nGetting ether\n\n\nPlease see this page here \nhttps://github.com/ethereum/wiki/wiki/Getting-Ether\n_.\n\n\nSending ether\n\n\nThe Ethereum Wallet \nhttps://github.com/ethereum/mist/releases\n_  supports sending ether via a graphical interface.\n\n\nEther can also be transferred using the \ngeth console\n.\n\n\n::: console\n\n\n var \nsender\n \n=\n eth.accounts\n\\[\n0\n\\]\n;\n\n\n var \nreceiver\n \n=\n eth.accounts\n\\[\n1\n\\]\n;\n\n\n var \namount\n \n=\n web3.toWei\n(\n0\n.01, \n\\\nether\n\\\n)\n\n\n eth.sendTransaction\n({\nfrom:sender, to:receiver, value: amount\n})\n\n\n\n\n\n\nFor more information of ether transfer transactions, see :ref:account-types-gas-and-transactions`.\n\n\nEthereum is unique in the realm of cryptocurrencies in that ether has\nutility value as a cryptofuel, commonly referred to as \\\"gas\\\". Beyond\ntransaction fees, gas is a central part of every network request and\nrequires the sender to pay for the computing resources consumed. The gas\ncost is dynamically calculated, based on the volume and complexity of\nthe request and multiplied by the current gas price. Its value as a\ncryptofuel has the effect of increasing the stability and long-term\ndemand for ether and Ethereum as a whole. For more information, see\n[account-types-gas-and-transactions]{role=\"ref\"}.\n\n\nGas and ether\n\n\n\n\nhttps://www.reddit.com/r/ethereum/comments/271qdz/can_someone_explain_the_concept_of_gas_in_ethereum/\n\n\nhttps://www.reddit.com/r/ethereum/comments/3fnpr1/can_someone_possibly_explain_the_concept_of/\n\n\nhttps://www.reddit.com/r/ethereum/comments/49gol3/can_ether_be_used_as_a_currency_eli5_ether_gas/\n\n\n\n\nGas is supposed to be the constant cost of network\nresources/utilisation. You want the real cost of sending a transaction\nto always be the same, so you can\\'t really expect Gas to be issued,\ncurrencies in general are volatile.\n\n\nSo instead, we issue ether whose value is supposed to vary, but also\nimplement a Gas Price in terms of Ether. If the price of ether goes up,\nthe Gas Price in terms of ether should go down to keep the real cost of\nGas the same.\n\n\nGas has multiple associated terms with it: Gas Prices, Gas Cost, Gas\nLimit, and Gas Fees. The principle behind Gas is to have a stable value\nfor how much a transaction or computation costs on the Ethereum network.\n\n\n\n\nGas Cost is a static value for how much a computation costs in terms\n    of Gas, and the intent is that the real value of the Gas never\n    changes, so this cost should always stay stable over time.\n\n\nGas Price is how much Gas costs in terms of another currency or\n    token like Ether. To stabilise the value of gas, the Gas Price is a\n    floating value such that if the cost of tokens or currency\n    fluctuates, the Gas Price changes to keep the same real value. The\n    Gas Price is set by the equilibrium price of how much users are\n    willing to spend, and how much processing nodes are willing to\n    accept.\n\n\nGas Limit is the maximum amount of Gas that can be used per block,\n    it is considered the maximum computational load, transaction volume,\n    or block size of a block, and miners can slowly change this value\n    over time.\n\n\nGas Fee is effectively the amount of Gas needed to be paid to run a\n    particular transaction or program (called a contract). The Gas Fees\n    of a block can be used to imply the computational load, transaction\n    volume, or size of a block. The gas fees are paid to the miners (or\n    bonded contractors in PoS).", 
            "title": "\u4ee5\u592a\u5e01"
        }, 
        {
            "location": "/ether/#ether", 
            "text": "", 
            "title": "Ether"
        }, 
        {
            "location": "/ether/#ether_1", 
            "text": "Ether is the name of the currency used within Ethereum. It is used to\npay for computation within the EVM. This is done indirectly by\npurchasing gas for ether as explained in _gas.", 
            "title": "\u4ec0\u4e48\u662fether?"
        }, 
        {
            "location": "/ether/#_1", 
            "text": "Ethereum has a metric system of denominations used as units of ether.\nEach denomination has its own unique name (some bear the family name of\nseminal figures playing a role in evolution of computer science and\ncryptoeconomics). The smallest denomination aka  base unit  of ether is\ncalled Wei. Below is a list of the named denominations and their value\nin Wei. Following a common (although somewhat ambiguous) pattern, ether\nalso designates a unit (of 1e18 or one quintillion Wei) of the currency.\nNote that the currency is not called Ethereum as many mistakenly think,\nnor is Ethereum a unit.     \u5355\u5143  wei \u503c  wei      wei  1 wei  1    Kwei (babbage)  1e3 wei  1,000    Mwei (lovelace)  1e6 wei  1,000,000    Gwei (shannon)  1e9 wei  1,000,000,000    microether (szabo)  1e12 wei  1,000,000,000,000    **milliether  1e15 wei  1,000,000,000,000,000    (finney)**      ether  1e18 wei  1,000,000,000,000,000,000", 
            "title": "\u8ba1\u4ef7"
        }, 
        {
            "location": "/ether/#ether-supply", 
            "text": "https://blog.ethereum.org/2014/04/10/the-issuance-model-in-ethereum/  https://www.reddit.com/r/ethereum/comments/44zy88/clarification_on_ether_supply_and_cost_of_gas/  https://www.reddit.com/r/ethereum/comments/45vj4g/question_about_scarcity_of_ethereum_and_its/  https://www.reddit.com/r/ethtrader/comments/48yqg6/is_there_a_cap_like_with_btc_with_how_many_ether/", 
            "title": "Ether supply"
        }, 
        {
            "location": "/ether/#getting-ether", 
            "text": "Please see this page here  https://github.com/ethereum/wiki/wiki/Getting-Ether _.", 
            "title": "Getting ether"
        }, 
        {
            "location": "/ether/#sending-ether", 
            "text": "The Ethereum Wallet  https://github.com/ethereum/mist/releases _  supports sending ether via a graphical interface.  Ether can also be transferred using the  geth console .  ::: console   var  sender   =  eth.accounts \\[ 0 \\] ;   var  receiver   =  eth.accounts \\[ 1 \\] ;   var  amount   =  web3.toWei ( 0 .01,  \\ ether \\ )   eth.sendTransaction ({ from:sender, to:receiver, value: amount })   For more information of ether transfer transactions, see :ref:account-types-gas-and-transactions`.  Ethereum is unique in the realm of cryptocurrencies in that ether has\nutility value as a cryptofuel, commonly referred to as \\\"gas\\\". Beyond\ntransaction fees, gas is a central part of every network request and\nrequires the sender to pay for the computing resources consumed. The gas\ncost is dynamically calculated, based on the volume and complexity of\nthe request and multiplied by the current gas price. Its value as a\ncryptofuel has the effect of increasing the stability and long-term\ndemand for ether and Ethereum as a whole. For more information, see\n[account-types-gas-and-transactions]{role=\"ref\"}.", 
            "title": "Sending ether"
        }, 
        {
            "location": "/ether/#gas-and-ether", 
            "text": "https://www.reddit.com/r/ethereum/comments/271qdz/can_someone_explain_the_concept_of_gas_in_ethereum/  https://www.reddit.com/r/ethereum/comments/3fnpr1/can_someone_possibly_explain_the_concept_of/  https://www.reddit.com/r/ethereum/comments/49gol3/can_ether_be_used_as_a_currency_eli5_ether_gas/   Gas is supposed to be the constant cost of network\nresources/utilisation. You want the real cost of sending a transaction\nto always be the same, so you can\\'t really expect Gas to be issued,\ncurrencies in general are volatile.  So instead, we issue ether whose value is supposed to vary, but also\nimplement a Gas Price in terms of Ether. If the price of ether goes up,\nthe Gas Price in terms of ether should go down to keep the real cost of\nGas the same.  Gas has multiple associated terms with it: Gas Prices, Gas Cost, Gas\nLimit, and Gas Fees. The principle behind Gas is to have a stable value\nfor how much a transaction or computation costs on the Ethereum network.   Gas Cost is a static value for how much a computation costs in terms\n    of Gas, and the intent is that the real value of the Gas never\n    changes, so this cost should always stay stable over time.  Gas Price is how much Gas costs in terms of another currency or\n    token like Ether. To stabilise the value of gas, the Gas Price is a\n    floating value such that if the cost of tokens or currency\n    fluctuates, the Gas Price changes to keep the same real value. The\n    Gas Price is set by the equilibrium price of how much users are\n    willing to spend, and how much processing nodes are willing to\n    accept.  Gas Limit is the maximum amount of Gas that can be used per block,\n    it is considered the maximum computational load, transaction volume,\n    or block size of a block, and miners can slowly change this value\n    over time.  Gas Fee is effectively the amount of Gas needed to be paid to run a\n    particular transaction or program (called a contract). The Gas Fees\n    of a block can be used to imply the computational load, transaction\n    volume, or size of a block. The gas fees are paid to the miners (or\n    bonded contractors in PoS).", 
            "title": "Gas and ether"
        }, 
        {
            "location": "/network/connecting-to-the-network/", 
            "text": "Connecting to the Network {#sec:connecting-to-the-network}\n\n\nThis section\n\n\nThe Ethereum network\n\n\nThe basis for decentralised consensus is the peer-to-peer network of\nparticipating nodes which maintain and secure the blockchain. See\n[mining]{role=\"ref\"}.\n\n\nEthereum network stats\n\n\nEthStats.net\n is a dashboard of live statistics\nof the Ethereum network. This dashboard displays important information\nsuch as the current block, hash difficulty, gas price, and gas spending.\nThe nodes shown on the page are only a selection of actual nodes on the\nnetwork. Anyone is allowed to add their node to the EthStats dashboard.\nThe \nEth-Netstats README on\nGithub\n describes how to\nconnect.\n\n\nEtherNodes.com\n displays current and\nhistorical data on node count and other information on both the Ethereum\nmainnet and Morden testnet.\n\n\nDistribution of client implementations on the current live\nnetwork\n - Realtime stats on EtherChain.\n\n\nPublic, private, and consortium blockchains\n\n\nMost Ethereum projects today rely on Ethereum as a public blockchain,\nwhich grants access to a larger audience of users, network nodes,\ncurrency, and markets. However, there are often reasons to prefer a\nprivate blockchain or consortium blockchain (among a group of trusted\nparticipants). For example, a number of companies in verticals, like\nbanking, are looking to Ethereum as a platform for their own private\nblockchains.\n\n\nBelow is an excerpt from the blog post \nOn Public and Private\nBlockchains\n\nthat explains the difference between the three types of blockchains\nbased on permissioning:\n\n\n\n\nPublic blockchains\n: a public blockchain is a blockchain that\n    anyone in the world can read, anyone in the world can send\n    transactions to and expect to see them included if they are valid,\n    and anyone in the world can participate in the consensus process --\n    the process for determining what blocks get added to the chain and\n    what the current state is. As a substitute for centralized or\n    quasi-centralized trust, public blockchains are secured by\n    cryptoeconomics -- the combination of economic incentives and\n    cryptographic verification using mechanisms such as proof of work or\n    proof of stake, following a general principle that the degree to\n    which someone can have an influence in the consensus process is\n    proportional to the quantity of economic resources that they can\n    bring to bear. These blockchains are generally considered to be\n    \"fully decentralized\".\n\n\nConsortium blockchains\n: a consortium blockchain is a blockchain\n    where the consensus process is controlled by a pre-selected set of\n    nodes; for example, one might imagine a consortium of 15 financial\n    institutions, each of which operates a node and of which 10 must\n    sign every block in order for the block to be valid. The right to\n    read the blockchain may be public, or restricted to the\n    participants, and there are also hybrid routes such as the root\n    hashes of the blocks being public together with an API that allows\n    members of the public to make a limited number of queries and get\n    back cryptographic proofs of some parts of the blockchain state.\n    These blockchains may be considered \"partially decentralized\".\n\n\nPrivate blockchains\n: a fully private blockchain is a blockchain\n    where write permissions are kept centralized to one organization.\n    Read permissions may be public or restricted to an arbitrary extent.\n    Likely applications include database management, auditing, etc\n    internal to a single company, and so public readability may not be\n    necessary in many cases at all, though in other cases public\n    auditability is desired.\n\n\n\n\nWhile these private/consortium blockchains may not have any connection\nto the public blockchain, they still contribute to the overall Ethereum\necosystem by investing in Ethereum software development. Over time, this\ntranslates into software improvements, shared knowledge, and job\nopportunities.\n\n\nHow to connect\n\n\nGeth continuously attempts to connect to other nodes on the network\nuntil it has peers. If you have UPnP enabled on your router or run\nEthereum on an Internet-facing server, it will also accept connections\nfrom other nodes.\n\n\nGeth finds peers through something called the \ndiscovery protocol\n. In\nthe discovery protocol, nodes are gossipping with each other to find out\nabout other nodes on the network. In order to get going initially, geth\nuses a set of bootstrap nodes whose endpoints are recorded in the source\ncode.\n\n\nChecking connectivity and ENODE IDs\n\n\nTo check how many peers the client is connected to in the interactive\nconsole, the \nnet\n module has two attributes that give you info about\nthe number of peers and whether you are a listening node.\n\n\n``` {.sourceCode .Javascript}\n\n\n\n\nnet.listening\ntrue\n\n\nnet.peerCount\n4\n\nTo get more information about the connected peers, such as IP address\nand port number, supported protocols, use the `peers()` function of the\n`admin` object. `admin.peers()` returns the list of currently connected\npeers.\n\n``` {.sourceCode .Javascript}\n\n admin.peers\n[{\n  ID: \na4de274d3a159e10c2c9a68c326511236381b84c9ec52e72ad732eb0b2b1a2277938f78593cdbe734e6002bf23114d434a085d260514ab336d4acdc312db671b\n,\n  Name: \nGeth/v0.9.14/linux/go1.4.2\n,\n  Caps: \neth/60\n,\n  RemoteAddress: \n5.9.150.40:30301\n,\n  LocalAddress: \n192.168.0.28:39219\n\n }, {\n  ID: \na979fb575495b8d6db44f750317d0f4622bf4c2aa3365d6af7c284339968eef29b69ad0dce72a4d8db5ebb4968de0e3bec910127f134779fbcb0cb6d3331163c\n,\n  Name: \nGeth/v0.9.15/linux/go1.4.2\n,\n  Caps: \neth/60\n,\n  RemoteAddress: \n52.16.188.185:30303\n,\n  LocalAddress: \n192.168.0.28:50995\n\n }, {\n  ID: \nf6ba1f1d9241d48138136ccf5baa6c2c8b008435a1c2bd009ca52fb8edbbc991eba36376beaee9d45f16d5dcbf2ed0bc23006c505d57ffcf70921bd94aa7a172\n,\n  Name: \npyethapp_dd52/v0.9.13/linux2/py2.7.9\n,\n  Caps: \neth/60, p2p/3\n,\n  RemoteAddress: \n144.76.62.101:30303\n,\n  LocalAddress: \n192.168.0.28:40454\n\n }, {\n  ID: \nf4642fa65af50cfdea8fa7414a5def7bb7991478b768e296f5e4a54e8b995de102e0ceae2e826f293c481b5325f89be6d207b003382e18a8ecba66fbaf6416c0\n,\n  Name: \n++eth/Zeppelin/Rascal/v0.9.14/Release/Darwin/clang/int\n,\n  Caps: \neth/60, shh/2\n,\n  RemoteAddress: \n129.16.191.64:30303\n,\n  LocalAddress: \n192.168.0.28:39705\n\n } ]\n\n\n\n\n\nTo check the ports used by geth and also find your enode URI run:\n\n\n``` {.sourceCode .Javascript}\n\n\n\n\nadmin.nodeInfo\n{\n  Name: 'Geth/v0.9.14/darwin/go1.4.2',\n  NodeUrl: 'enode://3414c01c19aa75a34f2dbd2f8d0898dc79d6b219ad77f8155abf1a287ce2ba60f14998a3a98c0cf14915eabfdacf914a92b27a01769de18fa2d049dbf4c17694@[::]:30303',\n  NodeID: '3414c01c19aa75a34f2dbd2f8d0898dc79d6b219ad77f8155abf1a287ce2ba60f14998a3a98c0cf14915eabfdacf914a92b27a01769de18fa2d049dbf4c17694',\n  IP: '::',\n  DiscPort: 30303,\n  TCPPort: 30303,\n  Td: '2044952618444',\n  ListenAddr: '[::]:30303'\n}\n\nDownload the blockchain faster\n------------------------------\n\nWhen you start an Ethereum client, the Ethereum blockchain is\nautomatically downloaded. The time it takes to download the Ethereum\nblockchain can vary based on client, client settings, connection speed,\nand number of peers available. Below are some options for more quickly\nobtaining the Ethereum blockchain.\n\n### Using geth\n\nIf you are using the geth client, there are some things you can do to\nspeed up the time it takes to download the Ethereum blockchain. If you\nchoose to use the `--fast` flag to perform an Ethereum fast sync, you\nwill not retain past transaction data.\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\nYou cannot use this flag after performing all or part of a normal sync\noperation, meaning you should not have any portion of the Ethereum\nblockchain downloaded before using this command. [See this Ethereum\nStack.Exchange answer for more\ninformation](http://ethereum.stackexchange.com/questions/1845/why-isnt-fast-sync-the-default).\n:::\n\nBelow are some flags to use when you want to sync your client more\nquickly.\n\n`--fast`\n\nThis flag enables fast syncing through state downloads rather than\ndownloading the full block data. This will also reduce the size of your\nblockchain dramatically. NOTE: `--fast` can only be run if you are\nsyncing your blockchain from scratch and only the first time you\ndownload the blockchain for security reasons. [See this Reddit post for\nmore\ninformation](https://www.reddit.com/r/ethereum/comments/3y9316/geth_fast_option_question/).\n\n`--cache=1024`\n\nMegabytes of memory allocated to internal caching (min 16MB / database\nforced). Default is 16MB, so increasing this to 256, 512, 1024 (1GB), or\n2048 (2GB) depending on how much RAM your computer has should make a\ndifference.\n\n`--jitvm`\n\nThis flag enables the JIT VM.\n\nFull example command with console:\n\n``` {.sourceCode .Bash}\ngeth --fast --cache=1024 --jitvm console\n\n\n\n\n\nFor more discussion on fast syncing and blockchain download times, \nsee\nthis Reddit\npost\n.\n\n\nExporting/Importing the blockchain\n\n\nIf you already have a full Ethereum node synced, you can export the\nblockchain data from the fully synced node and import it into your new\nnode. You can accomplish this in geth by exporting your full node with\nthe command \ngeth export filename\n and importing the blockchain into\nyour node using \ngeth import filename\n. see \nthis link\n\n\nStatic Nodes, Trusted Nodes, and Boot Nodes\n\n\nGeth supports a feature called static nodes if you have certain peers\nyou always want to connect to. Static nodes are re-connected on\ndisconnects. You can configure permanent static nodes by putting\nsomething like the following into \ndatadir\n/static-nodes.json\n (this\nshould be the same folder that your \nchaindata\n and \nkeystore\n folders\nare in)\n\n\n``` {.sourceCode .Javascript}\n[\n  \"enode://f4642fa65af50cfdea8fa7414a5def7bb7991478b768e296f5e4a54e8b995de102e0ceae2e826f293c481b5325f89be6d207b003382e18a8ecba66fbaf6416c0@33.4.2.1:30303\",\n  \"enode://pubkey@ip:port\"\n]\n\nYou\n \ncan\n \nalso\n \nadd\n \nstatic\n \nnodes\n \nat\n \nruntime\n \nvia\n \nthe\n \nJavascript\n \nconsole\n\n\nusing\n \n`\nadmin\n.\naddPeer\n()\n`\n\n\n\n```\n \n{.\nsourceCode\n \n.\nConsole\n}\n\n\n \nadmin\n.\naddPeer\n(\nenode://f4642fa65af50cfdea8fa7414a5def7bb7991478b768e296f5e4a54e8b995de102e0ceae2e826f293c481b5325f89be6d207b003382e18a8ecba66fbaf6416c0@33.4.2.1:30303\n)\n\n\n\n\nCommon problems with connectivity\n\n\nSometimes you just can\\'t get connected. The most common reasons are:\n\n\n\n\nYour local time might be incorrect. An accurate clock is required to\n    participate in the Ethereum network. Check your OS for how to resync\n    your clock (example \nsudo ntpdate -s time.nist.gov\n) because even 12\n    seconds too fast can lead to 0 peers.\n\n\nSome firewall configurations can prevent UDP traffic from flowing.\n    You can use the static nodes feature or \nadmin.addPeer()\n on the\n    console to configure connections by hand.\n\n\n\n\nTo start geth without the discovery protocol, you can use the\n\n--nodiscover\n parameter. You only want this if you are running a test\nnode or an experimental test network with fixed nodes.", 
            "title": "\u8fde\u63a5\u5230\u7f51\u7edc"
        }, 
        {
            "location": "/network/connecting-to-the-network/#connecting-to-the-network-secconnecting-to-the-network", 
            "text": "This section", 
            "title": "Connecting to the Network {#sec:connecting-to-the-network}"
        }, 
        {
            "location": "/network/connecting-to-the-network/#the-ethereum-network", 
            "text": "The basis for decentralised consensus is the peer-to-peer network of\nparticipating nodes which maintain and secure the blockchain. See\n[mining]{role=\"ref\"}.", 
            "title": "The Ethereum network"
        }, 
        {
            "location": "/network/connecting-to-the-network/#ethereum-network-stats", 
            "text": "EthStats.net  is a dashboard of live statistics\nof the Ethereum network. This dashboard displays important information\nsuch as the current block, hash difficulty, gas price, and gas spending.\nThe nodes shown on the page are only a selection of actual nodes on the\nnetwork. Anyone is allowed to add their node to the EthStats dashboard.\nThe  Eth-Netstats README on\nGithub  describes how to\nconnect.  EtherNodes.com  displays current and\nhistorical data on node count and other information on both the Ethereum\nmainnet and Morden testnet.  Distribution of client implementations on the current live\nnetwork  - Realtime stats on EtherChain.", 
            "title": "Ethereum network stats"
        }, 
        {
            "location": "/network/connecting-to-the-network/#public-private-and-consortium-blockchains", 
            "text": "Most Ethereum projects today rely on Ethereum as a public blockchain,\nwhich grants access to a larger audience of users, network nodes,\ncurrency, and markets. However, there are often reasons to prefer a\nprivate blockchain or consortium blockchain (among a group of trusted\nparticipants). For example, a number of companies in verticals, like\nbanking, are looking to Ethereum as a platform for their own private\nblockchains.  Below is an excerpt from the blog post  On Public and Private\nBlockchains \nthat explains the difference between the three types of blockchains\nbased on permissioning:   Public blockchains : a public blockchain is a blockchain that\n    anyone in the world can read, anyone in the world can send\n    transactions to and expect to see them included if they are valid,\n    and anyone in the world can participate in the consensus process --\n    the process for determining what blocks get added to the chain and\n    what the current state is. As a substitute for centralized or\n    quasi-centralized trust, public blockchains are secured by\n    cryptoeconomics -- the combination of economic incentives and\n    cryptographic verification using mechanisms such as proof of work or\n    proof of stake, following a general principle that the degree to\n    which someone can have an influence in the consensus process is\n    proportional to the quantity of economic resources that they can\n    bring to bear. These blockchains are generally considered to be\n    \"fully decentralized\".  Consortium blockchains : a consortium blockchain is a blockchain\n    where the consensus process is controlled by a pre-selected set of\n    nodes; for example, one might imagine a consortium of 15 financial\n    institutions, each of which operates a node and of which 10 must\n    sign every block in order for the block to be valid. The right to\n    read the blockchain may be public, or restricted to the\n    participants, and there are also hybrid routes such as the root\n    hashes of the blocks being public together with an API that allows\n    members of the public to make a limited number of queries and get\n    back cryptographic proofs of some parts of the blockchain state.\n    These blockchains may be considered \"partially decentralized\".  Private blockchains : a fully private blockchain is a blockchain\n    where write permissions are kept centralized to one organization.\n    Read permissions may be public or restricted to an arbitrary extent.\n    Likely applications include database management, auditing, etc\n    internal to a single company, and so public readability may not be\n    necessary in many cases at all, though in other cases public\n    auditability is desired.   While these private/consortium blockchains may not have any connection\nto the public blockchain, they still contribute to the overall Ethereum\necosystem by investing in Ethereum software development. Over time, this\ntranslates into software improvements, shared knowledge, and job\nopportunities.", 
            "title": "Public, private, and consortium blockchains"
        }, 
        {
            "location": "/network/connecting-to-the-network/#how-to-connect", 
            "text": "Geth continuously attempts to connect to other nodes on the network\nuntil it has peers. If you have UPnP enabled on your router or run\nEthereum on an Internet-facing server, it will also accept connections\nfrom other nodes.  Geth finds peers through something called the  discovery protocol . In\nthe discovery protocol, nodes are gossipping with each other to find out\nabout other nodes on the network. In order to get going initially, geth\nuses a set of bootstrap nodes whose endpoints are recorded in the source\ncode.", 
            "title": "How to connect"
        }, 
        {
            "location": "/network/connecting-to-the-network/#checking-connectivity-and-enode-ids", 
            "text": "To check how many peers the client is connected to in the interactive\nconsole, the  net  module has two attributes that give you info about\nthe number of peers and whether you are a listening node.  ``` {.sourceCode .Javascript}   net.listening\ntrue  net.peerCount\n4 To get more information about the connected peers, such as IP address\nand port number, supported protocols, use the `peers()` function of the\n`admin` object. `admin.peers()` returns the list of currently connected\npeers.\n\n``` {.sourceCode .Javascript}  admin.peers\n[{\n  ID:  a4de274d3a159e10c2c9a68c326511236381b84c9ec52e72ad732eb0b2b1a2277938f78593cdbe734e6002bf23114d434a085d260514ab336d4acdc312db671b ,\n  Name:  Geth/v0.9.14/linux/go1.4.2 ,\n  Caps:  eth/60 ,\n  RemoteAddress:  5.9.150.40:30301 ,\n  LocalAddress:  192.168.0.28:39219 \n }, {\n  ID:  a979fb575495b8d6db44f750317d0f4622bf4c2aa3365d6af7c284339968eef29b69ad0dce72a4d8db5ebb4968de0e3bec910127f134779fbcb0cb6d3331163c ,\n  Name:  Geth/v0.9.15/linux/go1.4.2 ,\n  Caps:  eth/60 ,\n  RemoteAddress:  52.16.188.185:30303 ,\n  LocalAddress:  192.168.0.28:50995 \n }, {\n  ID:  f6ba1f1d9241d48138136ccf5baa6c2c8b008435a1c2bd009ca52fb8edbbc991eba36376beaee9d45f16d5dcbf2ed0bc23006c505d57ffcf70921bd94aa7a172 ,\n  Name:  pyethapp_dd52/v0.9.13/linux2/py2.7.9 ,\n  Caps:  eth/60, p2p/3 ,\n  RemoteAddress:  144.76.62.101:30303 ,\n  LocalAddress:  192.168.0.28:40454 \n }, {\n  ID:  f4642fa65af50cfdea8fa7414a5def7bb7991478b768e296f5e4a54e8b995de102e0ceae2e826f293c481b5325f89be6d207b003382e18a8ecba66fbaf6416c0 ,\n  Name:  ++eth/Zeppelin/Rascal/v0.9.14/Release/Darwin/clang/int ,\n  Caps:  eth/60, shh/2 ,\n  RemoteAddress:  129.16.191.64:30303 ,\n  LocalAddress:  192.168.0.28:39705 \n } ]   To check the ports used by geth and also find your enode URI run:  ``` {.sourceCode .Javascript}   admin.nodeInfo\n{\n  Name: 'Geth/v0.9.14/darwin/go1.4.2',\n  NodeUrl: 'enode://3414c01c19aa75a34f2dbd2f8d0898dc79d6b219ad77f8155abf1a287ce2ba60f14998a3a98c0cf14915eabfdacf914a92b27a01769de18fa2d049dbf4c17694@[::]:30303',\n  NodeID: '3414c01c19aa75a34f2dbd2f8d0898dc79d6b219ad77f8155abf1a287ce2ba60f14998a3a98c0cf14915eabfdacf914a92b27a01769de18fa2d049dbf4c17694',\n  IP: '::',\n  DiscPort: 30303,\n  TCPPort: 30303,\n  Td: '2044952618444',\n  ListenAddr: '[::]:30303'\n} Download the blockchain faster\n------------------------------\n\nWhen you start an Ethereum client, the Ethereum blockchain is\nautomatically downloaded. The time it takes to download the Ethereum\nblockchain can vary based on client, client settings, connection speed,\nand number of peers available. Below are some options for more quickly\nobtaining the Ethereum blockchain.\n\n### Using geth\n\nIf you are using the geth client, there are some things you can do to\nspeed up the time it takes to download the Ethereum blockchain. If you\nchoose to use the `--fast` flag to perform an Ethereum fast sync, you\nwill not retain past transaction data.\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\nYou cannot use this flag after performing all or part of a normal sync\noperation, meaning you should not have any portion of the Ethereum\nblockchain downloaded before using this command. [See this Ethereum\nStack.Exchange answer for more\ninformation](http://ethereum.stackexchange.com/questions/1845/why-isnt-fast-sync-the-default).\n:::\n\nBelow are some flags to use when you want to sync your client more\nquickly.\n\n`--fast`\n\nThis flag enables fast syncing through state downloads rather than\ndownloading the full block data. This will also reduce the size of your\nblockchain dramatically. NOTE: `--fast` can only be run if you are\nsyncing your blockchain from scratch and only the first time you\ndownload the blockchain for security reasons. [See this Reddit post for\nmore\ninformation](https://www.reddit.com/r/ethereum/comments/3y9316/geth_fast_option_question/).\n\n`--cache=1024`\n\nMegabytes of memory allocated to internal caching (min 16MB / database\nforced). Default is 16MB, so increasing this to 256, 512, 1024 (1GB), or\n2048 (2GB) depending on how much RAM your computer has should make a\ndifference.\n\n`--jitvm`\n\nThis flag enables the JIT VM.\n\nFull example command with console:\n\n``` {.sourceCode .Bash}\ngeth --fast --cache=1024 --jitvm console   For more discussion on fast syncing and blockchain download times,  see\nthis Reddit\npost .", 
            "title": "Checking connectivity and ENODE IDs"
        }, 
        {
            "location": "/network/connecting-to-the-network/#exportingimporting-the-blockchain", 
            "text": "If you already have a full Ethereum node synced, you can export the\nblockchain data from the fully synced node and import it into your new\nnode. You can accomplish this in geth by exporting your full node with\nthe command  geth export filename  and importing the blockchain into\nyour node using  geth import filename . see  this link", 
            "title": "Exporting/Importing the blockchain"
        }, 
        {
            "location": "/network/connecting-to-the-network/#static-nodes-trusted-nodes-and-boot-nodes", 
            "text": "Geth supports a feature called static nodes if you have certain peers\nyou always want to connect to. Static nodes are re-connected on\ndisconnects. You can configure permanent static nodes by putting\nsomething like the following into  datadir /static-nodes.json  (this\nshould be the same folder that your  chaindata  and  keystore  folders\nare in)  ``` {.sourceCode .Javascript}\n[\n  \"enode://f4642fa65af50cfdea8fa7414a5def7bb7991478b768e296f5e4a54e8b995de102e0ceae2e826f293c481b5325f89be6d207b003382e18a8ecba66fbaf6416c0@33.4.2.1:30303\",\n  \"enode://pubkey@ip:port\"\n] You   can   also   add   static   nodes   at   runtime   via   the   Javascript   console  using   ` admin . addPeer () `  ```   {. sourceCode   . Console }    admin . addPeer ( enode://f4642fa65af50cfdea8fa7414a5def7bb7991478b768e296f5e4a54e8b995de102e0ceae2e826f293c481b5325f89be6d207b003382e18a8ecba66fbaf6416c0@33.4.2.1:30303 )", 
            "title": "Static Nodes, Trusted Nodes, and Boot Nodes"
        }, 
        {
            "location": "/network/connecting-to-the-network/#common-problems-with-connectivity", 
            "text": "Sometimes you just can\\'t get connected. The most common reasons are:   Your local time might be incorrect. An accurate clock is required to\n    participate in the Ethereum network. Check your OS for how to resync\n    your clock (example  sudo ntpdate -s time.nist.gov ) because even 12\n    seconds too fast can lead to 0 peers.  Some firewall configurations can prevent UDP traffic from flowing.\n    You can use the static nodes feature or  admin.addPeer()  on the\n    console to configure connections by hand.   To start geth without the discovery protocol, you can use the --nodiscover  parameter. You only want this if you are running a test\nnode or an experimental test network with fixed nodes.", 
            "title": "Common problems with connectivity"
        }, 
        {
            "location": "/network/test-networks/", 
            "text": "Test Networks\n\n\nMorden testnet\n\n\nMorden is a public Ethereum alternative testnet. It is expected to\ncontinue throughout the Frontier and Homestead milestones of the\nsoftware.\n\n\nUsage\n\n\neth (C++ client)\n\n\nThis is supported natively on 0.9.93 and above. Pass the \n--morden\n\nargument in when starting any of the clients. e.g.:\n\n\n``` {.sourceCode .Console}\n\n\n\n\neth --morden\n\n#### PyEthApp (Python client)\n\nPyEthApp supports the morden network from v1.0.5 onwards:\n\n``` {.sourceCode .Console}\n\n pyethapp --profile morden run\n\n\n\n\n\ngeth (Go client)\n\n\n``` {.sourceCode .Console}\n\n\n\n\ngeth --testnet\n\n### Details\n\nAll parameters are the same as the main Ethereum network except:\n\n-   Network Name: **Morden**\n-   Network Identity: 2\n-   genesis.json (given below);\n-   Initial Account Nonce (`IAN`) is 2\\^20 (instead of 0 in all previous\n    networks).\n    -   All accounts in the state trie have nonce \\\n= `IAN`.\n    -   Whenever an account is inserted into the state trie it is\n        initialised with nonce = `IAN`.\n-   Genesis generic block hash:\n    `0cd786a2425d16f152c658316c423e6ce1181e15c3295826d7c9904cba9ce303`\n-   Genesis generic state root:\n    `f3f4696bbf3b3b07775128eb7a3763279a394e382130f27c21e70233e04946a9`\n\n#### Morden\\\ns genesis.json\n\n``` {.sourceCode .JSON}\n{\n        \nnonce\n: \n0x00006d6f7264656e\n,\n        \ndifficulty\n: \n0x20000\n,\n        \nmixhash\n: \n0x00000000000000000000000000000000000000647572616c65787365646c6578\n,\n        \ncoinbase\n: \n0x0000000000000000000000000000000000000000\n,\n        \ntimestamp\n: \n0x00\n,\n        \nparentHash\n: \n0x0000000000000000000000000000000000000000000000000000000000000000\n,\n        \nextraData\n: \n0x\n,\n        \ngasLimit\n: \n0x2FEFD8\n,\n        \nalloc\n: {\n                \n0000000000000000000000000000000000000001\n: { \nbalance\n: \n1\n },\n                \n0000000000000000000000000000000000000002\n: { \nbalance\n: \n1\n },\n                \n0000000000000000000000000000000000000003\n: { \nbalance\n: \n1\n },\n                \n0000000000000000000000000000000000000004\n: { \nbalance\n: \n1\n },\n                \n102e61f5d8f9bc71d0ad4a084df4e65e05ce0e1c\n: { \nbalance\n: \n1606938044258990275541962092341162602522202993782792835301376\n }\n        }\n}\n\n\n\n\n\nGetting Morden testnet ether\n\n\nBecause of decreased mining difficulty on the testnet, ether can easily\nmined using your CPU/GPU (see [mining]{role=\"ref\"}).\n\n\nSetting up a local private testnet\n\n\neth (C++ client) {#custom-networks-eth}\n\n\nIt is possible to connect to or create a new network by using the\n--genesis and --config.\n\n\n``` {.sourceCode .Console}\n\n\n\n\neth --private \"customChain\" --config config.json --genesis genesis.json\n\nIt is possible to use both \\--config and \\--genesis.\n\nIn that case, the genesis block description provided by \\--config will\nbe overwritten by the \\--genesis option.\n\n``` {.sourceCode .Console}\n--private //defines the name of the custom chain (optional).\n\n\n\n\n\n``` {.sourceCode .Console}\n--config \n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\\\nfilename\\\n contains a JSON description of the network:\n\n-   sealEngine (engine use to mine block)\n\n    \n \\\nEthash\\\n is the Ethereum proof of work engine (used by the live\n    \n network).\n    \n\n    \n \\\nNoProof\\\n no proof of work is needed to mine a block.\n\n-   params (general network information like minGasLimit,\n    minimumDifficulty, blockReward, networkID)\n-   genesis (genesis block description)\n-   accounts (setup an original state that contains accounts/contracts)\n:::\n\nHere is a Config sample (used by the Olympic network):\n\n``` {.sourceCode .JSON}\n{\n    \nsealEngine\n: \nEthash\n,\n    \nparams\n: {\n        \naccountStartNonce\n: \n0x00\n,\n        \nfrontierCompatibilityModeLimit\n: \n0xffffffff\n,\n        \nmaximumExtraDataSize\n: \n0x0400\n,\n        \ntieBreakingGas\n: false,\n        \nminGasLimit\n: \n125000\n,\n        \ngasLimitBoundDivisor\n: \n0x0400\n,\n        \nminimumDifficulty\n: \n0x020000\n,\n        \ndifficultyBoundDivisor\n: \n0x0800\n,\n        \ndurationLimit\n: \n0x08\n,\n        \nblockReward\n: \n0x14D1120D7B160000\n,\n        \nregistrar\n: \n5e70c0bbcd5636e0f9f9316e9f8633feb64d4050\n,\n        \nnetworkID\n : \n0x0\n\n    },\n    \ngenesis\n: {\n        \nnonce\n: \n0x000000000000002a\n,\n        \ndifficulty\n: \n0x20000\n,\n        \nmixHash\n: \n0x0000000000000000000000000000000000000000000000000000000000000000\n,\n        \nauthor\n: \n0x0000000000000000000000000000000000000000\n,\n        \ntimestamp\n: \n0x00\n,\n        \nparentHash\n: \n0x0000000000000000000000000000000000000000000000000000000000000000\n,\n        \nextraData\n: \n0x\n,\n        \ngasLimit\n: \n0x2fefd8\n\n    },\n    \naccounts\n: {\n        \n0000000000000000000000000000000000000001\n: { \nwei\n: \n1\n, \nprecompiled\n: { \nname\n: \necrecover\n, \nlinear\n: { \nbase\n: 3000, \nword\n: 0 } } },\n        \n0000000000000000000000000000000000000002\n: { \nwei\n: \n1\n, \nprecompiled\n: { \nname\n: \nsha256\n, \nlinear\n: { \nbase\n: 60, \nword\n: 12 } } },\n        \n0000000000000000000000000000000000000003\n: { \nwei\n: \n1\n, \nprecompiled\n: { \nname\n: \nripemd160\n, \nlinear\n: { \nbase\n: 600, \nword\n: 120 } } },\n        \n0000000000000000000000000000000000000004\n: { \nwei\n: \n1\n, \nprecompiled\n: { \nname\n: \nidentity\n, \nlinear\n: { \nbase\n: 15, \nword\n: 3 } } },\n        \ndbdbdb2cbd23b783741e8d7fcf51e459b497e4a6\n: { \nwei\n: \n1606938044258990275541962092341162602522202993782792835301376\n },\n        \ne6716f9544a56c530d868e4bfbacb172315bdead\n: { \nwei\n: \n1606938044258990275541962092341162602522202993782792835301376\n },\n        \nb9c015918bdaba24b4ff057a92a3873d6eb201be\n: { \nwei\n: \n1606938044258990275541962092341162602522202993782792835301376\n },\n        \n1a26338f0d905e295fccb71fa9ea849ffa12aaf4\n: { \nwei\n: \n1606938044258990275541962092341162602522202993782792835301376\n },\n        \n2ef47100e0787b915105fd5e3f4ff6752079d5cb\n: { \nwei\n: \n1606938044258990275541962092341162602522202993782792835301376\n },\n        \ncd2a3d9f938e13cd947ec05abc7fe734df8dd826\n: { \nwei\n: \n1606938044258990275541962092341162602522202993782792835301376\n },\n        \n6c386a4b26f73c802f34673f7248bb118f97424a\n: { \nwei\n: \n1606938044258990275541962092341162602522202993782792835301376\n },\n        \ne4157b34ea9615cfbde6b4fda419828124b70c78\n: { \nwei\n: \n1606938044258990275541962092341162602522202993782792835301376\n }\n    }\n}\n\n\n\n``` {.sourceCode .Console}\n--genesis \n (optional if the config option is provided and contains the genesis description).\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\\\nfilename\\\n contains a JSON description of the genesis block:\n:::\n\nThe content is the same as the genesis field provided by the \\\nconfig\\\n\nparameter:\n\n``` {.sourceCode .JavaScript}\n{\n      \nnonce\n: \n0x000000000000002a\n,\n      \ndifficulty\n: \n0x20000\n,\n      \nmixHash\n: \n0x0000000000000000000000000000000000000000000000000000000000000000\n,\n      \nauthor\n: \n0x0000000000000000000000000000000000000000\n,\n      \ntimestamp\n: \n0x00\n,\n      \nparentHash\n: \n0x0000000000000000000000000000000000000000000000000000000000000000\n,\n      \nextraData\n: \n0x\n,\n      \ngasLimit\n: \n0x2fefd8\n\n}\n\n\n\ngeth (Go client)\n\n\nYou either pre-generate or mine your own ether on a private testnet. It\nis a much more cost effective way of trying out Ethereum and you can\navoid having to mine or find Morden test ether.\n\n\nThe things that are required to specify in a private chain are:\n\n\n:   -   Custom Genesis File\n    -   Custom Data Directory\n    -   Custom NetworkID\n    -   (Recommended) Disable Node Discovery\n\n\nThe genesis file\n\n\nThe genesis block is the start of the blockchain - the first block,\nblock 0, and the only block that does not point to a predecessor block.\nThe protocol ensures that no other node will agree with your version of\nthe blockchain unless they have the same genesis block, so you can make\nas many private testnet blockchains as you\\'d like!\n\n\n[CustomGenesis.json]{role=\"file\"}\n\n\n``` {.sourceCode .JSON}\n{\n    \"config\": { }, \"nonce\": \"0x0000000000000042\",     \"timestamp\": \"0x0\",\n    \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"extraData\": \"0x00\",     \"gasLimit\": \"0x8000000\",     \"difficulty\": \"0x400\",\n    \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"coinbase\": \"0x3333333333333333333333333333333333333333\",     \"alloc\": {     }\n}\n\nSave a file called [CustomGenesis.json]{role=\nfile\n}. You will reference\nthis when starting your geth node using the following command:\n\n`geth init /path/to/CustomGenesis.json`\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\nBy default geth will use the same directory for network related files as\nfor the public mainnet. Thus you are advised to set a custom `--datadir`\nto keep the public network\\\ns chaindata from bing reset.\n:::\n\n### Command line parameters for private network\n\nThere are some command line options (also called \nflags\n) that are\nnecessary in order to make sure that your network is private. We already\ncovered the genesis flag, but we need a few more. Note that all of the\ncommands below are to be used in the geth Ethereum client.\n\n`--nodiscover`\n\nUse this to make sure that your node is not discoverable by people who\ndo not manually add you. Otherwise, there is a chance that your node may\nbe inadvertently added to a stranger\\\ns blockchain if they have the same\ngenesis file and network id.\n\n`--maxpeers 0`\n\nUse maxpeers 0 if you do not want anyone else connecting to your test\nchain. Alternatively, you can adjust this number if you know exactly how\nmany peers you want connecting to your node.\n\n`--rpc`\n\nThis will enable RPC interface on your node. This is generally enabled\nby default in Geth.\n\n`--rpcapi \ndb,eth,net,web3\n`\n\nThis dictates what APIs that are allowed to be accessed over RPC. By\ndefault, Geth enables the web3 interface over RPC.\n\n**IMPORTANT: Please note that offering an API over the RPC/IPC interface\nwill give everyone access to the API who can access this interface (e.g.\ndapp\\\ns). Be careful which API\\\ns you enable. By default geth enables\nall API\\\ns over the IPC interface and only the db,eth,net and web3\nAPI\\\ns over the RPC interface.**\n\n`--rpcport \n8080\n`\n\nChange 8000 to any port that is open on your network. The default for\ngeth is 8080.\n\n`--rpccorsdomain \nhttp://chriseth.github.io/browser-solidity/\n`\n\nThis dictates what URLs can connect to your node in order to perform RPC\nclient tasks. Be very careful with this and type a specific URL rather\nthan the wildcard (\\*) which would allow any URL to connect to your RPC\ninstance.\n\n`--datadir \n/home/TestChain1\n`\n\nThis is the data directory that your private chain data will be stored\nin (under the [nubits]{role=\nfile\n} . Choose a location that is separate\nfrom your public Ethereum chain folder.\n\n`--port \n30303\n`\n\nThis is the \\\nnetwork listening port\\\n, which you will use to connect\nwith other peers manually.\n\n`--identity \nTestnetMainNode\n`\n\nThis will set up an identity for your node so it can be identified more\neasily in a list of peers. Here is an example of how these identities\nshow up on the network.\n\n### Launching `geth`\n\nAfter you have created your custom genesis block JSON file and created a\ndirectory for your blockchain data, type the following command into your\nconsole that has access to geth:\n\n``` {.sourceCode .Console}\ngeth --identity \nMyNodeName\n --rpc --rpcport \n8080\n --rpccorsdomain \n*\n --datadir \nC:\\chains\\TestChain1\n --port \n30303\n --nodiscover --rpcapi \ndb,eth,net,web3\n --networkid 1999 init /path/to/CustomGenesis.json\n\n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\nPlease change the flags to match your custom settings.\n:::\n\n\nThis will initialize your genesis block. To interact with geth through\nthe console enter:\n\n\n``` {.sourceCode .Console}\ngeth --identity \"MyNodeName\" --rpc --rpcport \"8080\" --rpccorsdomain \"*\" --datadir \"C:\\chains\\TestChain1\" --port \"30303\" --nodiscover --rpcapi \"db,eth,net,web3\" --networkid 1999 console\n\nYou will need to start your geth instance with your custom chain command\nevery time you want to access your custom chain. If you just type\n\\\ngeth\\\n in your console, it will not remember all of the flags you have\nset.\n\nThe full list of methods available through the javascript console is\navailable on [the geth wiki on\ngithub](https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console)\n\nIf you already have a geth node running, you can attach another geth\ninstance to it using:\n\n``` {.sourceCode .Console}\ngeth attach\n\n\n\nNow you\\'ll need to initialize a new account on the testnest, and set it\nas your etherbase (the address that will receive mining rewards).\n\n\nIn the javascript console type\n\n\n``` {.sourceCode .Console}\npersonal.newAccount(\"password\")\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\nReplace with the password of your choice\n:::\n\nNow we\\\nll set it as the etherbase:\n\n``` {.sourceCode .Console}\nminer.setEtherbase(personal.listAccounts[0])\n\n\n\nIf successful, the console will print \\\"true\\\"\n\n\nFinally, you are ready to start mining test ether:\n\n\n``` {.sourceCode .Console}\nminer.start()\n\n### Pre-allocating ether to your account\n\nA difficulty of \\\n0x400\\\n allows you to mine Ether very quickly on your\nprivate testnet chain. If you create your chain and start mining, you\nshould have hundreds of ether in a matter of minutes which is way more\nthan enough to test transactions on your network. If you would still\nlike to pre-allocate Ether to your account, you will need to:\n\n1.  Create a new Ethereum account after you create your private chain\n2.  Copy your new account address\n3.  Add the following command to your Custom\\_Genesis.json file:\n\n``` {.sourceCode .Javascript}\n\nalloc\n:\n{\n    \nyour account address e.g. 0x1fb891f92eb557f4d688463d0d7c560552263b5a\n:\n    { \nbalance\n: \n20000000000000000000\n }\n}\n\n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\nReplace \n0x1fb891f92eb557f4d688463d0d7c560552263b5a\n with your account\naddress.\n:::\n\n\nSave your genesis file and rerun your private chain command. Once geth\nis fully loaded, close it by .\n\n\nWe want to assign an address to the variable \nprimary\n and check its\nbalance.\n\n\nRun the command \ngeth account list\n in your terminal to see what account\n# your new address was assigned.\n\n\n``` {.sourceCode .Console}\n\n\n\n\ngeth account list\nAccount #0: {d1ade25ccd3d550a7eb532ac759cac7be09c2719}\nAccount #1: {da65665fc30803cb1fb7e6d86691e20b1826dee0}\nAccount #2: {e470b1a7d2c9c5c6f03bbaa8fa20db6d404a0c32}\nAccount #3: {f4dd5c3794f1fd0cdc0327a83aa472609c806e99}\n\nTake note of which account \\# is the one that you pre-allocated ether\nto. Alternatively, you can launch the console with `geth console` (keep\nthe same parameters as when you launched `geth` first). Once the prompt\nappears, type\n\n``` {.sourceCode .Console}\n\n eth.accounts\n\n\n\n\n\nThis will return the array of account addresses you possess.\n\n\n``` {.sourceCode .Console}\n\n\n\n\nprimary = eth.accounts[0]\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\nReplace `0` with your account\\\ns index. This console command should\nreturn your primary Ethereum address.\n:::\n\nType the following command:\n\n``` {.sourceCode .Console}\n\n balance = web3.fromWei(eth.getBalance(primary), \nether\n);\n\n\n\n\n\nThis should return \n7.5\n indicating you have that much ether in your\naccount. The reason we had to put such a large number in the alloc\nsection of your genesis file is because the \\\"balance\\\" field takes a\nnumber in wei which is the smallest denomination of the Ethereum\ncurrency ether (see _Ether).\n\n\n\n\nhttps://www.reddit.com/r/ethereum/comments/3kdnus/question_about_private_chain_mining_dont_upvote/", 
            "title": "\u6d4b\u8bd5\u7f51\u7edc"
        }, 
        {
            "location": "/network/test-networks/#test-networks", 
            "text": "", 
            "title": "Test Networks"
        }, 
        {
            "location": "/network/test-networks/#morden-testnet", 
            "text": "Morden is a public Ethereum alternative testnet. It is expected to\ncontinue throughout the Frontier and Homestead milestones of the\nsoftware.", 
            "title": "Morden testnet"
        }, 
        {
            "location": "/network/test-networks/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/network/test-networks/#eth-c-client", 
            "text": "This is supported natively on 0.9.93 and above. Pass the  --morden \nargument in when starting any of the clients. e.g.:  ``` {.sourceCode .Console}   eth --morden #### PyEthApp (Python client)\n\nPyEthApp supports the morden network from v1.0.5 onwards:\n\n``` {.sourceCode .Console}  pyethapp --profile morden run", 
            "title": "eth (C++ client)"
        }, 
        {
            "location": "/network/test-networks/#geth-go-client", 
            "text": "``` {.sourceCode .Console}   geth --testnet ### Details\n\nAll parameters are the same as the main Ethereum network except:\n\n-   Network Name: **Morden**\n-   Network Identity: 2\n-   genesis.json (given below);\n-   Initial Account Nonce (`IAN`) is 2\\^20 (instead of 0 in all previous\n    networks).\n    -   All accounts in the state trie have nonce \\ = `IAN`.\n    -   Whenever an account is inserted into the state trie it is\n        initialised with nonce = `IAN`.\n-   Genesis generic block hash:\n    `0cd786a2425d16f152c658316c423e6ce1181e15c3295826d7c9904cba9ce303`\n-   Genesis generic state root:\n    `f3f4696bbf3b3b07775128eb7a3763279a394e382130f27c21e70233e04946a9`\n\n#### Morden\\ s genesis.json\n\n``` {.sourceCode .JSON}\n{\n         nonce :  0x00006d6f7264656e ,\n         difficulty :  0x20000 ,\n         mixhash :  0x00000000000000000000000000000000000000647572616c65787365646c6578 ,\n         coinbase :  0x0000000000000000000000000000000000000000 ,\n         timestamp :  0x00 ,\n         parentHash :  0x0000000000000000000000000000000000000000000000000000000000000000 ,\n         extraData :  0x ,\n         gasLimit :  0x2FEFD8 ,\n         alloc : {\n                 0000000000000000000000000000000000000001 : {  balance :  1  },\n                 0000000000000000000000000000000000000002 : {  balance :  1  },\n                 0000000000000000000000000000000000000003 : {  balance :  1  },\n                 0000000000000000000000000000000000000004 : {  balance :  1  },\n                 102e61f5d8f9bc71d0ad4a084df4e65e05ce0e1c : {  balance :  1606938044258990275541962092341162602522202993782792835301376  }\n        }\n}", 
            "title": "geth (Go client)"
        }, 
        {
            "location": "/network/test-networks/#getting-morden-testnet-ether", 
            "text": "Because of decreased mining difficulty on the testnet, ether can easily\nmined using your CPU/GPU (see [mining]{role=\"ref\"}).", 
            "title": "Getting Morden testnet ether"
        }, 
        {
            "location": "/network/test-networks/#setting-up-a-local-private-testnet", 
            "text": "", 
            "title": "Setting up a local private testnet"
        }, 
        {
            "location": "/network/test-networks/#eth-c-client-custom-networks-eth", 
            "text": "It is possible to connect to or create a new network by using the\n--genesis and --config.  ``` {.sourceCode .Console}   eth --private \"customChain\" --config config.json --genesis genesis.json It is possible to use both \\--config and \\--genesis.\n\nIn that case, the genesis block description provided by \\--config will\nbe overwritten by the \\--genesis option.\n\n``` {.sourceCode .Console}\n--private //defines the name of the custom chain (optional).   ``` {.sourceCode .Console}\n--config   ::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\\ filename\\  contains a JSON description of the network:\n\n-   sealEngine (engine use to mine block)\n\n      \\ Ethash\\  is the Ethereum proof of work engine (used by the live\n      network).\n     \n      \\ NoProof\\  no proof of work is needed to mine a block.\n\n-   params (general network information like minGasLimit,\n    minimumDifficulty, blockReward, networkID)\n-   genesis (genesis block description)\n-   accounts (setup an original state that contains accounts/contracts)\n:::\n\nHere is a Config sample (used by the Olympic network):\n\n``` {.sourceCode .JSON}\n{\n     sealEngine :  Ethash ,\n     params : {\n         accountStartNonce :  0x00 ,\n         frontierCompatibilityModeLimit :  0xffffffff ,\n         maximumExtraDataSize :  0x0400 ,\n         tieBreakingGas : false,\n         minGasLimit :  125000 ,\n         gasLimitBoundDivisor :  0x0400 ,\n         minimumDifficulty :  0x020000 ,\n         difficultyBoundDivisor :  0x0800 ,\n         durationLimit :  0x08 ,\n         blockReward :  0x14D1120D7B160000 ,\n         registrar :  5e70c0bbcd5636e0f9f9316e9f8633feb64d4050 ,\n         networkID  :  0x0 \n    },\n     genesis : {\n         nonce :  0x000000000000002a ,\n         difficulty :  0x20000 ,\n         mixHash :  0x0000000000000000000000000000000000000000000000000000000000000000 ,\n         author :  0x0000000000000000000000000000000000000000 ,\n         timestamp :  0x00 ,\n         parentHash :  0x0000000000000000000000000000000000000000000000000000000000000000 ,\n         extraData :  0x ,\n         gasLimit :  0x2fefd8 \n    },\n     accounts : {\n         0000000000000000000000000000000000000001 : {  wei :  1 ,  precompiled : {  name :  ecrecover ,  linear : {  base : 3000,  word : 0 } } },\n         0000000000000000000000000000000000000002 : {  wei :  1 ,  precompiled : {  name :  sha256 ,  linear : {  base : 60,  word : 12 } } },\n         0000000000000000000000000000000000000003 : {  wei :  1 ,  precompiled : {  name :  ripemd160 ,  linear : {  base : 600,  word : 120 } } },\n         0000000000000000000000000000000000000004 : {  wei :  1 ,  precompiled : {  name :  identity ,  linear : {  base : 15,  word : 3 } } },\n         dbdbdb2cbd23b783741e8d7fcf51e459b497e4a6 : {  wei :  1606938044258990275541962092341162602522202993782792835301376  },\n         e6716f9544a56c530d868e4bfbacb172315bdead : {  wei :  1606938044258990275541962092341162602522202993782792835301376  },\n         b9c015918bdaba24b4ff057a92a3873d6eb201be : {  wei :  1606938044258990275541962092341162602522202993782792835301376  },\n         1a26338f0d905e295fccb71fa9ea849ffa12aaf4 : {  wei :  1606938044258990275541962092341162602522202993782792835301376  },\n         2ef47100e0787b915105fd5e3f4ff6752079d5cb : {  wei :  1606938044258990275541962092341162602522202993782792835301376  },\n         cd2a3d9f938e13cd947ec05abc7fe734df8dd826 : {  wei :  1606938044258990275541962092341162602522202993782792835301376  },\n         6c386a4b26f73c802f34673f7248bb118f97424a : {  wei :  1606938044258990275541962092341162602522202993782792835301376  },\n         e4157b34ea9615cfbde6b4fda419828124b70c78 : {  wei :  1606938044258990275541962092341162602522202993782792835301376  }\n    }\n}  ``` {.sourceCode .Console}\n--genesis   (optional if the config option is provided and contains the genesis description). ::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\\ filename\\  contains a JSON description of the genesis block:\n:::\n\nThe content is the same as the genesis field provided by the \\ config\\ \nparameter:\n\n``` {.sourceCode .JavaScript}\n{\n       nonce :  0x000000000000002a ,\n       difficulty :  0x20000 ,\n       mixHash :  0x0000000000000000000000000000000000000000000000000000000000000000 ,\n       author :  0x0000000000000000000000000000000000000000 ,\n       timestamp :  0x00 ,\n       parentHash :  0x0000000000000000000000000000000000000000000000000000000000000000 ,\n       extraData :  0x ,\n       gasLimit :  0x2fefd8 \n}", 
            "title": "eth (C++ client) {#custom-networks-eth}"
        }, 
        {
            "location": "/network/test-networks/#geth-go-client_1", 
            "text": "You either pre-generate or mine your own ether on a private testnet. It\nis a much more cost effective way of trying out Ethereum and you can\navoid having to mine or find Morden test ether.  The things that are required to specify in a private chain are:  :   -   Custom Genesis File\n    -   Custom Data Directory\n    -   Custom NetworkID\n    -   (Recommended) Disable Node Discovery", 
            "title": "geth (Go client)"
        }, 
        {
            "location": "/network/test-networks/#the-genesis-file", 
            "text": "The genesis block is the start of the blockchain - the first block,\nblock 0, and the only block that does not point to a predecessor block.\nThe protocol ensures that no other node will agree with your version of\nthe blockchain unless they have the same genesis block, so you can make\nas many private testnet blockchains as you\\'d like!  [CustomGenesis.json]{role=\"file\"}  ``` {.sourceCode .JSON}\n{\n    \"config\": { }, \"nonce\": \"0x0000000000000042\",     \"timestamp\": \"0x0\",\n    \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"extraData\": \"0x00\",     \"gasLimit\": \"0x8000000\",     \"difficulty\": \"0x400\",\n    \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"coinbase\": \"0x3333333333333333333333333333333333333333\",     \"alloc\": {     }\n} Save a file called [CustomGenesis.json]{role= file }. You will reference\nthis when starting your geth node using the following command:\n\n`geth init /path/to/CustomGenesis.json`\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\nBy default geth will use the same directory for network related files as\nfor the public mainnet. Thus you are advised to set a custom `--datadir`\nto keep the public network\\ s chaindata from bing reset.\n:::\n\n### Command line parameters for private network\n\nThere are some command line options (also called  flags ) that are\nnecessary in order to make sure that your network is private. We already\ncovered the genesis flag, but we need a few more. Note that all of the\ncommands below are to be used in the geth Ethereum client.\n\n`--nodiscover`\n\nUse this to make sure that your node is not discoverable by people who\ndo not manually add you. Otherwise, there is a chance that your node may\nbe inadvertently added to a stranger\\ s blockchain if they have the same\ngenesis file and network id.\n\n`--maxpeers 0`\n\nUse maxpeers 0 if you do not want anyone else connecting to your test\nchain. Alternatively, you can adjust this number if you know exactly how\nmany peers you want connecting to your node.\n\n`--rpc`\n\nThis will enable RPC interface on your node. This is generally enabled\nby default in Geth.\n\n`--rpcapi  db,eth,net,web3 `\n\nThis dictates what APIs that are allowed to be accessed over RPC. By\ndefault, Geth enables the web3 interface over RPC.\n\n**IMPORTANT: Please note that offering an API over the RPC/IPC interface\nwill give everyone access to the API who can access this interface (e.g.\ndapp\\ s). Be careful which API\\ s you enable. By default geth enables\nall API\\ s over the IPC interface and only the db,eth,net and web3\nAPI\\ s over the RPC interface.**\n\n`--rpcport  8080 `\n\nChange 8000 to any port that is open on your network. The default for\ngeth is 8080.\n\n`--rpccorsdomain  http://chriseth.github.io/browser-solidity/ `\n\nThis dictates what URLs can connect to your node in order to perform RPC\nclient tasks. Be very careful with this and type a specific URL rather\nthan the wildcard (\\*) which would allow any URL to connect to your RPC\ninstance.\n\n`--datadir  /home/TestChain1 `\n\nThis is the data directory that your private chain data will be stored\nin (under the [nubits]{role= file } . Choose a location that is separate\nfrom your public Ethereum chain folder.\n\n`--port  30303 `\n\nThis is the \\ network listening port\\ , which you will use to connect\nwith other peers manually.\n\n`--identity  TestnetMainNode `\n\nThis will set up an identity for your node so it can be identified more\neasily in a list of peers. Here is an example of how these identities\nshow up on the network.\n\n### Launching `geth`\n\nAfter you have created your custom genesis block JSON file and created a\ndirectory for your blockchain data, type the following command into your\nconsole that has access to geth:\n\n``` {.sourceCode .Console}\ngeth --identity  MyNodeName  --rpc --rpcport  8080  --rpccorsdomain  *  --datadir  C:\\chains\\TestChain1  --port  30303  --nodiscover --rpcapi  db,eth,net,web3  --networkid 1999 init /path/to/CustomGenesis.json  ::: {.note}\n::: {.admonition-title}\nNote\n:::  Please change the flags to match your custom settings.\n:::  This will initialize your genesis block. To interact with geth through\nthe console enter:  ``` {.sourceCode .Console}\ngeth --identity \"MyNodeName\" --rpc --rpcport \"8080\" --rpccorsdomain \"*\" --datadir \"C:\\chains\\TestChain1\" --port \"30303\" --nodiscover --rpcapi \"db,eth,net,web3\" --networkid 1999 console You will need to start your geth instance with your custom chain command\nevery time you want to access your custom chain. If you just type\n\\ geth\\  in your console, it will not remember all of the flags you have\nset.\n\nThe full list of methods available through the javascript console is\navailable on [the geth wiki on\ngithub](https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console)\n\nIf you already have a geth node running, you can attach another geth\ninstance to it using:\n\n``` {.sourceCode .Console}\ngeth attach  Now you\\'ll need to initialize a new account on the testnest, and set it\nas your etherbase (the address that will receive mining rewards).  In the javascript console type  ``` {.sourceCode .Console}\npersonal.newAccount(\"password\") ::: {.note}\n::: {.admonition-title}\nNote\n:::\n\nReplace with the password of your choice\n:::\n\nNow we\\ ll set it as the etherbase:\n\n``` {.sourceCode .Console}\nminer.setEtherbase(personal.listAccounts[0])  If successful, the console will print \\\"true\\\"  Finally, you are ready to start mining test ether:  ``` {.sourceCode .Console}\nminer.start() ### Pre-allocating ether to your account\n\nA difficulty of \\ 0x400\\  allows you to mine Ether very quickly on your\nprivate testnet chain. If you create your chain and start mining, you\nshould have hundreds of ether in a matter of minutes which is way more\nthan enough to test transactions on your network. If you would still\nlike to pre-allocate Ether to your account, you will need to:\n\n1.  Create a new Ethereum account after you create your private chain\n2.  Copy your new account address\n3.  Add the following command to your Custom\\_Genesis.json file:\n\n``` {.sourceCode .Javascript} alloc :\n{\n     your account address e.g. 0x1fb891f92eb557f4d688463d0d7c560552263b5a :\n    {  balance :  20000000000000000000  }\n}  ::: {.note}\n::: {.admonition-title}\nNote\n:::  Replace  0x1fb891f92eb557f4d688463d0d7c560552263b5a  with your account\naddress.\n:::  Save your genesis file and rerun your private chain command. Once geth\nis fully loaded, close it by .  We want to assign an address to the variable  primary  and check its\nbalance.  Run the command  geth account list  in your terminal to see what account\n# your new address was assigned.  ``` {.sourceCode .Console}   geth account list\nAccount #0: {d1ade25ccd3d550a7eb532ac759cac7be09c2719}\nAccount #1: {da65665fc30803cb1fb7e6d86691e20b1826dee0}\nAccount #2: {e470b1a7d2c9c5c6f03bbaa8fa20db6d404a0c32}\nAccount #3: {f4dd5c3794f1fd0cdc0327a83aa472609c806e99} Take note of which account \\# is the one that you pre-allocated ether\nto. Alternatively, you can launch the console with `geth console` (keep\nthe same parameters as when you launched `geth` first). Once the prompt\nappears, type\n\n``` {.sourceCode .Console}  eth.accounts   This will return the array of account addresses you possess.  ``` {.sourceCode .Console}   primary = eth.accounts[0] ::: {.note}\n::: {.admonition-title}\nNote\n:::\n\nReplace `0` with your account\\ s index. This console command should\nreturn your primary Ethereum address.\n:::\n\nType the following command:\n\n``` {.sourceCode .Console}  balance = web3.fromWei(eth.getBalance(primary),  ether );   This should return  7.5  indicating you have that much ether in your\naccount. The reason we had to put such a large number in the alloc\nsection of your genesis file is because the \\\"balance\\\" field takes a\nnumber in wei which is the smallest denomination of the Ethereum\ncurrency ether (see _Ether).   https://www.reddit.com/r/ethereum/comments/3kdnus/question_about_private_chain_mining_dont_upvote/", 
            "title": "The genesis file"
        }, 
        {
            "location": "/mining/", 
            "text": "Mining\n\n\nIntroduction\n\n\nThe word mining originates in the context of the gold analogy for crypto\ncurrencies. Gold or precious metals are scarce, so are digital tokens,\nand the only way to increase the total volume is through mining. This is\nappropriate to the extent that in Ethereum too, the only mode of\nissuance post launch is via mining. Unlike these examples however,\nmining is also the way to secure the network by creating, verifying,\npublishing and propagating blocks in the blockchain.\n\n\n\n\nMining ether = Securing the Network = Verifying Computation\n\n\n\n\nWhat is mining?\n\n\nEthereum, like all blockchain technologies, uses an incentive-driven\nmodel of security. Consensus is based on choosing the block with the\nhighest total difficulty. Miners produce blocks which the others check\nfor validity. Among other well-formedness criteria, a block is only\nvalid if it contains \nproof of work\n (PoW) of a given \ndifficulty\n. Note\nthat in the Ethereum Serenity milestone, this is likely going to be\nreplaced by a (see [proof of stake model \\\nPOS vs POW>]{role=\"ref\"} ).\n\n\nThe Ethereum blockchain is in many ways similar to the Bitcoin\nblockchain, although it does have some differences. The main difference\nbetween Ethereum and Bitcoin with regard to the blockchain architecture\nis that, unlike Bitcoin, Ethereum blocks contain a copy of both the\ntransaction list and the most recent state (the root hash of the merkle\npatricia trie encoding the state to be more precise). Aside from that,\ntwo other values, the block number and the difficulty, are also stored\nin the block.\n\n\nThe proof of work algorithm used is called\n\nEthash\n (a modified\nversion of \nthe Dagger-Hashimoto\nalgorithm\n) and\ninvolves finding a \nnonce\n input to the algorithm so that the result is\nbelow a certain difficulty threshold. The point in PoW algorithms is\nthat there is no better strategy to find such a nonce than enumerating\nthe possibilities, while verification of a solution is trivial and\ncheap. Since outputs have a uniform distribution (as they are the result\nof the application of a hash function), we can guarantee that, on\naverage, the time needed to find such a nonce depends on the difficulty\nthreshold. This makes it possible to control the time of finding a new\nblock just by manipulating the difficulty.\n\n\nAs dictated by the protocol, the difficulty dynamically adjusts in such\na way that on average one block is produced by the entire network every\n15 seconds. We say that the network produces a blockchain with a \n15\nsecond block time\n. This \\\"heartbeat\\\" basically punctuates the\nsynchronisation of system state and guarantees that maintaining a fork\n(to allow double spend) or rewriting history by malicious actors are\nimpossible unless the attacker possesses more than half of the network\nmining power (this is the so called \n51% attack\n).\n\n\nAny node participating in the network can be a miner and their expected\nrevenue from mining will be directly proportional to their (relative)\nmining power or \nhashrate\n, i.e., the number of nonces tried per second\nnormalised by the total hashrate of the network.\n\n\nEthash PoW is \nmemory hard\n, making it \nASIC resistant\n. Memory hardness\nis achieved with a proof of work algorithm that requires choosing\nsubsets of a fixed resource dependent on the nonce and block header.\nThis resource (a few gigabyte size data) is called a \nDAG\n. The\n\nDAG\n is totally\ndifferent every 30000 blocks, a 125-hour window called \nepoch\n (roughly\n5.2 days) and takes a while to generate. Since the DAG only depends on\nblock height, it can be pregenerated but if its not, the client needs to\nwait until the end of this process to produce a block. If clients do not\npregenerate and cache DAGs ahead of time the network may experience\nmassive block delay on each epoch transition. Note that the DAG does not\nneed to be generated for verifying the PoW essentially allowing for\nverification with both low CPU and small memory.\n\n\nAs a special case, when you start up your node from scratch, mining will\nonly start once the DAG is built for the current epoch.\n\n\nMining rewards\n\n\nThe successful PoW miner of the winning block receives:\n\n\n\n\na \nstatic block reward\n for the \\'winning\\' block, consisting of\n    exactly 5.0 Ether\n\n\ncost of the gas expended within the block -- an amount of ether that\n    depends on the current gas price\n\n\nan extra reward for including uncles as part of the block, in the\n    form of an extra 1/32 per uncle included\n\n\n\n\nAll the gas consumed by the execution of all the transactions in the\nblock submitted by the winning miner is paid by the senders of each\ntransaction. The gas cost incurred is credited to the miner\\'s account\nas part of the consensus protocol. Over time, it is expected these will\ndwarf the static block reward.\n\n\nUncles\n are stale blocks i.e. with parents that are ancestors (max 6\nblocks back) of the including block. Valid uncles are rewarded in order\nto neutralise the effect of network lag on the dispersion of mining\nrewards, thereby increasing security (this is called the GHOST\nprotocol). Uncles included in a block formed by the successful PoW miner\nreceive 7/8 of the static block reward (=4.375 ether). A maximum of 2\nuncles are allowed per block.\n\n\n\n\n\n\nUncles ELI5 on\n    reddit\n\n\nForum thread explaining\n    uncles\n\n\n\n\n\n\nMining success depends on the set block difficulty. Block difficulty\ndynamically adjusts each block in order to regulate the network hashing\npower to produce a 12 second blocktime. Your chances of finding a block\ntherefore follows from your hashrate relative to difficulty.\n\n\nEthash DAG\n\n\nEthash uses a \nDAG\n (directed acyclic graph) for the proof of work\nalgorithm, this is generated for each \nepoch\n, i.e., every 30000 blocks\n(125 hours, ca. 5.2 days). The DAG takes a long time to generate. If\nclients only generate it on demand, you may see a long wait at each\nepoch transition before the first block of the new epoch is found.\nHowever, the DAG only depends on the block number, so it can and should\nbe calculated in advance to avoid long wait times at each epoch\ntransition. Both \ngeth\n and \nethminer\n implement automatic DAG\ngeneration and maintains two DAGs at a time for smooth epoch\ntransitions. Automatic DAG generation is turned on and off when mining\nis controlled from the console. It is also turned on by default if\n\ngeth\n is launched with the \n--mine\n option. Note that clients share a\nDAG resource, so if you are running multiple instances of any client,\nmake sure automatic dag generation is switched off in all but one\ninstance.\n\n\nTo generate the DAG for an arbitrary epoch:\n\n\n``` {.sourceCode .bash}\ngeth makedag \n \n\n\nFor instance `geth makedag 360000 ~/.ethash`. Note that ethash uses\n`~/.ethash` (Mac/Linux) or `~/AppData/Ethash` (Windows) for the DAG so\nthat it can shared between different client implementations as well as\nmultiple running instances.\n\n## The algorithm-\n\nOur algorithm, [Ethash](https://github.com/ethereum/wiki/wiki/Ethash)\n(previously known as Dagger-Hashimoto), is based around the provision of\na large, transient, randomly generated dataset which forms a DAG (the\nDagger-part), and attempting to solve a particular constraint on it,\npartly determined through a block\\\ns header-hash.\n\nIt is designed to hash a fast verifiability time within a slow CPU-only\nenvironment, yet provide vast speed-ups for mining when provided with a\nlarge amount of memory with high-bandwidth. The large memory\nrequirements mean that large-scale miners get comparatively little\nsuper-linear benefit. The high bandwidth requirement means that a\nspeed-up from piling on many super-fast processing units sharing the\nsame memory gives little benefit over a single unit. This is important\nin that pool mining have no benefit for nodes doing verification, thus\ndiscourageing centralisation.\n\nCommunication between the external mining application and the Ethereum\ndaemon for work provision and submission happens through the JSON-RPC\nAPI. Two RPC functions are provided; `eth_getWork` and `eth_submitWork`.\n\nThese are formally documented on the [JSON-RPC\nAPI](https://github.com/ethereum/wiki/wiki/JSON-RPC) wiki article under\n[miner](https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console#miner).\n\nIn order to mine you need a fully synced Ethereum client that is enabled\nfor mining and at least one ethereum account. This account is used to\nsend the mining rewards to and is often referred to as *coinbase* or\n*etherbase*. Visit the \\\n[creating\\_an\\_account]{role=\nref\n}\\\n section\nof this guide to learn how to create an account.\n\n::: {.warning}\n::: {.admonition-title}\nWarning\n:::\n\nEnsure your blockchain is fully synchronised with the main chain before\nstarting to mine, otherwise you will not be mining on the main chain.\n:::\n\n## CPU mining\n\nYou can use your computer\\\ns central processing unit (CPU) to mine\nether. This is no longer profitable, since GPU miners are roughly two\norders of magnitude more efficient. However, you can use CPU mining to\nmine on the Morden testnet or a private chain for the purposes of\ncreating the ether you need to test contracts and transactions without\nspending your real ether on the live network.\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\nThe testnet ether has no value other than using it for testing purposes\n(see [test-networks]{role=\nref\n}).\n:::\n\n### Using geth\n\nWhen you start up your ethereum node with `geth` it is not mining by\ndefault. To start it in CPU mining mode, you use the `--mine` [command\nline\noption](https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options).\nThe `-minerthreads` parameter can be used to set the number parallel\nmining threads (defaulting to the total number of processor cores).\n\n`geth --mine --minerthreads=4`\n\nYou can also start and stop CPU mining at runtime using the\n[console](https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console#adminminerstart).\n`miner.start` takes an optional parameter for the number of miner\nthreads.\n\n``` {.sourceCode .Javascript}\n\n miner.start(8)\ntrue\n\n miner.stop()\ntrue\n\n\n\nNote that mining for real ether only makes sense if you are in sync with\nthe network (since you mine on top of the consensus block). Therefore\nthe eth blockchain downloader/synchroniser will delay mining until\nsyncing is complete, and after that mining automatically starts unless\nyou cancel your intention with \nminer.stop()\n.\n\n\nIn order to earn ether you must have your \netherbase\n (or\n\ncoinbase\n) address set. This etherbase defaults to your primary\naccount. If you don\\'t have an etherbase address, then \ngeth --mine\n\nwill not start up.\n\n\nYou can set your etherbase on the command line:\n\n\n``` {.sourceCode .bash}\ngeth --etherbase 1 --mine  2\n geth.log // 1 is index: second account by creation order OR\ngeth --etherbase '0xa4d8e9cae4d04b093aac82e6cd355b6b963fb7ff' --mine 2\n geth.log\n\nYou can reset your etherbase on the console too:\n\n``` {.sourceCode .javascript}\nminer.setEtherbase(eth.accounts[2])\n\n\n\nNote that your etherbase does not need to be an address of a local\naccount, just an existing one.\n\n\nThere is an option \nto add extra\nData\n\n(32 bytes only) to your mined blocks. By convention this is interpreted\nas a unicode string, so you can set your short vanity tag.\n\n\n``` {.sourceCode .javascript}\nminer.setExtra(\"\u039eTH\u039e\u042fSPH\u039e\u042f\u039e\")\n...\ndebug.printBlock(131805)\nBLOCK(be465b020fdbedc4063756f0912b5a89bbb4735bd1d1df84363e05ade0195cb1): Size: 531.00 B TD: 643485290485 {\nNoNonce: ee48752c3a0bfe3d85339451a5f3f411c21c8170353e450985e1faab0a9ac4cc\nHeader:\n[\n...\n        Coinbase:           a4d8e9cae4d04b093aac82e6cd355b6b963fb7ff\n        Number:             131805\n        Extra:              \u039eTH\u039e\u042fSPH\u039e\u042f\u039e\n...\n}\n\nYou can check your hashrate with\n[miner.hashrate](https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console#adminminerhashrate),\nthe result is in H/s (Hash operations per second).\n\n``` {.sourceCode .javascript}\n\n miner.hashrate\n712000\n\n\n\nAfter you successfully mined some blocks, you can check the ether\nbalance of your etherbase account. Now assuming your etherbase is a\nlocal account:\n\n\n``` {.sourceCode .javascript}\n\n\n\n\neth.getBalance(eth.coinbase).toNumber();\n'34698870000000'\n\nIn order to spend your earnings on gas to transact, you will need to\nhave this account unlocked.\n\n``` {.sourceCode .javascript}\n\n personal.unlockAccount(eth.coinbase)\nPassword\ntrue\n\n\n\n\n\nYou can check which blocks are mined by a particular miner (address)\nwith the following code snippet on the console:\n\n\n``` {.sourceCode .javascript}\nfunction minedBlocks(lastn, addr) {\n  addrs = [];\n  if (!addr) {\n    addr = eth.coinbase\n  }\n  limit = eth.blockNumber - lastn\n  for (i = eth.blockNumber; i \n= limit; i--) {\n    if (eth.getBlock(i).miner == addr) {\n      addrs.push(i)\n    }\n  }\n  return addrs\n}\n// scans the last 1000 blocks and returns the blocknumbers of blocks mined by your coinbase\n// (more precisely blocks the mining reward for which is sent to your coinbase).\nminedBlocks(1000, eth.coinbase);\n//[352708, 352655, 352559]\n\nNote that it will happen often that you find a block yet it never makes\nit to the canonical chain. This means when you locally include your\nmined block, the current state will show the mining reward credited to\nyour account, however, after a while, the better chain is discovered and\nwe switch to a chain in which your block is not included and therefore\nno mining reward is credited. Therefore it is quite possible that as a\nminer monitoring their coinbase balance will find that it may fluctuate\nquite a bit.\n\n## GPU mining\n\n### Hardware\n\nThe algorithm is memory hard and in order to fit the DAG into memory, it\nneeds 1-2GB of RAM on each GPU. If you get\n`Error GPU mining. GPU memory fragmentation?` you do not have enough\nmemory. The GPU miner is implemented in OpenCL, so AMD GPUs will be\n\\\nfaster\\\n than same-category NVIDIA GPUs. ASICs and FPGAs are\nrelatively inefficient and therefore discouraged. To get openCL for your\nchipset and platform, try:\n\n-   [AMD SDK\n    openCL](http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk)\n-   [NVIDIA CUDA openCL](https://developer.nvidia.com/cuda-downloads)\n\n### Ubuntu Linux set-up\n\nFor this quick guide, you\\\nll need Ubuntu 14.04 or 15.04 and the fglrx\ngraphics drivers. You can use NVidia drivers and other platforms, too,\nbut you\\\nll have to find your own way to getting a working OpenCL\ninstall with them, such as [Genoil\\\ns ethminer\nfork](http://cryptomining-blog.com/tag/ethminer/).\n\nIf you\\\nre on 15.04, Go to \\\nSoftware and Updates \\\n Additional\nDrivers\\\n and set it to \\\nUsing video drivers for the AMD graphics\naccelerator from fglrx\\\n.\n\nIf you\\\nre on 14.04, go to \\\nSoftware and Updates \\\n Additional\nDrivers\\\n and set it to \\\nUsing video drivers for the AMD graphics\naccelerator from fglrx\\\n. Unfortunately, for some of you this will not\nwork due to a known bug in Ubuntu 14.04.02 preventing you from switching\nto the proprietary graphics drivers required to GPU mine.\n\nSo, if you encounter this bug, and before you do anything else, go to\n\\\nSoftware and updates \\\n Updates\\\n and select \\\nPre-released updates\ntrusty proposed\\\n. Then, go back to \\\nSoftware and Updates \\\n Additional\nDrivers\\\n and set it to \\\nUsing video drivers for the AMD graphics\naccelerator from fglrx\\\n). After rebooting, it\\\ns well worth having a\ncheck that the drivers have now indeed been installed correctly (For\nexample by going to \\\nAdditional Drivers\\\n again).\n\nWhatever you do, if you are on 14.04.02 do not alter the drivers or the\ndrivers configuration once set. For example, the usage of aticonfig\n\\--initial (especially with the -f, \\--force option) can \\\nbreak\\\n your\nsetup. If you accidentally alter their configuration, you\\\nll need to\nde-install the drivers, reboot, reinstall the drivers and reboot.\n\n### Mac set-up\n\n``` {.sourceCode .bash}\nwget http://developer.download.nvidia.com/compute/cuda/7_0/Prod/local_installers/cuda_7.0.29_mac.pkg\nsudo installer -pkg ~/Desktop/cuda_7.0.29_mac.pkg -target /\nbrew update\nbrew tap ethereum/ethereum\nbrew reinstall cpp-ethereum --with-gpu-mining --devel --headless --build-from-source\n\n\n\nYou check your cooling status:\n\n\n``` {.sourceCode .bash}\naticonfig --adapter=0 --od-gettemperature\n\n### Windows set-up\n\n[Download the latest Eth++\ninstallation](https://github.com/ethereum-mining/ethminer/releases) and\nchoose ethminer at the \\\nChoose Components\\\n screen of the installation\nscreen.\n\n![image](img/eth_miner_setup.png)\n\n### Using ethminer with geth\n\n``` {.sourceCode .bash}\ngeth account new // Set-up ethereum account if you do not have one\ngeth --rpc --rpccorsdomain localhost 2\n geth.log \n\nethminer -G  // -G for GPU, -M for benchmark\ntail -f geth.log\n\n\n\nethminer\n communicates with geth on port 8545 (the default RPC port in\ngeth). You can change this by giving the \n--rpcport\n option to \ngeth\n.\nEthminer will find geth on any port. Note that you need to set the CORS\nheader with \n--rpccorsdomain localhost\n. You can also set port on\n\nethminer\n with \n-F http://127.0.0.1:3301\n. Setting the ports is\nnecessary if you want several instances mining on the same computer,\nalthough this is somewhat pointless. If you are testing on a private\nchain, we recommend you use CPU mining instead.\n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\nYou do \nnot\n need to give \ngeth\n the \n--mine\n option or start the\nminer in the console unless you want to do CPU mining on TOP of GPU\nmining.\n:::\n\n\nIf the default for \nethminer\n does not work try to specify the OpenCL\ndevice with: \n--opencl-device X\n where X is {0, 1, 2,...}. When running\n\nethminer\n with \n-M\n (benchmark), you should see something like:\n\n\n``` {.sourceCode .bash}\nBenchmarking on platform: { \"platform\": \"NVIDIA CUDA\", \"device\": \"GeForce GTX 750 Ti\", \"version\": \"OpenCL 1.1 CUDA\" }\n\n\nBenchmarking on platform: { \"platform\": \"Apple\", \"device\": \"Intel(R) Xeon(R) CPU E5-1620 v2 @ 3.70GHz\", \"version\": \"OpenCL 1.2 \" }\n\nTo debug `geth`:\n\n``` {.sourceCode .bash}\ngeth  --rpccorsdomain \nlocalhost\n --verbosity 6 2\n geth.log\n\n\n\nTo debug the miner:\n\n\n``` {.sourceCode .bash}\nmake -DCMAKE_BUILD_TYPE=Debug -DETHASHCL=1 -DGUI=0\ngdb --args ethminer -G -M\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\nhashrate info is not available in `geth` when GPU mining.\n:::\n\nCheck your hashrate with `ethminer`, `miner.hashrate` will always report\n0.\n\n### Using ethminer with eth\n\n#### Mining on a single GPU\n\nIn order to mine on a single GPU all that needs to be done is to run eth\nwith the following arguments:\n\n``` {.sourceCode .bash}\neth -v 1 -a 0xcadb3223d4eebcaa7b40ec5722967ced01cfc8f2 --client-name \nOPTIONALNAMEHERE\n -x 50 -m on -G\n\n\n\n\n\n-v 1\n Set verbosity to 1. Let\\'s not get spammed by messages.\n\n\n-a YOURWALLETADDRESS\n Set the coinbase, where the mining rewards\n    will go to. The above address is just an example. This argument is\n    really important, make sure to not make a mistake in your wallet\n    address or you will receive no ether payout.\n\n\n--client-name \"OPTIONAL\"\n Set an optional client name to identify\n    you on the network\n\n\n-x 50\n Request a high amount of peers. Helps with finding peers in\n    the beginning.\n\n\n-m on\n Actually launch with mining on.\n\n\n-G\n set GPU mining on.\n\n\n\n\nWhile the client is running you can interact with it using either geth\nattach` or\n[ethconsole](\nhttps://github.com/ethereum/ethereum-console\n).\n\n\nMining on a multiple GPUs\n\n\nMining with multiple GPUs and eth is very similar to mining with geth\nand multiple GPUs. Ensure that an eth node is running with your coinbase\naddress properly set:\n\n\n``` {.sourceCode .bash}\neth -v 1 -a 0xcadb3223d4eebcaa7b40ec5722967ced01cfc8f2 --client-name \"OPTIONALNAMEHERE\" -x 50 -j\n\nNotice that we also added the -j argument so that the client can have\nthe JSON-RPC server enabled to communicate with the ethminer instances.\nAdditionally we removed the mining related arguments since ethminer will\nnow do the mining for us. For each of your GPUs execute a different\nethminer instance:\n\n``` {.sourceCode .bash}\nethminer --no-precompute -G --opencl-device X\n\n\n\nWhere X is the index number corresponding to the openCL device you want\nthe ethminer to use {0, 1, 2,...}. In order to easily get a list of\nOpenCL devices you can execute \nethminer --list-devices\n which will\nprovide a list of all devices OpenCL can detect, with also some\nadditional information per device.\n\n\nBelow is a sample output:\n\n\n``` {.sourceCode .console}\n[0] GeForce GTX 770\n    CL_DEVICE_TYPE: GPU\n    CL_DEVICE_GLOBAL_MEM_SIZE: 4286345216\n    CL_DEVICE_MAX_MEM_ALLOC_SIZE: 1071586304\n    CL_DEVICE_MAX_WORK_GROUP_SIZE: 1024\n\nFinally the `--no-precompute` argument requests that the ethminers\ndon\\\nt create the DAG of the next epoch ahead of time. Although this is\nnot recommended since you\\\nll have a mining interruption every time when\nthere\\\ns an epoch transition.\n\n#### Benchmarking\n\nMining power tends to scale with memory bandwidth. Our implementation is\nwritten in OpenCL, which is typically supported better by AMD GPUs over\nNVidia. Empirical evidence confirms that AMD GPUs offer a better mining\nperformance in terms of price than their NVidia counterparts.\n\nTo benchmark a single-device setup you can use ethminer in benchmarking\nmode through the -M option:\n\n``` {.sourceCode .bash}\nethminer -G -M\n\n\n\nIf you have many devices and you\\'ll like to benchmark each\nindividually, you can use the --opencl-device option similarly to the\nprevious section:\n\n\n{.sourceCode .bash}\nethminer -G -M --opencl-device X\n\n\nUse ethminer \n--list-devices\n to list possible numbers to substitute for\nthe X {0, 1, 2,...}.\n\n\nTo start mining on Windows, first \ndownload the geth windows\nbinary\n.\n\n\n\n\nUnzip Geth (right-click and select unpack) and launch Command\n    Prompt. Use cd to navigate to the location of the Geth data folder.\n    (e.g. \ncd /\n to go to the \nC:\n drive)\n\n\nStart geth by typing \ngeth --rpc\n.\n\n\n\n\nAs soon as you enter this, the Ethereum blockchain will start\ndownloading. Sometimes your firewall may block the synchronisation\nprocess (it will prompt you when doing so). If this is the case, click\n\\\"Allow access\\\".\n\n\n\n\nFirst \ndownload and install\n    ethminer\n,\n    the C++ mining software (your firewall or Windows itself may act up,\n    allow access)\n\n\nOpen up another Command Prompt (leave the first one running!),\n    change directory by typing \ncd /Program\\ Files/Ethereum(++)/release\n\n\nNow make sure geth has finished syncing the blockchain. If it is not\n    syncing any longer, you can start the mining process by typing\n    \nethminer -G\n at the command prompt\n\n\n\n\nAt this point some problems may appear. If you get an error, you can\nabort the miner by pressing \nCtrl+C\n. If the error says \\\"Insufficient\nMemory\\\", your GPU does not have enough memory to mine ether.\n\n\nPool mining-\n\n\nMining pools are cooperatives that aim to smooth out expected revenue by\npooling the mining power of participating miners. In return, they\nusually charge you 0-5% of your mining rewards. The mining pool submits\nblocks with proof of work from a central account and redistributes the\nreward to participants in proportion to their contributed mining power.\n\n\n::: {.warning}\n::: {.admonition-title}\nWarning\n:::\n\n\nMost mining pools involve third party, central components which means\nthey are not trustless. In other words, pool operators can run away with\nyour earnings. Act with caution. There are a number of trustless,\ndecentralised pools with open source codebase.\n:::\n\n\n::: {.warning}\n::: {.admonition-title}\nWarning\n:::\n\n\nMining pools only outsource proof of work calculation, they do not\nvalidate blocks or run the VM to check state transitions brought about\nby executing the transactions. This effectively make pools behave like\nsingle nodes in terms of security, so their growth poses a\ncentralisation risk of a \n51%\nattack\n. Make\nsure you follow the network capacity distribution and do not allow pools\nto grow too large.\n:::\n\n\nMining pools\n\n\n\n\ncoinotron\n\n\nnanopool\n\n\nethpool\n -\n    Predictable solo mining, unconventional payout scheme, affiliated\n    with \netherchain\\.org\n.\n\n\nsupernova\n\n\ncoinmine.pl\n\n\neth.pp.ua\n\n\ntalkether\n - Unconventional payout scheme,\n    partially decentralized\n\n\nweipool\n\n\nethereumpool\n\n\npooleum\n\n\nalphapool\n\n\ncryptopool\n\n\nunitedminers\n\n\n2miners\n\n\ndwarfpool\n - Try to avoid this (currently\n    over 50% of the network)\n\n\nlaintimes\n - Discontinued\n\n\n\n\nMining resources----\n\n\n\n\nTop miners of last 24h on\n    etherchain\n\n\npool hashrate distribution for august\n    2015\n\n\nUnmaintained list of pools on\n    Forum\n\n\nMining profitability calculator on\n    cryptocompare\n\n\nMining profitability calculator on\n    cryptowizzard\n\n\nMining profitability calculator on\n    etherscan\n\n\nMining profitability calculator on In The\n    Ether\n\n\nMining difficulty chart on\n    etherscan\n\n\n\n\nPOS vs POW {#POS vs POW}\n\n\n\n\nhttps://www.reddit.com/r/ethereum/comments/38db1z/eli5_the_difference_between_pos_and_pow/\n\n\nhttps://blog.ethereum.org/2014/11/25/proof-stake-learned-love-weak-subjectivity/\n\n\nhttps://www.reddit.com/r/ethereum/comments/42o8oy/can_someone_explain_the_switch_to_pos_how_and_when/", 
            "title": "\u6316\u77ff"
        }, 
        {
            "location": "/mining/#mining", 
            "text": "", 
            "title": "Mining"
        }, 
        {
            "location": "/mining/#introduction", 
            "text": "The word mining originates in the context of the gold analogy for crypto\ncurrencies. Gold or precious metals are scarce, so are digital tokens,\nand the only way to increase the total volume is through mining. This is\nappropriate to the extent that in Ethereum too, the only mode of\nissuance post launch is via mining. Unlike these examples however,\nmining is also the way to secure the network by creating, verifying,\npublishing and propagating blocks in the blockchain.   Mining ether = Securing the Network = Verifying Computation", 
            "title": "Introduction"
        }, 
        {
            "location": "/mining/#what-is-mining", 
            "text": "Ethereum, like all blockchain technologies, uses an incentive-driven\nmodel of security. Consensus is based on choosing the block with the\nhighest total difficulty. Miners produce blocks which the others check\nfor validity. Among other well-formedness criteria, a block is only\nvalid if it contains  proof of work  (PoW) of a given  difficulty . Note\nthat in the Ethereum Serenity milestone, this is likely going to be\nreplaced by a (see [proof of stake model \\ POS vs POW>]{role=\"ref\"} ).  The Ethereum blockchain is in many ways similar to the Bitcoin\nblockchain, although it does have some differences. The main difference\nbetween Ethereum and Bitcoin with regard to the blockchain architecture\nis that, unlike Bitcoin, Ethereum blocks contain a copy of both the\ntransaction list and the most recent state (the root hash of the merkle\npatricia trie encoding the state to be more precise). Aside from that,\ntwo other values, the block number and the difficulty, are also stored\nin the block.  The proof of work algorithm used is called Ethash  (a modified\nversion of  the Dagger-Hashimoto\nalgorithm ) and\ninvolves finding a  nonce  input to the algorithm so that the result is\nbelow a certain difficulty threshold. The point in PoW algorithms is\nthat there is no better strategy to find such a nonce than enumerating\nthe possibilities, while verification of a solution is trivial and\ncheap. Since outputs have a uniform distribution (as they are the result\nof the application of a hash function), we can guarantee that, on\naverage, the time needed to find such a nonce depends on the difficulty\nthreshold. This makes it possible to control the time of finding a new\nblock just by manipulating the difficulty.  As dictated by the protocol, the difficulty dynamically adjusts in such\na way that on average one block is produced by the entire network every\n15 seconds. We say that the network produces a blockchain with a  15\nsecond block time . This \\\"heartbeat\\\" basically punctuates the\nsynchronisation of system state and guarantees that maintaining a fork\n(to allow double spend) or rewriting history by malicious actors are\nimpossible unless the attacker possesses more than half of the network\nmining power (this is the so called  51% attack ).  Any node participating in the network can be a miner and their expected\nrevenue from mining will be directly proportional to their (relative)\nmining power or  hashrate , i.e., the number of nonces tried per second\nnormalised by the total hashrate of the network.  Ethash PoW is  memory hard , making it  ASIC resistant . Memory hardness\nis achieved with a proof of work algorithm that requires choosing\nsubsets of a fixed resource dependent on the nonce and block header.\nThis resource (a few gigabyte size data) is called a  DAG . The DAG  is totally\ndifferent every 30000 blocks, a 125-hour window called  epoch  (roughly\n5.2 days) and takes a while to generate. Since the DAG only depends on\nblock height, it can be pregenerated but if its not, the client needs to\nwait until the end of this process to produce a block. If clients do not\npregenerate and cache DAGs ahead of time the network may experience\nmassive block delay on each epoch transition. Note that the DAG does not\nneed to be generated for verifying the PoW essentially allowing for\nverification with both low CPU and small memory.  As a special case, when you start up your node from scratch, mining will\nonly start once the DAG is built for the current epoch.", 
            "title": "What is mining?"
        }, 
        {
            "location": "/mining/#mining-rewards", 
            "text": "The successful PoW miner of the winning block receives:   a  static block reward  for the \\'winning\\' block, consisting of\n    exactly 5.0 Ether  cost of the gas expended within the block -- an amount of ether that\n    depends on the current gas price  an extra reward for including uncles as part of the block, in the\n    form of an extra 1/32 per uncle included   All the gas consumed by the execution of all the transactions in the\nblock submitted by the winning miner is paid by the senders of each\ntransaction. The gas cost incurred is credited to the miner\\'s account\nas part of the consensus protocol. Over time, it is expected these will\ndwarf the static block reward.  Uncles  are stale blocks i.e. with parents that are ancestors (max 6\nblocks back) of the including block. Valid uncles are rewarded in order\nto neutralise the effect of network lag on the dispersion of mining\nrewards, thereby increasing security (this is called the GHOST\nprotocol). Uncles included in a block formed by the successful PoW miner\nreceive 7/8 of the static block reward (=4.375 ether). A maximum of 2\nuncles are allowed per block.    Uncles ELI5 on\n    reddit  Forum thread explaining\n    uncles    Mining success depends on the set block difficulty. Block difficulty\ndynamically adjusts each block in order to regulate the network hashing\npower to produce a 12 second blocktime. Your chances of finding a block\ntherefore follows from your hashrate relative to difficulty.", 
            "title": "Mining rewards"
        }, 
        {
            "location": "/mining/#ethash-dag", 
            "text": "Ethash uses a  DAG  (directed acyclic graph) for the proof of work\nalgorithm, this is generated for each  epoch , i.e., every 30000 blocks\n(125 hours, ca. 5.2 days). The DAG takes a long time to generate. If\nclients only generate it on demand, you may see a long wait at each\nepoch transition before the first block of the new epoch is found.\nHowever, the DAG only depends on the block number, so it can and should\nbe calculated in advance to avoid long wait times at each epoch\ntransition. Both  geth  and  ethminer  implement automatic DAG\ngeneration and maintains two DAGs at a time for smooth epoch\ntransitions. Automatic DAG generation is turned on and off when mining\nis controlled from the console. It is also turned on by default if geth  is launched with the  --mine  option. Note that clients share a\nDAG resource, so if you are running multiple instances of any client,\nmake sure automatic dag generation is switched off in all but one\ninstance.  To generate the DAG for an arbitrary epoch:  ``` {.sourceCode .bash}\ngeth makedag     For instance `geth makedag 360000 ~/.ethash`. Note that ethash uses\n`~/.ethash` (Mac/Linux) or `~/AppData/Ethash` (Windows) for the DAG so\nthat it can shared between different client implementations as well as\nmultiple running instances.\n\n## The algorithm-\n\nOur algorithm, [Ethash](https://github.com/ethereum/wiki/wiki/Ethash)\n(previously known as Dagger-Hashimoto), is based around the provision of\na large, transient, randomly generated dataset which forms a DAG (the\nDagger-part), and attempting to solve a particular constraint on it,\npartly determined through a block\\ s header-hash.\n\nIt is designed to hash a fast verifiability time within a slow CPU-only\nenvironment, yet provide vast speed-ups for mining when provided with a\nlarge amount of memory with high-bandwidth. The large memory\nrequirements mean that large-scale miners get comparatively little\nsuper-linear benefit. The high bandwidth requirement means that a\nspeed-up from piling on many super-fast processing units sharing the\nsame memory gives little benefit over a single unit. This is important\nin that pool mining have no benefit for nodes doing verification, thus\ndiscourageing centralisation.\n\nCommunication between the external mining application and the Ethereum\ndaemon for work provision and submission happens through the JSON-RPC\nAPI. Two RPC functions are provided; `eth_getWork` and `eth_submitWork`.\n\nThese are formally documented on the [JSON-RPC\nAPI](https://github.com/ethereum/wiki/wiki/JSON-RPC) wiki article under\n[miner](https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console#miner).\n\nIn order to mine you need a fully synced Ethereum client that is enabled\nfor mining and at least one ethereum account. This account is used to\nsend the mining rewards to and is often referred to as *coinbase* or\n*etherbase*. Visit the \\ [creating\\_an\\_account]{role= ref }\\  section\nof this guide to learn how to create an account.\n\n::: {.warning}\n::: {.admonition-title}\nWarning\n:::\n\nEnsure your blockchain is fully synchronised with the main chain before\nstarting to mine, otherwise you will not be mining on the main chain.\n:::\n\n## CPU mining\n\nYou can use your computer\\ s central processing unit (CPU) to mine\nether. This is no longer profitable, since GPU miners are roughly two\norders of magnitude more efficient. However, you can use CPU mining to\nmine on the Morden testnet or a private chain for the purposes of\ncreating the ether you need to test contracts and transactions without\nspending your real ether on the live network.\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\nThe testnet ether has no value other than using it for testing purposes\n(see [test-networks]{role= ref }).\n:::\n\n### Using geth\n\nWhen you start up your ethereum node with `geth` it is not mining by\ndefault. To start it in CPU mining mode, you use the `--mine` [command\nline\noption](https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options).\nThe `-minerthreads` parameter can be used to set the number parallel\nmining threads (defaulting to the total number of processor cores).\n\n`geth --mine --minerthreads=4`\n\nYou can also start and stop CPU mining at runtime using the\n[console](https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console#adminminerstart).\n`miner.start` takes an optional parameter for the number of miner\nthreads.\n\n``` {.sourceCode .Javascript}  miner.start(8)\ntrue  miner.stop()\ntrue  Note that mining for real ether only makes sense if you are in sync with\nthe network (since you mine on top of the consensus block). Therefore\nthe eth blockchain downloader/synchroniser will delay mining until\nsyncing is complete, and after that mining automatically starts unless\nyou cancel your intention with  miner.stop() .  In order to earn ether you must have your  etherbase  (or coinbase ) address set. This etherbase defaults to your primary\naccount. If you don\\'t have an etherbase address, then  geth --mine \nwill not start up.  You can set your etherbase on the command line:  ``` {.sourceCode .bash}\ngeth --etherbase 1 --mine  2  geth.log // 1 is index: second account by creation order OR\ngeth --etherbase '0xa4d8e9cae4d04b093aac82e6cd355b6b963fb7ff' --mine 2  geth.log You can reset your etherbase on the console too:\n\n``` {.sourceCode .javascript}\nminer.setEtherbase(eth.accounts[2])  Note that your etherbase does not need to be an address of a local\naccount, just an existing one.  There is an option  to add extra\nData \n(32 bytes only) to your mined blocks. By convention this is interpreted\nas a unicode string, so you can set your short vanity tag.  ``` {.sourceCode .javascript}\nminer.setExtra(\"\u039eTH\u039e\u042fSPH\u039e\u042f\u039e\")\n...\ndebug.printBlock(131805)\nBLOCK(be465b020fdbedc4063756f0912b5a89bbb4735bd1d1df84363e05ade0195cb1): Size: 531.00 B TD: 643485290485 {\nNoNonce: ee48752c3a0bfe3d85339451a5f3f411c21c8170353e450985e1faab0a9ac4cc\nHeader:\n[\n...\n        Coinbase:           a4d8e9cae4d04b093aac82e6cd355b6b963fb7ff\n        Number:             131805\n        Extra:              \u039eTH\u039e\u042fSPH\u039e\u042f\u039e\n...\n} You can check your hashrate with\n[miner.hashrate](https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console#adminminerhashrate),\nthe result is in H/s (Hash operations per second).\n\n``` {.sourceCode .javascript}  miner.hashrate\n712000  After you successfully mined some blocks, you can check the ether\nbalance of your etherbase account. Now assuming your etherbase is a\nlocal account:  ``` {.sourceCode .javascript}   eth.getBalance(eth.coinbase).toNumber();\n'34698870000000' In order to spend your earnings on gas to transact, you will need to\nhave this account unlocked.\n\n``` {.sourceCode .javascript}  personal.unlockAccount(eth.coinbase)\nPassword\ntrue   You can check which blocks are mined by a particular miner (address)\nwith the following code snippet on the console:  ``` {.sourceCode .javascript}\nfunction minedBlocks(lastn, addr) {\n  addrs = [];\n  if (!addr) {\n    addr = eth.coinbase\n  }\n  limit = eth.blockNumber - lastn\n  for (i = eth.blockNumber; i  = limit; i--) {\n    if (eth.getBlock(i).miner == addr) {\n      addrs.push(i)\n    }\n  }\n  return addrs\n}\n// scans the last 1000 blocks and returns the blocknumbers of blocks mined by your coinbase\n// (more precisely blocks the mining reward for which is sent to your coinbase).\nminedBlocks(1000, eth.coinbase);\n//[352708, 352655, 352559] Note that it will happen often that you find a block yet it never makes\nit to the canonical chain. This means when you locally include your\nmined block, the current state will show the mining reward credited to\nyour account, however, after a while, the better chain is discovered and\nwe switch to a chain in which your block is not included and therefore\nno mining reward is credited. Therefore it is quite possible that as a\nminer monitoring their coinbase balance will find that it may fluctuate\nquite a bit.\n\n## GPU mining\n\n### Hardware\n\nThe algorithm is memory hard and in order to fit the DAG into memory, it\nneeds 1-2GB of RAM on each GPU. If you get\n`Error GPU mining. GPU memory fragmentation?` you do not have enough\nmemory. The GPU miner is implemented in OpenCL, so AMD GPUs will be\n\\ faster\\  than same-category NVIDIA GPUs. ASICs and FPGAs are\nrelatively inefficient and therefore discouraged. To get openCL for your\nchipset and platform, try:\n\n-   [AMD SDK\n    openCL](http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk)\n-   [NVIDIA CUDA openCL](https://developer.nvidia.com/cuda-downloads)\n\n### Ubuntu Linux set-up\n\nFor this quick guide, you\\ ll need Ubuntu 14.04 or 15.04 and the fglrx\ngraphics drivers. You can use NVidia drivers and other platforms, too,\nbut you\\ ll have to find your own way to getting a working OpenCL\ninstall with them, such as [Genoil\\ s ethminer\nfork](http://cryptomining-blog.com/tag/ethminer/).\n\nIf you\\ re on 15.04, Go to \\ Software and Updates \\  Additional\nDrivers\\  and set it to \\ Using video drivers for the AMD graphics\naccelerator from fglrx\\ .\n\nIf you\\ re on 14.04, go to \\ Software and Updates \\  Additional\nDrivers\\  and set it to \\ Using video drivers for the AMD graphics\naccelerator from fglrx\\ . Unfortunately, for some of you this will not\nwork due to a known bug in Ubuntu 14.04.02 preventing you from switching\nto the proprietary graphics drivers required to GPU mine.\n\nSo, if you encounter this bug, and before you do anything else, go to\n\\ Software and updates \\  Updates\\  and select \\ Pre-released updates\ntrusty proposed\\ . Then, go back to \\ Software and Updates \\  Additional\nDrivers\\  and set it to \\ Using video drivers for the AMD graphics\naccelerator from fglrx\\ ). After rebooting, it\\ s well worth having a\ncheck that the drivers have now indeed been installed correctly (For\nexample by going to \\ Additional Drivers\\  again).\n\nWhatever you do, if you are on 14.04.02 do not alter the drivers or the\ndrivers configuration once set. For example, the usage of aticonfig\n\\--initial (especially with the -f, \\--force option) can \\ break\\  your\nsetup. If you accidentally alter their configuration, you\\ ll need to\nde-install the drivers, reboot, reinstall the drivers and reboot.\n\n### Mac set-up\n\n``` {.sourceCode .bash}\nwget http://developer.download.nvidia.com/compute/cuda/7_0/Prod/local_installers/cuda_7.0.29_mac.pkg\nsudo installer -pkg ~/Desktop/cuda_7.0.29_mac.pkg -target /\nbrew update\nbrew tap ethereum/ethereum\nbrew reinstall cpp-ethereum --with-gpu-mining --devel --headless --build-from-source  You check your cooling status:  ``` {.sourceCode .bash}\naticonfig --adapter=0 --od-gettemperature ### Windows set-up\n\n[Download the latest Eth++\ninstallation](https://github.com/ethereum-mining/ethminer/releases) and\nchoose ethminer at the \\ Choose Components\\  screen of the installation\nscreen.\n\n![image](img/eth_miner_setup.png)\n\n### Using ethminer with geth\n\n``` {.sourceCode .bash}\ngeth account new // Set-up ethereum account if you do not have one\ngeth --rpc --rpccorsdomain localhost 2  geth.log  \nethminer -G  // -G for GPU, -M for benchmark\ntail -f geth.log  ethminer  communicates with geth on port 8545 (the default RPC port in\ngeth). You can change this by giving the  --rpcport  option to  geth .\nEthminer will find geth on any port. Note that you need to set the CORS\nheader with  --rpccorsdomain localhost . You can also set port on ethminer  with  -F http://127.0.0.1:3301 . Setting the ports is\nnecessary if you want several instances mining on the same computer,\nalthough this is somewhat pointless. If you are testing on a private\nchain, we recommend you use CPU mining instead.  ::: {.note}\n::: {.admonition-title}\nNote\n:::  You do  not  need to give  geth  the  --mine  option or start the\nminer in the console unless you want to do CPU mining on TOP of GPU\nmining.\n:::  If the default for  ethminer  does not work try to specify the OpenCL\ndevice with:  --opencl-device X  where X is {0, 1, 2,...}. When running ethminer  with  -M  (benchmark), you should see something like:  ``` {.sourceCode .bash}\nBenchmarking on platform: { \"platform\": \"NVIDIA CUDA\", \"device\": \"GeForce GTX 750 Ti\", \"version\": \"OpenCL 1.1 CUDA\" }  Benchmarking on platform: { \"platform\": \"Apple\", \"device\": \"Intel(R) Xeon(R) CPU E5-1620 v2 @ 3.70GHz\", \"version\": \"OpenCL 1.2 \" } To debug `geth`:\n\n``` {.sourceCode .bash}\ngeth  --rpccorsdomain  localhost  --verbosity 6 2  geth.log  To debug the miner:  ``` {.sourceCode .bash}\nmake -DCMAKE_BUILD_TYPE=Debug -DETHASHCL=1 -DGUI=0\ngdb --args ethminer -G -M ::: {.note}\n::: {.admonition-title}\nNote\n:::\n\nhashrate info is not available in `geth` when GPU mining.\n:::\n\nCheck your hashrate with `ethminer`, `miner.hashrate` will always report\n0.\n\n### Using ethminer with eth\n\n#### Mining on a single GPU\n\nIn order to mine on a single GPU all that needs to be done is to run eth\nwith the following arguments:\n\n``` {.sourceCode .bash}\neth -v 1 -a 0xcadb3223d4eebcaa7b40ec5722967ced01cfc8f2 --client-name  OPTIONALNAMEHERE  -x 50 -m on -G   -v 1  Set verbosity to 1. Let\\'s not get spammed by messages.  -a YOURWALLETADDRESS  Set the coinbase, where the mining rewards\n    will go to. The above address is just an example. This argument is\n    really important, make sure to not make a mistake in your wallet\n    address or you will receive no ether payout.  --client-name \"OPTIONAL\"  Set an optional client name to identify\n    you on the network  -x 50  Request a high amount of peers. Helps with finding peers in\n    the beginning.  -m on  Actually launch with mining on.  -G  set GPU mining on.   While the client is running you can interact with it using either geth\nattach` or\n[ethconsole]( https://github.com/ethereum/ethereum-console ).", 
            "title": "Ethash DAG"
        }, 
        {
            "location": "/mining/#mining-on-a-multiple-gpus", 
            "text": "Mining with multiple GPUs and eth is very similar to mining with geth\nand multiple GPUs. Ensure that an eth node is running with your coinbase\naddress properly set:  ``` {.sourceCode .bash}\neth -v 1 -a 0xcadb3223d4eebcaa7b40ec5722967ced01cfc8f2 --client-name \"OPTIONALNAMEHERE\" -x 50 -j Notice that we also added the -j argument so that the client can have\nthe JSON-RPC server enabled to communicate with the ethminer instances.\nAdditionally we removed the mining related arguments since ethminer will\nnow do the mining for us. For each of your GPUs execute a different\nethminer instance:\n\n``` {.sourceCode .bash}\nethminer --no-precompute -G --opencl-device X  Where X is the index number corresponding to the openCL device you want\nthe ethminer to use {0, 1, 2,...}. In order to easily get a list of\nOpenCL devices you can execute  ethminer --list-devices  which will\nprovide a list of all devices OpenCL can detect, with also some\nadditional information per device.  Below is a sample output:  ``` {.sourceCode .console}\n[0] GeForce GTX 770\n    CL_DEVICE_TYPE: GPU\n    CL_DEVICE_GLOBAL_MEM_SIZE: 4286345216\n    CL_DEVICE_MAX_MEM_ALLOC_SIZE: 1071586304\n    CL_DEVICE_MAX_WORK_GROUP_SIZE: 1024 Finally the `--no-precompute` argument requests that the ethminers\ndon\\ t create the DAG of the next epoch ahead of time. Although this is\nnot recommended since you\\ ll have a mining interruption every time when\nthere\\ s an epoch transition.\n\n#### Benchmarking\n\nMining power tends to scale with memory bandwidth. Our implementation is\nwritten in OpenCL, which is typically supported better by AMD GPUs over\nNVidia. Empirical evidence confirms that AMD GPUs offer a better mining\nperformance in terms of price than their NVidia counterparts.\n\nTo benchmark a single-device setup you can use ethminer in benchmarking\nmode through the -M option:\n\n``` {.sourceCode .bash}\nethminer -G -M  If you have many devices and you\\'ll like to benchmark each\nindividually, you can use the --opencl-device option similarly to the\nprevious section:  {.sourceCode .bash}\nethminer -G -M --opencl-device X  Use ethminer  --list-devices  to list possible numbers to substitute for\nthe X {0, 1, 2,...}.  To start mining on Windows, first  download the geth windows\nbinary .   Unzip Geth (right-click and select unpack) and launch Command\n    Prompt. Use cd to navigate to the location of the Geth data folder.\n    (e.g.  cd /  to go to the  C:  drive)  Start geth by typing  geth --rpc .   As soon as you enter this, the Ethereum blockchain will start\ndownloading. Sometimes your firewall may block the synchronisation\nprocess (it will prompt you when doing so). If this is the case, click\n\\\"Allow access\\\".   First  download and install\n    ethminer ,\n    the C++ mining software (your firewall or Windows itself may act up,\n    allow access)  Open up another Command Prompt (leave the first one running!),\n    change directory by typing  cd /Program\\ Files/Ethereum(++)/release  Now make sure geth has finished syncing the blockchain. If it is not\n    syncing any longer, you can start the mining process by typing\n     ethminer -G  at the command prompt   At this point some problems may appear. If you get an error, you can\nabort the miner by pressing  Ctrl+C . If the error says \\\"Insufficient\nMemory\\\", your GPU does not have enough memory to mine ether.", 
            "title": "Mining on a multiple GPUs"
        }, 
        {
            "location": "/mining/#pool-mining-", 
            "text": "Mining pools are cooperatives that aim to smooth out expected revenue by\npooling the mining power of participating miners. In return, they\nusually charge you 0-5% of your mining rewards. The mining pool submits\nblocks with proof of work from a central account and redistributes the\nreward to participants in proportion to their contributed mining power.  ::: {.warning}\n::: {.admonition-title}\nWarning\n:::  Most mining pools involve third party, central components which means\nthey are not trustless. In other words, pool operators can run away with\nyour earnings. Act with caution. There are a number of trustless,\ndecentralised pools with open source codebase.\n:::  ::: {.warning}\n::: {.admonition-title}\nWarning\n:::  Mining pools only outsource proof of work calculation, they do not\nvalidate blocks or run the VM to check state transitions brought about\nby executing the transactions. This effectively make pools behave like\nsingle nodes in terms of security, so their growth poses a\ncentralisation risk of a  51%\nattack . Make\nsure you follow the network capacity distribution and do not allow pools\nto grow too large.\n:::", 
            "title": "Pool mining-"
        }, 
        {
            "location": "/mining/#mining-pools", 
            "text": "coinotron  nanopool  ethpool  -\n    Predictable solo mining, unconventional payout scheme, affiliated\n    with  etherchain\\.org .  supernova  coinmine.pl  eth.pp.ua  talkether  - Unconventional payout scheme,\n    partially decentralized  weipool  ethereumpool  pooleum  alphapool  cryptopool  unitedminers  2miners  dwarfpool  - Try to avoid this (currently\n    over 50% of the network)  laintimes  - Discontinued", 
            "title": "Mining pools"
        }, 
        {
            "location": "/mining/#mining-resources-", 
            "text": "Top miners of last 24h on\n    etherchain  pool hashrate distribution for august\n    2015  Unmaintained list of pools on\n    Forum  Mining profitability calculator on\n    cryptocompare  Mining profitability calculator on\n    cryptowizzard  Mining profitability calculator on\n    etherscan  Mining profitability calculator on In The\n    Ether  Mining difficulty chart on\n    etherscan", 
            "title": "Mining resources----"
        }, 
        {
            "location": "/mining/#pos-vs-pow-pos-vs-pow", 
            "text": "https://www.reddit.com/r/ethereum/comments/38db1z/eli5_the_difference_between_pos_and_pow/  https://blog.ethereum.org/2014/11/25/proof-stake-learned-love-weak-subjectivity/  https://www.reddit.com/r/ethereum/comments/42o8oy/can_someone_explain_the_switch_to_pos_how_and_when/", 
            "title": "POS vs POW {#POS vs POW}"
        }, 
        {
            "location": "/contracts-and-transactions/account-types-gas-and-transactions/", 
            "text": "Account Types, Gas, and Transactions\n\n\nEOA vs contract accounts\n\n\nThere are two types of accounts in Ethereum\n\n\n:   -   Externally Owned Accounts\n    -   Contracts Accounts\n\n\nThis distinction might be eliminated in Serenity.\n\n\nExternally owned accounts (EOAs)\n\n\nAn externally controlled account\n\n\n\n\nhas an ether balance,\n\n\ncan send transactions (ether transfer or trigger contract code),\n\n\nis controlled by private keys,\n\n\nhas no associated code.\n\n\n\n\nContract accounts\n\n\nA contract\n\n\n\n\nhas an ether balance,\n\n\nhas associated code,\n\n\ncode execution is triggered by transactions or messages (calls)\n    received from other contracts.\n\n\nwhen executed\n\n\nperform operations of arbitrary complexity (Turing completeness)\n\n\nmanipulate its own persistent storage, i.e., can have its own\n    permanent state\n\n\ncan call other contracts\n\n\n\n\n\n\n\n\nAll action on the Ethereum block chain is set in motion by transactions\nfired from externally owned accounts. Every time a contract account\nreceives a transaction, its code is executed as instructed by the input\nparameters sent as part of the transaction. The contract code is\nexecuted by the Ethereum Virtual Machine on each node participating in\nthe network as part of their verification of new blocks.\n\n\nThis execution needs to be completely deterministic, its only context is\nthe position of the block on the blockchain and all data available. The\nblocks on the blockchain represent units of time, the blockchain itself\nis a temporal dimension and represents the entire history of states at\nthe discrete time points designated by the blocks on the chain.\n\n\nAll ether balances and values are denominated in units of wei: 1 ether\nis 1e18 wei.\n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\n\\\"Contracts\\\" in Ethereum should not be seen as something that should be\n\\\"fulfilled\\\" or \\\"complied with\\\"; rather, they are more like\n\\\"autonomous agents\\\" that live inside of the Ethereum execution\nenvironment, always executing a specific piece of code when \\\"poked\\\" by\na message or transaction, and having direct control over their own ether\nbalance and their own key/value store to store their permanent state.\n:::\n\n\nWhat is a transaction?\n\n\nThe term \\\"transaction\\\" is used in Ethereum to refer to the signed data\npackage that stores a message to be sent from an externally owned\naccount to another account on the blockchain.\n\n\nTransactions contain:\n\n\n:   -   the recipient of the message,\n    -   a signature identifying the sender and proving their intention\n        to send the message via the blockchain to the recipient,\n    -   \nVALUE\n field - The amount of wei to transfer from the sender to\n        the recipient,\n    -   an optional data field, which can contain the message sent to a\n        contract,\n    -   a \nSTARTGAS\n value, representing the maximum number of\n        computational steps the transaction execution is allowed to\n        take,\n    -   a \nGASPRICE\n value, representing \\\"Wei per gas\\\". One Wei\n        corresponds to 0.000000000000000001 Ether.\n\n\nWhat is a message?\n\n\nContracts have the ability to send \\\"messages\\\" to other contracts.\nMessages are virtual objects that are never serialized and exist only in\nthe Ethereum execution environment. They can be conceived of as function\ncalls.\n\n\nA message contains:\n\n\n:   -   the sender of the message (implicit).\n    -   the recipient of the message\n    -   \nVALUE\n field - The amount of wei to transfer alongside the\n        message to the contract address,\n    -   an optional data field, that is the actual input data to the\n        contract\n    -   a \nSTARTGAS\n value, which limits the maximum amount of gas the\n        code execution triggered by the message can incur.\n\n\nEssentially, a message is like a transaction, except it is produced by a\ncontract and not an external actor. A message is produced when a\ncontract currently executing code executes the \nCALL\n or \nDELEGATECALL\n\nopcodes, which produces and executes a message. Like a transaction, a\nmessage leads to the recipient account running its code. Thus, contracts\ncan have relationships with other contracts in exactly the same way that\nexternal actors can.\n\n\nWhat is gas?\n\n\nEthereum implements an execution environment on the blockchain called\nthe Ethereum Virtual Machine (EVM). Every node participating in the\nnetwork runs the EVM as part of the block verification protocol. They go\nthrough the transactions listed in the block they are verifying and run\nthe code as triggered by the transaction within the EVM. Each and every\nfull node in the network does the same calculations and stores the same\nvalues. Clearly Ethereum is not about optimising efficiency of\ncomputation. Its parallel processing is redundantly parallel. This is to\noffer an efficient way to reach consensus on the system state without\nneeding trusted third parties, oracles or violence monopolies. But\nimportantly they are not there for optimal computation. The fact that\ncontract executions are redundantly replicated across nodes, naturally\nmakes them expensive, which generally creates an incentive not to use\nthe blockchain for computation that can be done offchain.\n\n\nWhen you are running a decentralized application (dapp), it interacts\nwith the blockchain to read and modify its state, but dapps will\ntypically only put the business logic and state that are crucial for\nconsensus on the blockchain.\n\n\nWhen a contract is executed as a result of being triggered by a message\nor transaction, every instruction is executed on every node of the\nnetwork. This has a cost: for every executed operation there is a\nspecified cost, expressed in a number of gas units.\n\n\nGas is the name for the execution fee that senders of transactions need\nto pay for every operation made on an Ethereum blockchain. The name gas\nis inspired by the view that this fee acts as cryptofuel, driving the\nmotion of smart contracts. Gas is purchased for ether from the miners\nthat execute the code. Gas and ether are decoupled deliberately since\nunits of gas align with computation units having a natural cost, while\nthe price of ether generally fluctuates as a result of market forces.\nThe two are mediated by a free market: the price of gas is actually\ndecided by the miners, who can refuse to process a transaction with a\nlower gas price than their minimum limit. To get gas you simply need to\nadd ether to your account. The Ethereum clients automatically purchase\ngas for your ether in the amount you specify as your maximum expenditure\nfor the transaction.\n\n\nThe Ethereum protocol charges a fee per computational step that is\nexecuted in a contract or transaction to prevent deliberate attacks and\nabuse on the Ethereum network. Every transaction is required to include\na gas limit and a fee that it is willing to pay per gas. Miners have the\nchoice of including the transaction and collecting the fee or not. If\nthe total amount of gas used by the computational steps spawned by the\ntransaction, including the original message and any sub-messages that\nmay be triggered, is less than or equal to the gas limit, then the\ntransaction is processed. If the total gas exceeds the gas limit, then\nall changes are reverted, except that the transaction is still valid and\nthe fee can still be collected by the miner. All excess gas not used by\nthe transaction execution is reimbursed to the sender as Ether. You do\nnot need to worry about overspending, since you are only charged for the\ngas you consume. This means that it is useful as well as safe to send\ntransactions with a gas limit well above the estimates.\n\n\nEstimating transaction costs\n\n\nThe total ether cost of a transaction is based on 2 factors:\n\n\ngasUsed\n is the total gas that is consumed by the transaction\n\n\ngasPrice\n price (in ether) of one unit of gas specified in the\ntransaction\n\n\nTotal cost = gasUsed * gasPrice\n\n\ngasUsed\n\n\nEach operation in the EVM was assigned a number of how much gas it\nconsumes. \ngasUsed\n is the sum of all the gas for all the operations\nexecuted. There is a\n\nspreadsheet\n which offers a\nglimpse to some of the analysis behind this.\n\n\nFor estimating \ngasUsed\n, there is an \nestimateGas\nAPI\n that can be used but\nhas some caveats.\n\n\ngasPrice\n\n\nA user constructs and signs a transaction, and each user may specify\nwhatever \ngasPrice\n they desire, which can be zero. However, the\nEthereum clients launched at Frontier had a default gasPrice of 0.05e12\nwei. As miners optimize for their revenue, if most transactions are\nbeing submitted with a gasPrice of 0.05e12 wei, it would be difficult to\nconvince a miner to accept a transaction that specified a lower, or\nzero, gasPrice.\n\n\nExample transaction cost\n\n\nLet's take a contract that just adds 2 numbers. The EVM OPCODE \nADD\n\nconsumes 3 gas.\n\n\nThe approximate cost, using the default gas price (as of January 2016),\nwould be:\n\n\n3 * 0.05e12 = 1.5e11 wei\n\n\nSince 1 ether is 1e18 wei, the total cost would be 0.00000015 Ether.\n\n\nThis is a simplification since it ignores some costs, such as the cost\nof passing the 2 numbers to contract, before they can even be added.\n\n\n\n\nquestion\n\n\ngas fees\n\n\ngas cost calculator\n\n\nEthereum Gas\n    Prices\n\n\n\n\nOperation Name      Gas Cost   Remark                                         \n\n\n\n\nstep                1          default amount per execution cycle           \n\n  stop                0          free                                         \n\n  suicide sha3        0 20       free                                         \n\n  sload               20         get from permanent storage                   \n\n  sstore balance      100 20     put into permanent storage                   \n\n  create              100        contract creation                            \n\n  call                20         initiating a read-only call                  \n\n  memory              1          every additional word when expanding memory  \n\n  txdata              5          every byte of data or code for a transaction \n\n  transaction         500        base fee transaction                         \n\n  contract creation   53000      changed in homestead from 21000                \n\n\nAccount interactions example - betting contract\n\n\nAs previously mentioned, there are two types of accounts:\n\n\n\n\nExternally owned account (EOAs)\n: an account controlled by a\n    private key, and if you own the private key associated with the EOA\n    you have the ability to send ether and messages from it.\n\n\nContract\n: an account that has its own code, and is controlled by\n    code.\n\n\n\n\nBy default, the Ethereum execution environment is lifeless; nothing\nhappens and the state of every account remains the same. However, any\nuser can trigger an action by sending a transaction from an externally\nowned account, setting Ethereum\\'s wheels in motion. If the destination\nof the transaction is another EOA, then the transaction may transfer\nsome ether but otherwise does nothing. However, if the destination is a\ncontract, then the contract in turn activates, and automatically runs\nits code.\n\n\nThe code has the ability to read/write to its own internal storage (a\ndatabase mapping 32-byte keys to 32-byte values), read the storage of\nthe received message, and send messages to other contracts, triggering\ntheir execution in turn. Once execution stops, and all sub-executions\ntriggered by a message sent by a contract stop (this all happens in a\ndeterministic and synchronous order, ie. a sub-call completes fully\nbefore the parent call goes any further), the execution environment\nhalts once again, until woken by the next transaction.\n\n\nContracts generally serve four purposes:\n\n\n\n\nMaintain a data store representing something which is useful to\n    either other contracts or to the outside world; one example of this\n    is a contract that simulates a currency, and another is a contract\n    that records membership in a particular organization.\n\n\nServe as a sort of externally-owned account with a more complicated\n    access policy; this is called a \\\"forwarding contract\\\" and\n    typically involves simply resending incoming messages to some\n    desired destination only if certain conditions are met; for example,\n    one can have a forwarding contract that waits until two out of a\n    given three private keys have confirmed a particular message before\n    resending it (ie. multisig). More complex forwarding contracts have\n    different conditions based on the nature of the message sent. The\n    simplest use case for this functionality is a withdrawal limit that\n    is overrideable via some more complicated access procedure. A wallet\n    contract is a good example of this.\n\n\nManage an ongoing contract or relationship between multiple users.\n    Examples of this include a financial contract, an escrow with some\n    particular set of mediators, or some kind of insurance. One can also\n    have an open contract that one party leaves open for any other party\n    to engage with at any time; one example of this is a contract that\n    automatically pays a bounty to whoever submits a valid solution to\n    some mathematical problem, or proves that it is providing some\n    computational resource.\n\n\nProvide functions to other contracts, essentially serving as a\n    software library.\n\n\n\n\nContracts interact with each other through an activity that is\nalternately called either \\\"calling\\\" or \\\"sending messages\\\". A\n\\\"message\\\" is an object containing some quantity of ether, a byte-array\nof data of any size, the addresses of a sender and a recipient. When a\ncontract receives a message, it has the option of returning some data,\nwhich the original sender of the message can then immediately use. In\nthis way, sending a message is exactly like calling a function.\n\n\nBecause contracts can play such different roles, we expect that\ncontracts will be interacting with each other. As an example, consider a\nsituation where Alice and Bob are betting 100 GavCoin that the\ntemperature in San Francisco will not exceed 35\u00baC at any point in the\nnext year. However, Alice is very security-conscious, and as her primary\naccount uses a forwarding contract which only sends messages with the\napproval of two out of three private keys. Bob is paranoid about quantum\ncryptography, so he uses a forwarding contract which passes along only\nmessages that have been signed with Lamport signatures alongside\ntraditional ECDSA (but because he\\'s old fashioned, he prefers to use a\nversion of Lamport sigs based on SHA256, which is not supported in\nEthereum directly).\n\n\nThe betting contract itself needs to fetch data about the San Francisco\nweather from some contract, and it also needs to talk to the GavCoin\ncontract when it wants to actually send the GavCoin to either Alice or\nBob (or, more precisely, Alice or Bob\\'s forwarding contract). We can\nshow the relationships between the accounts thus:\n\n\n\n\nWhen Bob wants to finalize the bet, the following steps happen:\n\n\n\n\nA transaction is sent, triggering a message from Bob\\'s EOA to his\n    forwarding contract.\n\n\nBob\\'s forwarding contract sends the hash of the message and the\n    Lamport signature to a contract which functions as a Lamport\n    signature verification library.\n\n\nThe Lamport signature verification library sees that Bob wants a\n    SHA256-based Lamport sig, so it calls the SHA256 library many times\n    as needed to verify the signature.\n\n\nOnce the Lamport signature verification library returns 1,\n    signifying that the signature has been verified, it sends a message\n    to the contract representing the bet.\n\n\nThe bet contract checks the contract providing the San Francisco\n    temperature to see what the temperature is.\n\n\nThe bet contract sees that the response to the messages shows that\n    the temperature is above 35\u00baC, so it sends a message to the GavCoin\n    contract to move the GavCoin from its account to Bob\\'s forwarding\n    contract.\n\n\n\n\nNote that the GavCoin is all \\\"stored\\\" as entries in the GavCoin\ncontract\\'s database; the word \\\"account\\\" in the context of step 6\nsimply means that there is a data entry in the GavCoin contract storage\nwith a key for the bet contract\\'s address and a value for its balance.\nAfter receiving this message, the GavCoin contract decreases this value\nby some amount and increases the value in the entry corresponding to\nBob\\'s forwarding contract\\'s address. We can see these steps in the\nfollowing diagram:\n\n\n\n\nSigning transactions offline\n\n\n[ Maybe add this to the FAQ and point to the ethkey section of\nturboethereum guide? ]\n\n\n\n\nResilience Raw Transaction\n    Broadcaster", 
            "title": "\u5e10\u6237\u7c7b\u578b\u71c3\u6599\u4ea4\u6613"
        }, 
        {
            "location": "/contracts-and-transactions/account-types-gas-and-transactions/#account-types-gas-and-transactions", 
            "text": "", 
            "title": "Account Types, Gas, and Transactions"
        }, 
        {
            "location": "/contracts-and-transactions/account-types-gas-and-transactions/#eoa-vs-contract-accounts", 
            "text": "There are two types of accounts in Ethereum  :   -   Externally Owned Accounts\n    -   Contracts Accounts  This distinction might be eliminated in Serenity.", 
            "title": "EOA vs contract accounts"
        }, 
        {
            "location": "/contracts-and-transactions/account-types-gas-and-transactions/#externally-owned-accounts-eoas", 
            "text": "An externally controlled account   has an ether balance,  can send transactions (ether transfer or trigger contract code),  is controlled by private keys,  has no associated code.", 
            "title": "Externally owned accounts (EOAs)"
        }, 
        {
            "location": "/contracts-and-transactions/account-types-gas-and-transactions/#contract-accounts", 
            "text": "A contract   has an ether balance,  has associated code,  code execution is triggered by transactions or messages (calls)\n    received from other contracts.  when executed  perform operations of arbitrary complexity (Turing completeness)  manipulate its own persistent storage, i.e., can have its own\n    permanent state  can call other contracts     All action on the Ethereum block chain is set in motion by transactions\nfired from externally owned accounts. Every time a contract account\nreceives a transaction, its code is executed as instructed by the input\nparameters sent as part of the transaction. The contract code is\nexecuted by the Ethereum Virtual Machine on each node participating in\nthe network as part of their verification of new blocks.  This execution needs to be completely deterministic, its only context is\nthe position of the block on the blockchain and all data available. The\nblocks on the blockchain represent units of time, the blockchain itself\nis a temporal dimension and represents the entire history of states at\nthe discrete time points designated by the blocks on the chain.  All ether balances and values are denominated in units of wei: 1 ether\nis 1e18 wei.  ::: {.note}\n::: {.admonition-title}\nNote\n:::  \\\"Contracts\\\" in Ethereum should not be seen as something that should be\n\\\"fulfilled\\\" or \\\"complied with\\\"; rather, they are more like\n\\\"autonomous agents\\\" that live inside of the Ethereum execution\nenvironment, always executing a specific piece of code when \\\"poked\\\" by\na message or transaction, and having direct control over their own ether\nbalance and their own key/value store to store their permanent state.\n:::", 
            "title": "Contract accounts"
        }, 
        {
            "location": "/contracts-and-transactions/account-types-gas-and-transactions/#what-is-a-transaction", 
            "text": "The term \\\"transaction\\\" is used in Ethereum to refer to the signed data\npackage that stores a message to be sent from an externally owned\naccount to another account on the blockchain.  Transactions contain:  :   -   the recipient of the message,\n    -   a signature identifying the sender and proving their intention\n        to send the message via the blockchain to the recipient,\n    -    VALUE  field - The amount of wei to transfer from the sender to\n        the recipient,\n    -   an optional data field, which can contain the message sent to a\n        contract,\n    -   a  STARTGAS  value, representing the maximum number of\n        computational steps the transaction execution is allowed to\n        take,\n    -   a  GASPRICE  value, representing \\\"Wei per gas\\\". One Wei\n        corresponds to 0.000000000000000001 Ether.", 
            "title": "What is a transaction?"
        }, 
        {
            "location": "/contracts-and-transactions/account-types-gas-and-transactions/#what-is-a-message", 
            "text": "Contracts have the ability to send \\\"messages\\\" to other contracts.\nMessages are virtual objects that are never serialized and exist only in\nthe Ethereum execution environment. They can be conceived of as function\ncalls.  A message contains:  :   -   the sender of the message (implicit).\n    -   the recipient of the message\n    -    VALUE  field - The amount of wei to transfer alongside the\n        message to the contract address,\n    -   an optional data field, that is the actual input data to the\n        contract\n    -   a  STARTGAS  value, which limits the maximum amount of gas the\n        code execution triggered by the message can incur.  Essentially, a message is like a transaction, except it is produced by a\ncontract and not an external actor. A message is produced when a\ncontract currently executing code executes the  CALL  or  DELEGATECALL \nopcodes, which produces and executes a message. Like a transaction, a\nmessage leads to the recipient account running its code. Thus, contracts\ncan have relationships with other contracts in exactly the same way that\nexternal actors can.", 
            "title": "What is a message?"
        }, 
        {
            "location": "/contracts-and-transactions/account-types-gas-and-transactions/#what-is-gas", 
            "text": "Ethereum implements an execution environment on the blockchain called\nthe Ethereum Virtual Machine (EVM). Every node participating in the\nnetwork runs the EVM as part of the block verification protocol. They go\nthrough the transactions listed in the block they are verifying and run\nthe code as triggered by the transaction within the EVM. Each and every\nfull node in the network does the same calculations and stores the same\nvalues. Clearly Ethereum is not about optimising efficiency of\ncomputation. Its parallel processing is redundantly parallel. This is to\noffer an efficient way to reach consensus on the system state without\nneeding trusted third parties, oracles or violence monopolies. But\nimportantly they are not there for optimal computation. The fact that\ncontract executions are redundantly replicated across nodes, naturally\nmakes them expensive, which generally creates an incentive not to use\nthe blockchain for computation that can be done offchain.  When you are running a decentralized application (dapp), it interacts\nwith the blockchain to read and modify its state, but dapps will\ntypically only put the business logic and state that are crucial for\nconsensus on the blockchain.  When a contract is executed as a result of being triggered by a message\nor transaction, every instruction is executed on every node of the\nnetwork. This has a cost: for every executed operation there is a\nspecified cost, expressed in a number of gas units.  Gas is the name for the execution fee that senders of transactions need\nto pay for every operation made on an Ethereum blockchain. The name gas\nis inspired by the view that this fee acts as cryptofuel, driving the\nmotion of smart contracts. Gas is purchased for ether from the miners\nthat execute the code. Gas and ether are decoupled deliberately since\nunits of gas align with computation units having a natural cost, while\nthe price of ether generally fluctuates as a result of market forces.\nThe two are mediated by a free market: the price of gas is actually\ndecided by the miners, who can refuse to process a transaction with a\nlower gas price than their minimum limit. To get gas you simply need to\nadd ether to your account. The Ethereum clients automatically purchase\ngas for your ether in the amount you specify as your maximum expenditure\nfor the transaction.  The Ethereum protocol charges a fee per computational step that is\nexecuted in a contract or transaction to prevent deliberate attacks and\nabuse on the Ethereum network. Every transaction is required to include\na gas limit and a fee that it is willing to pay per gas. Miners have the\nchoice of including the transaction and collecting the fee or not. If\nthe total amount of gas used by the computational steps spawned by the\ntransaction, including the original message and any sub-messages that\nmay be triggered, is less than or equal to the gas limit, then the\ntransaction is processed. If the total gas exceeds the gas limit, then\nall changes are reverted, except that the transaction is still valid and\nthe fee can still be collected by the miner. All excess gas not used by\nthe transaction execution is reimbursed to the sender as Ether. You do\nnot need to worry about overspending, since you are only charged for the\ngas you consume. This means that it is useful as well as safe to send\ntransactions with a gas limit well above the estimates.", 
            "title": "What is gas?"
        }, 
        {
            "location": "/contracts-and-transactions/account-types-gas-and-transactions/#estimating-transaction-costs", 
            "text": "The total ether cost of a transaction is based on 2 factors:  gasUsed  is the total gas that is consumed by the transaction  gasPrice  price (in ether) of one unit of gas specified in the\ntransaction  Total cost = gasUsed * gasPrice", 
            "title": "Estimating transaction costs"
        }, 
        {
            "location": "/contracts-and-transactions/account-types-gas-and-transactions/#gasused", 
            "text": "Each operation in the EVM was assigned a number of how much gas it\nconsumes.  gasUsed  is the sum of all the gas for all the operations\nexecuted. There is a spreadsheet  which offers a\nglimpse to some of the analysis behind this.  For estimating  gasUsed , there is an  estimateGas\nAPI  that can be used but\nhas some caveats.", 
            "title": "gasUsed"
        }, 
        {
            "location": "/contracts-and-transactions/account-types-gas-and-transactions/#gasprice", 
            "text": "A user constructs and signs a transaction, and each user may specify\nwhatever  gasPrice  they desire, which can be zero. However, the\nEthereum clients launched at Frontier had a default gasPrice of 0.05e12\nwei. As miners optimize for their revenue, if most transactions are\nbeing submitted with a gasPrice of 0.05e12 wei, it would be difficult to\nconvince a miner to accept a transaction that specified a lower, or\nzero, gasPrice.", 
            "title": "gasPrice"
        }, 
        {
            "location": "/contracts-and-transactions/account-types-gas-and-transactions/#example-transaction-cost", 
            "text": "Let's take a contract that just adds 2 numbers. The EVM OPCODE  ADD \nconsumes 3 gas.  The approximate cost, using the default gas price (as of January 2016),\nwould be:  3 * 0.05e12 = 1.5e11 wei  Since 1 ether is 1e18 wei, the total cost would be 0.00000015 Ether.  This is a simplification since it ignores some costs, such as the cost\nof passing the 2 numbers to contract, before they can even be added.   question  gas fees  gas cost calculator  Ethereum Gas\n    Prices   Operation Name      Gas Cost   Remark                                            step                1          default amount per execution cycle            \n  stop                0          free                                          \n  suicide sha3        0 20       free                                          \n  sload               20         get from permanent storage                    \n  sstore balance      100 20     put into permanent storage                    \n  create              100        contract creation                             \n  call                20         initiating a read-only call                   \n  memory              1          every additional word when expanding memory   \n  txdata              5          every byte of data or code for a transaction  \n  transaction         500        base fee transaction                          \n  contract creation   53000      changed in homestead from 21000", 
            "title": "Example transaction cost"
        }, 
        {
            "location": "/contracts-and-transactions/account-types-gas-and-transactions/#account-interactions-example-betting-contract", 
            "text": "As previously mentioned, there are two types of accounts:   Externally owned account (EOAs) : an account controlled by a\n    private key, and if you own the private key associated with the EOA\n    you have the ability to send ether and messages from it.  Contract : an account that has its own code, and is controlled by\n    code.   By default, the Ethereum execution environment is lifeless; nothing\nhappens and the state of every account remains the same. However, any\nuser can trigger an action by sending a transaction from an externally\nowned account, setting Ethereum\\'s wheels in motion. If the destination\nof the transaction is another EOA, then the transaction may transfer\nsome ether but otherwise does nothing. However, if the destination is a\ncontract, then the contract in turn activates, and automatically runs\nits code.  The code has the ability to read/write to its own internal storage (a\ndatabase mapping 32-byte keys to 32-byte values), read the storage of\nthe received message, and send messages to other contracts, triggering\ntheir execution in turn. Once execution stops, and all sub-executions\ntriggered by a message sent by a contract stop (this all happens in a\ndeterministic and synchronous order, ie. a sub-call completes fully\nbefore the parent call goes any further), the execution environment\nhalts once again, until woken by the next transaction.  Contracts generally serve four purposes:   Maintain a data store representing something which is useful to\n    either other contracts or to the outside world; one example of this\n    is a contract that simulates a currency, and another is a contract\n    that records membership in a particular organization.  Serve as a sort of externally-owned account with a more complicated\n    access policy; this is called a \\\"forwarding contract\\\" and\n    typically involves simply resending incoming messages to some\n    desired destination only if certain conditions are met; for example,\n    one can have a forwarding contract that waits until two out of a\n    given three private keys have confirmed a particular message before\n    resending it (ie. multisig). More complex forwarding contracts have\n    different conditions based on the nature of the message sent. The\n    simplest use case for this functionality is a withdrawal limit that\n    is overrideable via some more complicated access procedure. A wallet\n    contract is a good example of this.  Manage an ongoing contract or relationship between multiple users.\n    Examples of this include a financial contract, an escrow with some\n    particular set of mediators, or some kind of insurance. One can also\n    have an open contract that one party leaves open for any other party\n    to engage with at any time; one example of this is a contract that\n    automatically pays a bounty to whoever submits a valid solution to\n    some mathematical problem, or proves that it is providing some\n    computational resource.  Provide functions to other contracts, essentially serving as a\n    software library.   Contracts interact with each other through an activity that is\nalternately called either \\\"calling\\\" or \\\"sending messages\\\". A\n\\\"message\\\" is an object containing some quantity of ether, a byte-array\nof data of any size, the addresses of a sender and a recipient. When a\ncontract receives a message, it has the option of returning some data,\nwhich the original sender of the message can then immediately use. In\nthis way, sending a message is exactly like calling a function.  Because contracts can play such different roles, we expect that\ncontracts will be interacting with each other. As an example, consider a\nsituation where Alice and Bob are betting 100 GavCoin that the\ntemperature in San Francisco will not exceed 35\u00baC at any point in the\nnext year. However, Alice is very security-conscious, and as her primary\naccount uses a forwarding contract which only sends messages with the\napproval of two out of three private keys. Bob is paranoid about quantum\ncryptography, so he uses a forwarding contract which passes along only\nmessages that have been signed with Lamport signatures alongside\ntraditional ECDSA (but because he\\'s old fashioned, he prefers to use a\nversion of Lamport sigs based on SHA256, which is not supported in\nEthereum directly).  The betting contract itself needs to fetch data about the San Francisco\nweather from some contract, and it also needs to talk to the GavCoin\ncontract when it wants to actually send the GavCoin to either Alice or\nBob (or, more precisely, Alice or Bob\\'s forwarding contract). We can\nshow the relationships between the accounts thus:   When Bob wants to finalize the bet, the following steps happen:   A transaction is sent, triggering a message from Bob\\'s EOA to his\n    forwarding contract.  Bob\\'s forwarding contract sends the hash of the message and the\n    Lamport signature to a contract which functions as a Lamport\n    signature verification library.  The Lamport signature verification library sees that Bob wants a\n    SHA256-based Lamport sig, so it calls the SHA256 library many times\n    as needed to verify the signature.  Once the Lamport signature verification library returns 1,\n    signifying that the signature has been verified, it sends a message\n    to the contract representing the bet.  The bet contract checks the contract providing the San Francisco\n    temperature to see what the temperature is.  The bet contract sees that the response to the messages shows that\n    the temperature is above 35\u00baC, so it sends a message to the GavCoin\n    contract to move the GavCoin from its account to Bob\\'s forwarding\n    contract.   Note that the GavCoin is all \\\"stored\\\" as entries in the GavCoin\ncontract\\'s database; the word \\\"account\\\" in the context of step 6\nsimply means that there is a data entry in the GavCoin contract storage\nwith a key for the bet contract\\'s address and a value for its balance.\nAfter receiving this message, the GavCoin contract decreases this value\nby some amount and increases the value in the entry corresponding to\nBob\\'s forwarding contract\\'s address. We can see these steps in the\nfollowing diagram:", 
            "title": "Account interactions example - betting contract"
        }, 
        {
            "location": "/contracts-and-transactions/account-types-gas-and-transactions/#signing-transactions-offline", 
            "text": "[ Maybe add this to the FAQ and point to the ethkey section of\nturboethereum guide? ]   Resilience Raw Transaction\n    Broadcaster", 
            "title": "Signing transactions offline"
        }, 
        {
            "location": "/contracts-and-transactions/contracts/", 
            "text": "Contracts {#Contracts}\n\n\nWhat is a contract?\n\n\nA contract is a collection of code (its functions) and data (its state)\nthat resides at a specific address on the Ethereum blockchain. Contract\naccounts are able to pass messages between themselves as well as doing\npractically Turing complete computation. Contracts live on the\nblockchain in a Ethereum-specific binary format called Ethereum Virtual\nMachine (EVM) bytecode.\n\n\nContracts are typically written in some high level language such as\n\nSolidity\n and then\ncompiled into bytecode to be uploaded on the blockchain.\n\n\n::: {.seealso}\nOther languages also exist, notably Serpent and LLL, which are described\nfurther in the [ethereum-high-level-languages]{role=\"ref\"} section of\nthis documentation.\n:::\n\n\n[IDE-or-development-framework]{role=\"ref\"} lists the integrated\ndevelopment environments, developer tools that help you develop in these\nlanguages, offering testing, and deployment support among other\nfeatures.\n\n\nEthereum high level languages\n\n\nContracts live on the blockchain in an Ethereum-specific binary format\n(EVM bytecode) that is executed by the Ethereum Virtual Machine (EVM).\nHowever, contracts are typically written in a higher level language and\nthen compiled using the EVM compiler into byte code to be deployed to\nthe blockchain.\n\n\nBelow are the different high level languages developers can use to write\nsmart contracts for Ethereum.\n\n\nSolidity\n\n\nSolidity is a language similar to JavaScript which allows you to develop\ncontracts and compile to EVM bytecode. It is currently the flagship\nlanguage of Ethereum and the most popular.\n\n\n\n\nSolidity\n    Documentation\n -\n    Solidity is the flagship Ethereum high level language that is used\n    to write contracts.\n\n\nSolidity online realtime\n    compiler\n\n\nStandardized Contract\n    APIs\n\n\nUseful \u00d0app\n    Patterns\n -\n    Code snippets which are useful for \u00d0app development.\n\n\n\n\nSerpent\n\n\nSerpent is a language similar to Python which can be used to develop\ncontracts and compile to EVM bytecode. It is intended to be maximally\nclean and simple, combining many of the efficiency benefits of a\nlow-level language with ease-of-use in programming style, and at the\nsame time adding special domain-specific features for contract\nprogramming. Serpent is compiled using _LLL.\n\n\n\n\nSerpent on the ethereum\n    wiki\n\n\nSerpent EVM compiler\n\n\n\n\nLLL\n\n\nLisp Like Language\n(LLL)\n is a\nlow level language similar to Assembly. It is meant to be very simple\nand minimalistic; essentially just a tiny wrapper over coding in EVM\ndirectly.\n\n\n\n\nLIBLLL in\n    GitHub\n\n\nExamples of\n    LLL\n\n\n\n\nMutan (deprecated)\n\n\nMutan\n is a statically typed, C-like\nlanguage designed and developed by Jeffrey Wilcke. It is no longer\nmaintained.\n\n\nWriting a contract\n\n\nNo language would be complete without a Hello World program. Operating\nwithin the Ethereum environment, Solidity has no obvious way of\n\\\"outputting\\\" a string. The closest we can do is to use a \nlog event\n\nto place a string into the blockchain:\n\n\n``` {.sourceCode .js}\ncontract HelloWorld {\n    event Print(string out);\n    function() { Print(\"Hello, World!\"); }\n}\n\nThis\n \ncontract\n \nwill\n \ncreate\n \na\n \nlog\n \nentry\n \non\n \nthe\n \nblockchain\n \nof\n \ntype\n \nPrint\n\n\nwith\n \na\n \nparameter\n \n\\\nHello, World!\\\n each time it is executed.\n\n\n\n::: {.seealso}\n\n\n[Solidity docs](https://solidity.readthedocs.org/en/latest/) has more\n\n\nexamples and guidelines to writing Solidity code.\n\n\n:::\n\n\n\nCompiling a contract\n\n\n--------------------\n\n\n\nCompilation of solidity contracts can be accomplished via a number of\n\n\nmechanisms.\n\n\n\n-   Using the `solc` compiler via the command line.\n\n\n-   Using `web3.eth.compile.solidity` in the javascript console provided\n\n\n    by `geth` or `eth` (This still requires the `solc` compiler to be\n\n\n    installed).\n\n\n-   The [online Solidity realtime\n\n\n    compiler](https://ethereum.github.io/browser-solidity/).\n\n\n-   The [Meteor dapp Cosmo for building solidity\n\n\n    contracts](https://github.com/SilentCicero/meteor-dapp-cosmo).\n\n\n-   The [Mix\n\n\n    IDE](https://github.com/ethereum/wiki/wiki/Mix:-The-DApp-IDE).\n\n\n-   The [Ethereum Wallet](https://github.com/ethereum/mist/releases).\n\n\n\n::: {.note}\n\n\n::: {.admonition-title}\n\n\nNote\n\n\n:::\n\n\n\nMore information on solc and compiling Solidity contract code can be\n\n\nfound\n\n\n[here](https://solidity.readthedocs.org/en/latest/frequently-asked-questions.html#how-do-i-compile-contracts).\n\n\n:::\n\n\n\n### Setting up the solidity compiler in geth\n\n\n\nIf you start up your `geth` node, you can check which compilers are\n\n\navailable.\n\n\n\n``` {.sourceCode .bash}\n\n\n web3.eth.getCompilers();\n\n\n[\nlll\n, \nsolidity\n, \nserpent\n]\n\n\n\n\nThis command returns an array of strings indicating which compilers are\ncurrently available.\n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\nThe \nsolc\n compiler is installed with \ncpp-ethereum\n. Alternatively, you\ncan \nbuild it\nyourself\n.\n:::\n\n\nIf your \nsolc\n executable is in a non-standard location you can specify\na custom path to the \nsolc\n executable using th \n--solc\n flag.\n\n\n``` {.sourceCode .bash}\n$ geth --solc /usr/local/bin/solc\n\nAlternatively, you can set this option at runtime via the console:\n\n``` {.sourceCode .bash}\n\n admin.setSolc(\n/usr/local/bin/solc\n)\nsolc, the solidity compiler commandline interface\nVersion: 0.2.2-02bb315d/.-Darwin/appleclang/JIT linked to libethereum-1.2.0-8007cef0/.-Darwin/appleclang/JIT\npath: /usr/local/bin/solc\n\n\n\nCompiling a simple contract {#compile_a_simple_contract}\n\n\nLet\\'s compile a simple contract source:\n\n\n``` {.sourceCode .bash}\n\n\n\n\nsource = \"contract test { function multiply(uint a) returns(uint d) { return a * 7; } }\"\n\nThis\n \ncontract\n \noffers\n \na\n \nsingle\n \nmethod\n \n**\nmultiply\n**\n \nwhich\n \nis\n \ncalled\n \nwith\n \na\n\n\npositive\n \ninteger\n \n`\na\n`\n \nand\n \nreturns\n \n`\na\n \n*\n \n7\n`\n.\n\n\n\nYou\n \nare\n \nready\n \nto\n \ncompile\n \nsolidity\n \ncode\n \nin\n \nthe\n \n`\ngeth\n`\n \nJS\n \nconsole\n \nusing\n\n\n[\neth.compile.solidity\n()\n]\n(\nhttps\n://\ngithub\n.\ncom\n/\nethereum\n/\nwiki\n/\nwiki\n/\nJavaScript-API\n#\nweb3ethcompilesolidity\n):\n\n\n\n```\n \n{\n.sourceCode\n \n.bash\n}\n\n\n \ncontract\n \n=\n \neth\n.\ncompile\n.\nsolidity\n(\nsource\n)\n.\ntest\n\n\n{\n\n  \ncode\n:\n \n605280600c6000396000f3006000357c010000000000000000000000000000000000000000000000000000000090048063c6888fa114602e57005b60376004356041565b8060005260206000f35b6000600782029050604d565b91905056\n,\n\n  \ninfo\n:\n \n{\n\n    \nlanguage\n:\n \nSolidity\n,\n\n    \nlanguageVersion\n:\n \n0\n,\n\n    \ncompilerVersion\n:\n \n0.9.13\n,\n\n    \nabiDefinition\n:\n \n[\n{\n\n      \nconstant\n:\n \nfalse\n,\n\n      \ninputs\n:\n \n[\n{\n\n        \nname\n:\n \na\n,\n\n        \ntype\n:\n \nuint256\n\n      \n}\n \n]\n,\n\n      \nname\n:\n \nmultiply\n,\n\n      \noutputs\n:\n \n[\n{\n\n        \nname\n:\n \nd\n,\n\n        \ntype\n:\n \nuint256\n\n      \n}\n \n]\n,\n\n      \ntype\n:\n \nfunction\n\n    \n}\n \n],\n\n    \nuserDoc\n:\n \n{\n\n      \nmethods\n:\n \n{\n\n      \n}\n\n    \n}\n,\n\n    \ndeveloperDoc\n:\n \n{\n\n      \nmethods\n:\n \n{\n\n      \n}\n\n    \n}\n,\n\n    \nsource\n:\n \ncontract test { function multiply(uint a) returns(uint d) { return a * 7; } }\n\n  \n}\n\n\n}\n\n\n\n\n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\nThe compiler is also available via\n\nRPC\n and therefore via\nweb3\\.js \\\nhttps://github.com/ethereum/wiki/wiki/JavaScript\n API#web3ethcompilesolidity>__ to any in-browser \u00d0app connecting to\n\ngeth\n via RPC/IPC.\n:::\n\n\nThe following example shows how you interface \ngeth\n via JSON-RPC to use\nthe compiler.\n\n\n``` {.sourceCode .bash}\n$ geth --datadir ~/eth/ --loglevel 6 --logtostderr=true --rpc --rpcport 8100 --rpccorsdomain '*' --mine console  2\n ~/eth/eth.log\n$ curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_compileSolidity\",\"params\":[\"contract test { function multiply(uint a) returns(uint d) { return a * 7; } }\"],\"id\":1}' http://127.0.0.1:8100\n\nThe\n \ncompiler\n \noutput\n \nfor\n \none\n \nsource\n \nwill\n \ngive\n \nyou\n \ncontract\n \nobjects\n \neach\n\n\nrepresenting\n \na\n \nsingle\n \ncontract\n.\n \nThe\n \nactual\n \nreturn\n \nvalue\n \nof\n\n\n`\neth\n.\ncompile\n.\nsolidity\n`\n \nis\n \na\n \nmap\n \nof\n \ncontract\n \nname\n \nto\n \ncontract\n \nobject\n\n\npairs\n.\n \nSince\n \nour\n \ncontract\n\\\ns\n \nname\n \nis\n \n`\ntest\n`\n,\n\n\n`\neth\n.\ncompile\n.\nsolidity\n(\nsource\n).\ntest\n`\n \nwill\n \ngive\n \nyou\n \nthe\n \ncontract\n \nobject\n\n\nfor\n \nthe\n \ntest\n \ncontract\n \ncontaining\n \nthe\n \nfollowing\n \nfields\n:\n\n\n\n:::\n \n{.\nglossary\n}\n\n\n\n`\ncode\n`\n\n\n\n:\n   \nThe\n \ncompiled\n \nEVM\n \nbytecode\n\n\n\n`\ninfo\n`\n\n\n\n:\n   \nAdditional\n \nmetadata\n \noutput\n \nfrom\n \nthe\n \ncompiler\n\n\n\n`\nsource\n`\n\n\n\n:\n   \nThe\n \nsource\n \ncode\n\n\n\n`\nlanguage\n`\n\n\n\n:\n   \nThe\n \ncontract\n \nlanguage\n \n(\nSolidity\n,\n \nSerpent\n,\n \nLLL\n)\n\n\n\n`\nlanguageVersion\n`\n\n\n\n:\n   \nThe\n \ncontract\n \nlanguage\n \nversion\n\n\n\n`\ncompilerVersion\n`\n\n\n\n:\n   \nThe\n \nsolidity\n \ncompiler\n \nversion\n \nthat\n \nwas\n \nused\n \nto\n \ncompile\n \nthis\n\n    \ncontract\n.\n\n\n\n`\nabiDefinition\n`\n\n\n\n:\n   \nThe\n \n[\nApplication\n \nBinary\n \nInterface\n\n    \nDefinition\n](\nhttps\n:\n//github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI)\n\n\n\n`\nuserDoc\n`\n\n\n\n:\n   \nThe\n \n[\nNatSpec\n\n    \nDoc\n](\nhttps\n:\n//github.com/ethereum/wiki/wiki/Ethereum-Natural-Specification-Format)\n\n    \nfor\n \nusers\n.\n\n\n\n`\ndeveloperDoc\n`\n\n\n\n:\n   \nThe\n \n[\nNatSpec\n\n    \nDoc\n](\nhttps\n:\n//github.com/ethereum/wiki/wiki/Ethereum-Natural-Specification-Format)\n\n    \nfor\n \ndevelopers\n.\n\n\n:::\n\n\n\nThe\n \nimmediate\n \nstructuring\n \nof\n \nthe\n \ncompiler\n \noutput\n \n(\ninto\n \n`\ncode\n`\n \nand\n\n\n`\ninfo\n`\n)\n \nreflects\n \nthe\n \ntwo\n \nvery\n \ndifferent\n \n**\npaths\n \nof\n \ndeployment\n**\n.\n \nThe\n\n\ncompiled\n \nEVM\n \ncode\n \nis\n \nsent\n \noff\n \nto\n \nthe\n \nblockchain\n \nwith\n \na\n \ncontract\n \ncreation\n\n\ntransaction\n \nwhile\n \nthe\n \nrest\n \n(\ninfo\n)\n \nwill\n \nideally\n \nlive\n \non\n \nthe\n \ndecentralised\n\n\ncloud\n \nas\n \npublicly\n \nverifiable\n \nmetadata\n \ncomplementing\n \nthe\n \ncode\n \non\n \nthe\n\n\nblockchain\n.\n\n\n\nIf\n \nyour\n \nsource\n \ncontains\n \nmultiple\n \ncontracts\n,\n \nthe\n \noutput\n \nwill\n \ncontain\n \nan\n\n\nentry\n \nfor\n \neach\n \ncontract\n,\n \nthe\n \ncorresponding\n \ncontract\n \ninfo\n \nobject\n \ncan\n \nbe\n\n\nretrieved\n \nwith\n \nthe\n \nname\n \nof\n \nthe\n \ncontract\n \nas\n \nattribute\n \nname\n.\n \nYou\n \ncan\n \ntry\n\n\nthis\n \nby\n \ninspecting\n \nthe\n \nmost\n \ncurrent\n \nGlobalRegistrar\n \ncode\n:\n\n\n\n```\n \n{.\nsourceCode\n \n.\njs\n}\n\n\ncontracts\n \n=\n \neth\n.\ncompile\n.\nsolidity\n(\nglobalRegistrarSrc\n)\n\n\n\n\nCreate and deploy a contract\n\n\nBefore you begin this section, make sure you have both an unlocked\naccount as well as some funds.\n\n\nYou will now create a contract on the blockchain by \nsending a\ntransaction\n\nto the empty address with the EVM code from the previous section as\ndata.\n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\nThis can be accomplished much easier using the \nonline Solidity realtime\ncompiler\n or the \nMix\nIDE\n program.\n:::\n\n\n``` {.sourceCode .js}\nvar primaryAddress = eth.accounts[0]\nvar abi = [{ constant: false, inputs: { name: 'a', type: 'uint256' } }]\nvar MyContract = eth.contract(abi)\nvar contract = MyContract.new(arg1, arg2, ..., {from: primaryAddress, data: evmByteCodeFromPreviousSection})\n\nAll binary data is serialised in hexadecimal form. Hex strings always\nhave a hex prefix `0x`.\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\nNote that `arg1, arg2, ...` are the arguments for the contract\nconstructor, in case it accepts any. If the contract does not require\nany constructor arguments then these arguments can be omitted.\n:::\n\nIt is worth pointing out that this step requires you to pay for\nexecution. Your balance on the account (that you put as sender in the\n`from` field) will be reduced according to the gas rules of the EVM once\nyour transaction makes it into a block. After some time, your\ntransaction should appear included in a block confirming that the state\nit brought about is a consensus. Your contract now lives on the\nblockchain.\n\nThe asynchronous way of doing the same looks like this:\n\n``` {.sourceCode .js}\nMyContract.new([arg1, arg2, ...,]{from: primaryAccount, data: evmCode}, function(err, contract) {\n  if (!err \n contract.address)\n    console.log(contract.address);\n});\n\n\n\nInteracting with a contract {#interacting_with_a_contract}\n\n\nInteraction with a contract is typically done using an abstraction layer\nsuch as the\n\neth.contract()\n\nfunction which returns a javascript object with all of the contract\nfunctions available as callable functions in javascript.\n\n\nThe standard way to describe the available functions of a contract is\nthe \nABI\ndefinition\n.\nThis object is an array which describles the call signature and return\nvalues for each available contract function.\n\n\n``` {.sourceCode .js}\nvar Multiply7 = eth.contract(contract.info.abiDefinition);\nvar myMultiply7 = Multiply7.at(address);\n\nNow all the function calls specified in the ABI are made available on\nthe contract instance. You can just call those methods on the contract\ninstance in one of two ways.\n\n``` {.sourceCode .js}\n\n myMultiply7.multiply.sendTransaction(3, {from: address})\n\n0x12345\n\n\n myMultiply7.multiply.call(3)\n21\n\n\n\nWhen called using \nsendTransaction\n the function call is executed via\nsending a transaction. This will cost ether to send and the call will be\nrecorded forever on the blockchain. The return value of calls made in\nthis manner is the hash of the transaction.\n\n\nWhen called using \ncall\n the function is executed locally in the EVM and\nthe return value of the function is returned with the function. Calls\nmade in this manner are not recorded on the blockchain and thus, cannot\nmodify the internal state of the contract. This manner of call is\nreferred to as a \nconstant\n function call. Calls made in this manner\ndo not cost any ether.\n\n\nYou should use \ncall\n if you are interested only in the return value and\nuse \nsendTransaction\n if you only care about \nside effects\n on the state\nof the contract.\n\n\nIn the example above, there are no side effects, therefore\n\nsendTransaction\n only burns gas and increases the entropy of the\nuniverse.\n\n\nContract metadata\n\n\nIn the previous sections we explained how you create a contract on the\nblockchain. Now we will deal with the rest of the compiler output, the\n\ncontract metadata\n or contract info.\n\n\nWhen interacting with a contract you did not create you might want\ndocumentation or to look at the source code. Contract authors are\nencouraged to make such information available by registering it on the\nblockchain or through a third party service, such as\n\nEtherChain\n. The \nadmin\n API\nprovides convenience methods to fetch this bundle for any contract that\nchose to register.\n\n\n``` {.sourceCode .js}\n// get the contract info for contract address to do manual verification\nvar info = admin.getContractInfo(address) // lookup, fetch, decode\nvar source = info.source;\nvar abiDef = info.abiDefinition\n\nThe\n \nunderlying\n \nmechanism\n \nthat\n \nmakes\n \nthis\n \nwork\n \nis\n \nis\n \nthat\n:\n\n\n\n-\n   \ncontract\n \ninfo\n \nis\n \nuploaded\n \nsomewhere\n \nidentifiable\n \nby\n \na\n \n*\nURI\n*\n \nwhich\n \nis\n\n    \npublicly\n \naccessible\n\n\n-\n   \nanyone\n \ncan\n \nfind\n \nout\n \nwhat\n \nthe\n \n*\nURI\n*\n \nis\n \nonly\n \nknowing\n \nthe\n \ncontracts\n\n    \naddress\n\n\n\nThese\n \nrequirements\n \nare\n \nachieved\n \nusing\n \na\n \n2\n \nstep\n \nblockchain\n \nregistry\n.\n \nThe\n\n\nfirst\n \nstep\n \nregisters\n \nthe\n \ncontract\n \ncode\n \n(\nhash\n)\n \nwith\n \na\n \ncontent\n \nhash\n \nin\n \na\n\n\ncontract\n \ncalled\n \n`\nHashReg\n`\n.\n \nThe\n \nsecond\n \nstep\n \nregisters\n \na\n \nurl\n \nwith\n \nthe\n\n\ncontent\n \nhash\n \nin\n \nthe\n \n`\nUrlHint\n`\n \ncontract\n.\n \nThese\n \n[\nregistry\n\n\ncontracts\n](\nhttps\n:\n//github.com/ethereum/go-ethereum/blob/develop/common/registrar/contracts.go)\n\n\nwere\n \npart\n \nof\n \nthe\n \nFrontier\n \nrelease\n \nand\n \nhave\n \ncarried\n \non\n \ninto\n \nHomestead\n.\n\n\n\nBy\n \nusing\n \nthis\n \nscheme\n,\n \nit\n \nis\n \nsufficient\n \nto\n \nknow\n \na\n \ncontract\n\\\ns\n \naddress\n \nto\n\n\nlook\n \nup\n \nthe\n \nurl\n \nand\n \nfetch\n \nthe\n \nactual\n \ncontract\n \nmetadata\n \ninfo\n \nbundle\n.\n\n\n\nSo\n \nif\n \nyou\n \nare\n \na\n \nconscientious\n \ncontract\n \ncreator\n,\n \nthe\n \nsteps\n \nare\n \nthe\n\n\nfollowing\n:\n\n\n\n1.\n  \nDeploy\n \nthe\n \ncontract\n \nitself\n \nto\n \nthe\n \nblockchain\n\n\n2.\n  \nGet\n \nthe\n \ncontract\n \ninfo\n \njson\n \nfile\n.\n\n\n3.\n  \nDeploy\n \ncontract\n \ninfo\n \njson\n \nfile\n \nto\n \nany\n \nurl\n \nof\n \nyour\n \nchoice\n\n\n4.\n  \nRegister\n \ncodehash\n \n-\n\\\ncontent\n \nhash\n \n-\n\\\n \nurl\n\n\n\nThe\n \nJS\n \nAPI\n \nmakes\n \nthis\n \nprocess\n \nvery\n \neasy\n \nby\n \nproviding\n \nhelpers\n.\n \nCall\n\n\n`\nadmin\n.\nregister\n`\n \nto\n \nextract\n \ninfo\n \nfrom\n \nthe\n \ncontract\n,\n \nwrite\n \nout\n \nits\n \njson\n\n\nserialisation\n \nin\n \nthe\n \ngiven\n \nfile\n,\n \ncalculates\n \nthe\n \ncontent\n \nhash\n \nof\n \nthe\n \nfile\n\n\nand\n \nfinally\n \nregisters\n \nthis\n \ncontent\n \nhash\n \nto\n \nthe\n \ncontract\n\\\ns\n \ncode\n \nhash\n.\n\n\nOnce\n \nyou\n \ndeployed\n \nthat\n \nfile\n \nto\n \nany\n \nurl\n,\n \nyou\n \ncan\n \nuse\n \n`\nadmin\n.\nregisterUrl\n`\n\n\nto\n \nregister\n \nthe\n \nurl\n \nwith\n \nyour\n \ncontent\n \nhash\n \non\n \nthe\n \nblockchain\n \nas\n \nwell\n.\n\n\n(\nNote\n \nthat\n \nin\n \ncase\n \na\n \nfixed\n \ncontent\n \naddressed\n \nmodel\n \nis\n \nused\n \nas\n \ndocument\n\n\nstore\n,\n \nthe\n \nurl\n-\nhint\n \nis\n \nno\n \nlonger\n \nnecessary\n.)\n\n\n\n```\n \n{.\nsourceCode\n \n.\njs\n}\n\n\nsource\n \n=\n \ncontract test { function multiply(uint a) returns(uint d) { return a * 7; } }\n\n\n// compile with solc\n\n\ncontract\n \n=\n \neth\n.\ncompile\n.\nsolidity\n(\nsource\n).\ntest\n\n\n// create contract object\n\n\nvar\n \nMyContract\n \n=\n \neth\n.\ncontract\n(\ncontract\n.\ninfo\n.\nabiDefinition\n)\n\n\n// extracts info from contract, save the json serialisation in the given file,\n\n\ncontenthash\n \n=\n \nadmin\n.\nsaveInfo\n(\ncontract\n.\ninfo\n,\n \n~/dapps/shared/contracts/test/info.json\n)\n\n\n// send off the contract to the blockchain\n\n\nMyContract\n.\nnew\n({\nfrom\n:\n \nprimaryAccount\n,\n \ndata\n:\n \ncontract\n.\ncode\n},\n \nfunction\n(\nerror\n,\n \ncontract\n){\n\n  \nif\n(\n!\nerror\n \n \ncontract\n.\naddress\n)\n \n{\n\n    \n// calculates the content hash and registers it with the code hash in `HashReg`\n\n    \n// it uses address to send the transaction.\n\n    \n// returns the content hash that we use to register a url\n\n    \nadmin\n.\nregister\n(\nprimaryAccount\n,\n \ncontract\n.\naddress\n,\n \ncontenthash\n)\n\n    \n// here you deploy ~/dapps/shared/contracts/test/info.json to a url\n\n    \nadmin\n.\nregisterUrl\n(\nprimaryAccount\n,\n \nhash\n,\n \nurl\n)\n\n  \n}\n\n\n});\n\n\n\n\nTesting contracts and transactions\n\n\nOften you need to resort to a low level strategy of testing and\ndebugging contracts and transactions. This section introduces some debug\ntools and practices you can use. In order to test contracts and\ntransactions without real-word consequences, you best test it on a\nprivate blockchain. This can be achieved with configuring an alternative\nnetwork id (select a unique integer) and/or disable peers. It is\nrecommended practice that for testing you use an alternative data\ndirectory and ports so that you never even accidentally clash with your\nlive running node (assuming that runs using the defaults. Starting your\n\ngeth\n with in VM debug mode with profiling and highest logging\nverbosity level is recommended:\n\n\n``` {.sourceCode .bash}\ngeth --datadir ~/dapps/testing/00/ --port 30310 --rpcport 8110 --networkid 4567890 --nodiscover --maxpeers 0 --vmdebug --verbosity 6 --pprof --pprofport 6110 console 2\n ~/dapp/testint/00/00.log\n\nBefore\n \nyou\n \ncan\n \nsubmit\n \nany\n \ntransactions\n, \nyou\n \nneed\n \nset\n \nup\n \nyour\n \nprivate\n\n\ntest\n \nchain\n. \nSee\n [\ntest-networks\n]{\nrole\n=\nref\n}.\n\n``` {.\nsourceCode\n .\njs\n}\n// \ncreate\n \naccount\n. \nwill\n \nprompt\n \nfor\n \npassword\n\n\npersonal\n.\nnewAccount\n();\n// \nname\n \nyour\n \nprimary\n \naccount\n, \nwill\n \noften\n \nuse\n \nit\n\n\nprimary\n = \neth\n.\naccounts\n[\n0\n];\n// \ncheck\n \nyour\n \nbalance\n (\ndenominated\n \nin\n \nether\n)\n\nbalance\n = \nweb3\n.\nfromWei\n(\neth\n.\ngetBalance\n(\nprimary\n), \nether\n);\n\n\n\n``` {.sourceCode .js}\n// assume an existing unlocked primary account\nprimary = eth.accounts[0];\n\n\n// mine 10 blocks to generate ether\n\n\n// starting miner\nminer.start(4);\n// sleep for 10 blocks (this can take quite some time).\nadmin.sleepBlocks(10);\n// then stop mining (just not to burn heat in vain)\nminer.stop();\nbalance = web3.fromWei(eth.getBalance(primary), \"ether\");\n\nAfter you create transactions, you can force process them with the\nfollowing lines:\n\n``` {.sourceCode .js}\nminer.start(1);\nadmin.sleepBlocks(1);\nminer.stop();\n\n\n\nYou can check your pending transactions with:\n\n\n``` {.sourceCode .js}\n// shows transaction pool\ntxpool.status\n// number of pending txs\neth.getBlockTransactionCount(\"pending\");\n// print all pending txs\neth.getBlock(\"pending\", true).transactions\n\nIf you submitted contract creation transaction, you can check if the\ndesired code actually got inserted in the current blockchain:\n\n``` {.sourceCode .js}\ntxhash = eth.sendTansaction({from:primary, data: code})\n//... mining\ncontractaddress = eth.getTransactionReceipt(txhash);\neth.getCode(contractaddress)", 
            "title": "\u5408\u540c"
        }, 
        {
            "location": "/contracts-and-transactions/contracts/#contracts-contracts", 
            "text": "", 
            "title": "Contracts {#Contracts}"
        }, 
        {
            "location": "/contracts-and-transactions/contracts/#what-is-a-contract", 
            "text": "A contract is a collection of code (its functions) and data (its state)\nthat resides at a specific address on the Ethereum blockchain. Contract\naccounts are able to pass messages between themselves as well as doing\npractically Turing complete computation. Contracts live on the\nblockchain in a Ethereum-specific binary format called Ethereum Virtual\nMachine (EVM) bytecode.  Contracts are typically written in some high level language such as Solidity  and then\ncompiled into bytecode to be uploaded on the blockchain.  ::: {.seealso}\nOther languages also exist, notably Serpent and LLL, which are described\nfurther in the [ethereum-high-level-languages]{role=\"ref\"} section of\nthis documentation.\n:::  [IDE-or-development-framework]{role=\"ref\"} lists the integrated\ndevelopment environments, developer tools that help you develop in these\nlanguages, offering testing, and deployment support among other\nfeatures.", 
            "title": "What is a contract?"
        }, 
        {
            "location": "/contracts-and-transactions/contracts/#ethereum-high-level-languages", 
            "text": "Contracts live on the blockchain in an Ethereum-specific binary format\n(EVM bytecode) that is executed by the Ethereum Virtual Machine (EVM).\nHowever, contracts are typically written in a higher level language and\nthen compiled using the EVM compiler into byte code to be deployed to\nthe blockchain.  Below are the different high level languages developers can use to write\nsmart contracts for Ethereum.", 
            "title": "Ethereum high level languages"
        }, 
        {
            "location": "/contracts-and-transactions/contracts/#solidity", 
            "text": "Solidity is a language similar to JavaScript which allows you to develop\ncontracts and compile to EVM bytecode. It is currently the flagship\nlanguage of Ethereum and the most popular.   Solidity\n    Documentation  -\n    Solidity is the flagship Ethereum high level language that is used\n    to write contracts.  Solidity online realtime\n    compiler  Standardized Contract\n    APIs  Useful \u00d0app\n    Patterns  -\n    Code snippets which are useful for \u00d0app development.", 
            "title": "Solidity"
        }, 
        {
            "location": "/contracts-and-transactions/contracts/#serpent", 
            "text": "Serpent is a language similar to Python which can be used to develop\ncontracts and compile to EVM bytecode. It is intended to be maximally\nclean and simple, combining many of the efficiency benefits of a\nlow-level language with ease-of-use in programming style, and at the\nsame time adding special domain-specific features for contract\nprogramming. Serpent is compiled using _LLL.   Serpent on the ethereum\n    wiki  Serpent EVM compiler", 
            "title": "Serpent"
        }, 
        {
            "location": "/contracts-and-transactions/contracts/#lll", 
            "text": "Lisp Like Language\n(LLL)  is a\nlow level language similar to Assembly. It is meant to be very simple\nand minimalistic; essentially just a tiny wrapper over coding in EVM\ndirectly.   LIBLLL in\n    GitHub  Examples of\n    LLL", 
            "title": "LLL"
        }, 
        {
            "location": "/contracts-and-transactions/contracts/#mutan-deprecated", 
            "text": "Mutan  is a statically typed, C-like\nlanguage designed and developed by Jeffrey Wilcke. It is no longer\nmaintained.", 
            "title": "Mutan (deprecated)"
        }, 
        {
            "location": "/contracts-and-transactions/contracts/#writing-a-contract", 
            "text": "No language would be complete without a Hello World program. Operating\nwithin the Ethereum environment, Solidity has no obvious way of\n\\\"outputting\\\" a string. The closest we can do is to use a  log event \nto place a string into the blockchain:  ``` {.sourceCode .js}\ncontract HelloWorld {\n    event Print(string out);\n    function() { Print(\"Hello, World!\"); }\n} This   contract   will   create   a   log   entry   on   the   blockchain   of   type   Print  with   a   parameter   \\ Hello, World!\\  each time it is executed.  ::: {.seealso}  [Solidity docs](https://solidity.readthedocs.org/en/latest/) has more  examples and guidelines to writing Solidity code.  :::  Compiling a contract  --------------------  Compilation of solidity contracts can be accomplished via a number of  mechanisms.  -   Using the `solc` compiler via the command line.  -   Using `web3.eth.compile.solidity` in the javascript console provided      by `geth` or `eth` (This still requires the `solc` compiler to be      installed).  -   The [online Solidity realtime      compiler](https://ethereum.github.io/browser-solidity/).  -   The [Meteor dapp Cosmo for building solidity      contracts](https://github.com/SilentCicero/meteor-dapp-cosmo).  -   The [Mix      IDE](https://github.com/ethereum/wiki/wiki/Mix:-The-DApp-IDE).  -   The [Ethereum Wallet](https://github.com/ethereum/mist/releases).  ::: {.note}  ::: {.admonition-title}  Note  :::  More information on solc and compiling Solidity contract code can be  found  [here](https://solidity.readthedocs.org/en/latest/frequently-asked-questions.html#how-do-i-compile-contracts).  :::  ### Setting up the solidity compiler in geth  If you start up your `geth` node, you can check which compilers are  available.  ``` {.sourceCode .bash}   web3.eth.getCompilers();  [ lll ,  solidity ,  serpent ]   This command returns an array of strings indicating which compilers are\ncurrently available.  ::: {.note}\n::: {.admonition-title}\nNote\n:::  The  solc  compiler is installed with  cpp-ethereum . Alternatively, you\ncan  build it\nyourself .\n:::  If your  solc  executable is in a non-standard location you can specify\na custom path to the  solc  executable using th  --solc  flag.  ``` {.sourceCode .bash}\n$ geth --solc /usr/local/bin/solc Alternatively, you can set this option at runtime via the console:\n\n``` {.sourceCode .bash}  admin.setSolc( /usr/local/bin/solc )\nsolc, the solidity compiler commandline interface\nVersion: 0.2.2-02bb315d/.-Darwin/appleclang/JIT linked to libethereum-1.2.0-8007cef0/.-Darwin/appleclang/JIT\npath: /usr/local/bin/solc", 
            "title": "Writing a contract"
        }, 
        {
            "location": "/contracts-and-transactions/contracts/#compiling-a-simple-contract-compile_a_simple_contract", 
            "text": "Let\\'s compile a simple contract source:  ``` {.sourceCode .bash}   source = \"contract test { function multiply(uint a) returns(uint d) { return a * 7; } }\" This   contract   offers   a   single   method   ** multiply **   which   is   called   with   a  positive   integer   ` a `   and   returns   ` a   *   7 ` .  You   are   ready   to   compile   solidity   code   in   the   ` geth `   JS   console   using  [ eth.compile.solidity () ] ( https :// github . com / ethereum / wiki / wiki / JavaScript-API # web3ethcompilesolidity ):  ```   { .sourceCode   .bash }    contract   =   eth . compile . solidity ( source ) . test  { \n   code :   605280600c6000396000f3006000357c010000000000000000000000000000000000000000000000000000000090048063c6888fa114602e57005b60376004356041565b8060005260206000f35b6000600782029050604d565b91905056 , \n   info :   { \n     language :   Solidity , \n     languageVersion :   0 , \n     compilerVersion :   0.9.13 , \n     abiDefinition :   [ { \n       constant :   false , \n       inputs :   [ { \n         name :   a , \n         type :   uint256 \n       }   ] , \n       name :   multiply , \n       outputs :   [ { \n         name :   d , \n         type :   uint256 \n       }   ] , \n       type :   function \n     }   ], \n     userDoc :   { \n       methods :   { \n       } \n     } , \n     developerDoc :   { \n       methods :   { \n       } \n     } , \n     source :   contract test { function multiply(uint a) returns(uint d) { return a * 7; } } \n   }  }    ::: {.note}\n::: {.admonition-title}\nNote\n:::  The compiler is also available via RPC  and therefore via\nweb3\\.js \\ https://github.com/ethereum/wiki/wiki/JavaScript\n API#web3ethcompilesolidity>__ to any in-browser \u00d0app connecting to geth  via RPC/IPC.\n:::  The following example shows how you interface  geth  via JSON-RPC to use\nthe compiler.  ``` {.sourceCode .bash}\n$ geth --datadir ~/eth/ --loglevel 6 --logtostderr=true --rpc --rpcport 8100 --rpccorsdomain '*' --mine console  2  ~/eth/eth.log\n$ curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_compileSolidity\",\"params\":[\"contract test { function multiply(uint a) returns(uint d) { return a * 7; } }\"],\"id\":1}' http://127.0.0.1:8100 The   compiler   output   for   one   source   will   give   you   contract   objects   each  representing   a   single   contract .   The   actual   return   value   of  ` eth . compile . solidity `   is   a   map   of   contract   name   to   contract   object  pairs .   Since   our   contract \\ s   name   is   ` test ` ,  ` eth . compile . solidity ( source ). test `   will   give   you   the   contract   object  for   the   test   contract   containing   the   following   fields :  :::   {. glossary }  ` code `  :     The   compiled   EVM   bytecode  ` info `  :     Additional   metadata   output   from   the   compiler  ` source `  :     The   source   code  ` language `  :     The   contract   language   ( Solidity ,   Serpent ,   LLL )  ` languageVersion `  :     The   contract   language   version  ` compilerVersion `  :     The   solidity   compiler   version   that   was   used   to   compile   this \n     contract .  ` abiDefinition `  :     The   [ Application   Binary   Interface \n     Definition ]( https : //github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI)  ` userDoc `  :     The   [ NatSpec \n     Doc ]( https : //github.com/ethereum/wiki/wiki/Ethereum-Natural-Specification-Format) \n     for   users .  ` developerDoc `  :     The   [ NatSpec \n     Doc ]( https : //github.com/ethereum/wiki/wiki/Ethereum-Natural-Specification-Format) \n     for   developers .  :::  The   immediate   structuring   of   the   compiler   output   ( into   ` code `   and  ` info ` )   reflects   the   two   very   different   ** paths   of   deployment ** .   The  compiled   EVM   code   is   sent   off   to   the   blockchain   with   a   contract   creation  transaction   while   the   rest   ( info )   will   ideally   live   on   the   decentralised  cloud   as   publicly   verifiable   metadata   complementing   the   code   on   the  blockchain .  If   your   source   contains   multiple   contracts ,   the   output   will   contain   an  entry   for   each   contract ,   the   corresponding   contract   info   object   can   be  retrieved   with   the   name   of   the   contract   as   attribute   name .   You   can   try  this   by   inspecting   the   most   current   GlobalRegistrar   code :  ```   {. sourceCode   . js }  contracts   =   eth . compile . solidity ( globalRegistrarSrc )", 
            "title": "Compiling a simple contract {#compile_a_simple_contract}"
        }, 
        {
            "location": "/contracts-and-transactions/contracts/#create-and-deploy-a-contract", 
            "text": "Before you begin this section, make sure you have both an unlocked\naccount as well as some funds.  You will now create a contract on the blockchain by  sending a\ntransaction \nto the empty address with the EVM code from the previous section as\ndata.  ::: {.note}\n::: {.admonition-title}\nNote\n:::  This can be accomplished much easier using the  online Solidity realtime\ncompiler  or the  Mix\nIDE  program.\n:::  ``` {.sourceCode .js}\nvar primaryAddress = eth.accounts[0]\nvar abi = [{ constant: false, inputs: { name: 'a', type: 'uint256' } }]\nvar MyContract = eth.contract(abi)\nvar contract = MyContract.new(arg1, arg2, ..., {from: primaryAddress, data: evmByteCodeFromPreviousSection}) All binary data is serialised in hexadecimal form. Hex strings always\nhave a hex prefix `0x`.\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\nNote that `arg1, arg2, ...` are the arguments for the contract\nconstructor, in case it accepts any. If the contract does not require\nany constructor arguments then these arguments can be omitted.\n:::\n\nIt is worth pointing out that this step requires you to pay for\nexecution. Your balance on the account (that you put as sender in the\n`from` field) will be reduced according to the gas rules of the EVM once\nyour transaction makes it into a block. After some time, your\ntransaction should appear included in a block confirming that the state\nit brought about is a consensus. Your contract now lives on the\nblockchain.\n\nThe asynchronous way of doing the same looks like this:\n\n``` {.sourceCode .js}\nMyContract.new([arg1, arg2, ...,]{from: primaryAccount, data: evmCode}, function(err, contract) {\n  if (!err   contract.address)\n    console.log(contract.address);\n});", 
            "title": "Create and deploy a contract"
        }, 
        {
            "location": "/contracts-and-transactions/contracts/#interacting-with-a-contract-interacting_with_a_contract", 
            "text": "Interaction with a contract is typically done using an abstraction layer\nsuch as the eth.contract() \nfunction which returns a javascript object with all of the contract\nfunctions available as callable functions in javascript.  The standard way to describe the available functions of a contract is\nthe  ABI\ndefinition .\nThis object is an array which describles the call signature and return\nvalues for each available contract function.  ``` {.sourceCode .js}\nvar Multiply7 = eth.contract(contract.info.abiDefinition);\nvar myMultiply7 = Multiply7.at(address); Now all the function calls specified in the ABI are made available on\nthe contract instance. You can just call those methods on the contract\ninstance in one of two ways.\n\n``` {.sourceCode .js}  myMultiply7.multiply.sendTransaction(3, {from: address}) 0x12345   myMultiply7.multiply.call(3)\n21  When called using  sendTransaction  the function call is executed via\nsending a transaction. This will cost ether to send and the call will be\nrecorded forever on the blockchain. The return value of calls made in\nthis manner is the hash of the transaction.  When called using  call  the function is executed locally in the EVM and\nthe return value of the function is returned with the function. Calls\nmade in this manner are not recorded on the blockchain and thus, cannot\nmodify the internal state of the contract. This manner of call is\nreferred to as a  constant  function call. Calls made in this manner\ndo not cost any ether.  You should use  call  if you are interested only in the return value and\nuse  sendTransaction  if you only care about  side effects  on the state\nof the contract.  In the example above, there are no side effects, therefore sendTransaction  only burns gas and increases the entropy of the\nuniverse.", 
            "title": "Interacting with a contract {#interacting_with_a_contract}"
        }, 
        {
            "location": "/contracts-and-transactions/contracts/#contract-metadata", 
            "text": "In the previous sections we explained how you create a contract on the\nblockchain. Now we will deal with the rest of the compiler output, the contract metadata  or contract info.  When interacting with a contract you did not create you might want\ndocumentation or to look at the source code. Contract authors are\nencouraged to make such information available by registering it on the\nblockchain or through a third party service, such as EtherChain . The  admin  API\nprovides convenience methods to fetch this bundle for any contract that\nchose to register.  ``` {.sourceCode .js}\n// get the contract info for contract address to do manual verification\nvar info = admin.getContractInfo(address) // lookup, fetch, decode\nvar source = info.source;\nvar abiDef = info.abiDefinition The   underlying   mechanism   that   makes   this   work   is   is   that :  -     contract   info   is   uploaded   somewhere   identifiable   by   a   * URI *   which   is \n     publicly   accessible  -     anyone   can   find   out   what   the   * URI *   is   only   knowing   the   contracts \n     address  These   requirements   are   achieved   using   a   2   step   blockchain   registry .   The  first   step   registers   the   contract   code   ( hash )   with   a   content   hash   in   a  contract   called   ` HashReg ` .   The   second   step   registers   a   url   with   the  content   hash   in   the   ` UrlHint `   contract .   These   [ registry  contracts ]( https : //github.com/ethereum/go-ethereum/blob/develop/common/registrar/contracts.go)  were   part   of   the   Frontier   release   and   have   carried   on   into   Homestead .  By   using   this   scheme ,   it   is   sufficient   to   know   a   contract \\ s   address   to  look   up   the   url   and   fetch   the   actual   contract   metadata   info   bundle .  So   if   you   are   a   conscientious   contract   creator ,   the   steps   are   the  following :  1.    Deploy   the   contract   itself   to   the   blockchain  2.    Get   the   contract   info   json   file .  3.    Deploy   contract   info   json   file   to   any   url   of   your   choice  4.    Register   codehash   - \\ content   hash   - \\   url  The   JS   API   makes   this   process   very   easy   by   providing   helpers .   Call  ` admin . register `   to   extract   info   from   the   contract ,   write   out   its   json  serialisation   in   the   given   file ,   calculates   the   content   hash   of   the   file  and   finally   registers   this   content   hash   to   the   contract \\ s   code   hash .  Once   you   deployed   that   file   to   any   url ,   you   can   use   ` admin . registerUrl `  to   register   the   url   with   your   content   hash   on   the   blockchain   as   well .  ( Note   that   in   case   a   fixed   content   addressed   model   is   used   as   document  store ,   the   url - hint   is   no   longer   necessary .)  ```   {. sourceCode   . js }  source   =   contract test { function multiply(uint a) returns(uint d) { return a * 7; } }  // compile with solc  contract   =   eth . compile . solidity ( source ). test  // create contract object  var   MyContract   =   eth . contract ( contract . info . abiDefinition )  // extracts info from contract, save the json serialisation in the given file,  contenthash   =   admin . saveInfo ( contract . info ,   ~/dapps/shared/contracts/test/info.json )  // send off the contract to the blockchain  MyContract . new ({ from :   primaryAccount ,   data :   contract . code },   function ( error ,   contract ){ \n   if ( ! error     contract . address )   { \n     // calculates the content hash and registers it with the code hash in `HashReg` \n     // it uses address to send the transaction. \n     // returns the content hash that we use to register a url \n     admin . register ( primaryAccount ,   contract . address ,   contenthash ) \n     // here you deploy ~/dapps/shared/contracts/test/info.json to a url \n     admin . registerUrl ( primaryAccount ,   hash ,   url ) \n   }  });", 
            "title": "Contract metadata"
        }, 
        {
            "location": "/contracts-and-transactions/contracts/#testing-contracts-and-transactions", 
            "text": "Often you need to resort to a low level strategy of testing and\ndebugging contracts and transactions. This section introduces some debug\ntools and practices you can use. In order to test contracts and\ntransactions without real-word consequences, you best test it on a\nprivate blockchain. This can be achieved with configuring an alternative\nnetwork id (select a unique integer) and/or disable peers. It is\nrecommended practice that for testing you use an alternative data\ndirectory and ports so that you never even accidentally clash with your\nlive running node (assuming that runs using the defaults. Starting your geth  with in VM debug mode with profiling and highest logging\nverbosity level is recommended:  ``` {.sourceCode .bash}\ngeth --datadir ~/dapps/testing/00/ --port 30310 --rpcport 8110 --networkid 4567890 --nodiscover --maxpeers 0 --vmdebug --verbosity 6 --pprof --pprofport 6110 console 2  ~/dapp/testint/00/00.log Before   you   can   submit   any   transactions ,  you   need   set   up   your   private  test   chain .  See  [ test-networks ]{ role = ref }.\n\n``` {. sourceCode  . js }\n//  create   account .  will   prompt   for   password  personal . newAccount ();\n//  name   your   primary   account ,  will   often   use   it  primary  =  eth . accounts [ 0 ];\n//  check   your   balance  ( denominated   in   ether ) balance  =  web3 . fromWei ( eth . getBalance ( primary ),  ether );  ``` {.sourceCode .js}\n// assume an existing unlocked primary account\nprimary = eth.accounts[0];  // mine 10 blocks to generate ether  // starting miner\nminer.start(4);\n// sleep for 10 blocks (this can take quite some time).\nadmin.sleepBlocks(10);\n// then stop mining (just not to burn heat in vain)\nminer.stop();\nbalance = web3.fromWei(eth.getBalance(primary), \"ether\"); After you create transactions, you can force process them with the\nfollowing lines:\n\n``` {.sourceCode .js}\nminer.start(1);\nadmin.sleepBlocks(1);\nminer.stop();  You can check your pending transactions with:  ``` {.sourceCode .js}\n// shows transaction pool\ntxpool.status\n// number of pending txs\neth.getBlockTransactionCount(\"pending\");\n// print all pending txs\neth.getBlock(\"pending\", true).transactions If you submitted contract creation transaction, you can check if the\ndesired code actually got inserted in the current blockchain:\n\n``` {.sourceCode .js}\ntxhash = eth.sendTansaction({from:primary, data: code})\n//... mining\ncontractaddress = eth.getTransactionReceipt(txhash);\neth.getCode(contractaddress)", 
            "title": "Testing contracts and transactions"
        }, 
        {
            "location": "/contracts-and-transactions/accessing-contracts-and-transactions/", 
            "text": "Accessing Contracts and Transactions {#Accessing Contracts and Transactions}\n\n\nRPC\n\n\nIn previous sections we have seen how contracts can be written, deployed\nand interacted with. Now it\\'s time to dive in the details of\ncommunicating with the Ethereum network and smart contracts.\n\n\nAn Ethereum node offers a\n\nRPC\n interface. This\ninterface gives \u00d0app\\'s access to the Ethereum blockchain and\nfunctionality that the node provides, such as compiling smart contract\ncode. It uses a subset of the \nJSON-RPC\n2.0\n specification (no support for\nnotifications or named parameters) as serialisation protocol and is\navailable over HTTP and IPC (unix domain sockets on linux/OSX and named\npipe\\'s on Windows).\n\n\nIf you are not interested in the details but are looking for an easy to\nuse javascript library you can skip the following sections and continue\nwith [Using Web3 \\\nusing_web3.js>]{role=\"ref\"}.\n\n\nConventions\n\n\nThe RPC interface uses a couple of conventions that are not part of the\nJSON-RPC 2.0 specification:\n\n\n\n\nNumbers are hex encoded. This decision was made because some\n    languages have no or limited support for working with extremly large\n    numbers. To prevent these type of errors numbers are hex encoded and\n    it is up to the developer to parse these numbers and handle them\n    appropriately. See the \nhex encoding\n    section\n\n    on the wiki for examples.\n\n\nDefault block number, several RPC methods accept a block number. In\n    some cases it\\'s not possible to give a block number or not very\n    convenient. For these cases the default block number can be one of\n    these strings [\\\"earliest\\\", \\\"latest\\\", \\\"pending\\\"]. See the\n    \nwiki\n    page\n\n    for a list of RPC methods that use the default block parameters.\n\n\n\n\nDeploy contract\n\n\nWe will go through the different steps to deploy the following contract\nusing only the RPC interface.\n\n\n``` {.sourceCode .js}\ncontract Multiply7 {\n   event Print(uint);\n   function multiply(uint input) returns (uint) {\n      Print(input * 7);\n      return input * 7;\n   }\n}\n\nThe first thing to do is make sure the HTTP RPC interface is enabled.\nThis means for geth we supply the `--rpc` flag on startup and for eth\nthe `-j` flag. In this example we use the geth node on a private\ndevelopment chain. Using this approach we don\\\nt need ether on the real\nnetwork.\n\n``` {.sourceCode .bash}\n\n geth --rpc --dev --mine --minerthreads 1 --unlock 0 console 2\ngeth.log\n\n\n\nThis will start the HTTP RPC interface on \nhttp://localhost:8545\n.\n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\ngeth supports\n\nCORS\n, see\nthe \n--rpccorsdomain\n flag for more information.\n:::\n\n\nWe can verify that the interface is running by retrieving the coinbase\naddress and balance using \ncurl\n.\nPlease note that data in these examples will differ on your local node.\nIf you want to try these command replace the request params accordingly.\n\n\n``` {.sourceCode .bash}\n\n\n\n\ncurl --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_coinbase\", \"id\":1}' -H \"Content-Type: application/json\" localhost:8545\n{\"id\":1,\"jsonrpc\":\"2.0\",\"result\":[\"0x9b1d35635cc34752ca54713bb99d38614f63c955\"]}\n\n\ncurl --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBalance\", \"params\": [\"0x9b1d35635cc34752ca54713bb99d38614f63c955\", \"latest\"], \"id\":2}' -H \"Content-Type: application/json\" localhost:8545\n{\"id\":2,\"jsonrpc\":\"2.0\",\"result\":\"0x1639e49bba16280000\"}\n\nRemember when we said that numbers are hex encoded? In this case the\nbalance is returned in wei as a hex string. If we want to have the\nbalance in ether as a number we can use web3 from the geth console.\n\n``` {.sourceCode .js}\n\n web3.fromWei(\n0x1639e49bba16280000\n, \nether\n)\n\n410\n\n\n\n\n\n\nNow that we have some ether on our private development chain we can\ndeploy the contract. The first step is to compile the Multiply7 contract\nto byte code that can be sent to the EVM. Follow these\n\nthese\n\ninstructions to install solc, the solidity compiler.\n\n\nThe next step is to compile the Multiply7 contract to byte code that can\nbe send to the EVM.\n\n\n``` {.sourceCode .bash}\n\n\n\n\necho 'pragma solidity ^0.4.16; contract Multiply7 { event Print(uint); function multiply(uint input) public returns (uint) { Print(input * 7); return input * 7; } }' | solc --bin\n======= \n:Multiply7 =======\nBinary: \n6060604052341561000f57600080fd5b60eb8061001d6000396000f300606060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063c6888fa1146044575b600080fd5b3415604e57600080fd5b606260048080359060200190919050506078565b6040518082815260200191505060405180910390f35b60007f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da600783026040518082815260200191505060405180910390a16007820290509190505600a165627a7a7230582040383f19d9f65246752244189b02f56e8d0980ed44e7a56c0b200458caad20bb0029\n\nNow that we have the compiled code we need to determine how much gas it\ncosts to deploy it. The RPC interface has an `eth_estimateGas` method\nthat will give us an estimate.\n\n``` {.sourceCode .bash}\n\n curl --data \n{\njsonrpc\n:\n2.0\n,\nmethod\n: \neth_estimateGas\n, \nparams\n: [{\nfrom\n: \n0x9b1d35635cc34752ca54713bb99d38614f63c955\n, \ndata\n: \n0x6060604052341561000f57600080fd5b60eb8061001d6000396000f300606060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063c6888fa1146044575b600080fd5b3415604e57600080fd5b606260048080359060200190919050506078565b6040518082815260200191505060405180910390f35b60007f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da600783026040518082815260200191505060405180910390a16007820290509190505600a165627a7a7230582040383f19d9f65246752244189b02f56e8d0980ed44e7a56c0b200458caad20bb0029\n}], \nid\n: 5}\n -H \nContent-Type: application/json\n localhost:8545\n{\njsonrpc\n:\n2.0\n,\nid\n:5,\nresult\n:\n0x1c31e\n}\n\n\n\n\n\nAnd finally deploy the contract.\n\n\n``` {.sourceCode .bash}\n\n\n\n\ncurl --data '{\"jsonrpc\":\"2.0\",\"method\": \"eth_sendTransaction\", \"params\": [{\"from\": \"0x9b1d35635cc34752ca54713bb99d38614f63c955\", \"gas\": \"0x1c31e\", \"data\": \"0x6060604052341561000f57600080fd5b60eb8061001d6000396000f300606060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063c6888fa1146044575b600080fd5b3415604e57600080fd5b606260048080359060200190919050506078565b6040518082815260200191505060405180910390f35b60007f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da600783026040518082815260200191505060405180910390a16007820290509190505600a165627a7a7230582040383f19d9f65246752244189b02f56e8d0980ed44e7a56c0b200458caad20bb0029\"}], \"id\": 6}' -H \"Content-Type: application/json\" localhost:8545\n{\"id\":6,\"jsonrpc\":\"2.0\",\"result\":\"0xe1f3095770633ab2b18081658bad475439f6a08c902d0915903bafff06e6febf\"}\n\nThe transaction is accepted by the node and a transaction hash is\nreturned. We can use this hash to track the transaction.\n\nThe next step is to determine the address where our contract is\ndeployed. Each executed transaction will create a receipt. This receipt\ncontains various information about the transaction such as in which\nblock the transaction was included and how much gas was used by the EVM.\nIf a transaction creates a contract it will also contain the contract\naddress. We can retrieve the receipt with the\n`eth_getTransactionReceipt` RPC method.\n\n``` {.sourceCode .bash}\n\n curl --data \n{\njsonrpc\n:\n2.0\n,\nmethod\n: \neth_getTransactionReceipt\n, \nparams\n: [\n0xe1f3095770633ab2b18081658bad475439f6a08c902d0915903bafff06e6febf\n], \nid\n: 7}\n -H \nContent-Type: application/json\n localhost:8545\n{\njsonrpc\n:\n2.0\n,\nid\n:7,\nresult\n:{\nblockHash\n:\n0x77b1a4f6872b9066312de3744f60020cbd8102af68b1f6512a05b7619d527a4f\n,\nblockNumber\n:\n0x1\n,\ncontractAddress\n:\n0x4d03d617d700cf81935d7f797f4e2ae719648262\n,\ncumulativeGasUsed\n:\n0x1c31e\n,\nfrom\n:\n0x9b1d35635cc34752ca54713bb99d38614f63c955\n,\ngasUsed\n:\n0x1c31e\n,\nlogs\n:[],\nlogsBloom\n:\n0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n,\nstatus\n:\n0x1\n,\nto\n:null,\ntransactionHash\n:\n0xe1f3095770633ab2b18081658bad475439f6a08c902d0915903bafff06e6febf\n,\ntransactionIndex\n:\n0x0\n}}\n\n\n\n\n\nWe can see that our contract was created on\n\n0x4d03d617d700cf81935d7f797f4e2ae719648262\n. If you got null instead of\na receipt the transaction has not been included in a block yet. Wait for\na moment and check if your miner is running and retry it.\n\n\nInteracting with smart contracts\n\n\nNow that our contract is deployed we can interact with it. There are 2\nmethods for this, sending a transaction or\n[using call as previously explained \\\ninteracting_with_a_contract>]{role=\"ref\"}.\nIn this example we will be sending a transaction to the multiply method\nof the contract.\n\n\nIf we look at the documentation for the\n\neth_sendTransaction\n\nwe can see that we need to supply several arguments. In our case we need\nto specify the \nfrom\n, \nto\n and \ndata\n arguments. \nFrom\n is the public\naddress of our account and \nto\n the contract address. The \ndata\n\nargument is a bit harder. It contains a payload that defines which\nmethod must be called and with which arguments. This is were the ABI\ncomes into play. The ABI defines how to define and encode data for the\nEVM. You can read \nall the details about the ABI\nhere\n.\n\n\nThe bytes of the payload is the function selector and defines which\nmethod is called. This is done by taking the first 4 bytes from the\nKeccak hash over the function name and its argument types and hex encode\nit. The multiply function accepts an uint which is an\n\nalias\n\nfor uint256. This leaves us with:\n\n\n``` {.sourceCode .js}\n\n\n\n\nweb3.sha3(\"multiply(uint256)\").substring(0, 10)\n\"0xc6888fa1\"\n\nSee\n \nfor\n \ndetails\n \n[\nthis\n\n\npage\n](\nhttps\n:\n//github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#function-selector).\n\n\n\nThe\n \nnext\n \nstep\n \nis\n \nto\n \nencode\n \nthe\n \narguments\n.\n \nWe\n \nonly\n \nhave\n \none\n \nuint256\n,\n \nlets\n\n\nassume\n \nwe\n \nsupply\n \nthe\n \nvalue\n \n6.\n \nThe\n \nABI\n \nhas\n \na\n\n\n[\nsection\n](\nhttps\n:\n//github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#argument-encoding)\n\n\nwhich\n \nspecifies\n \nhow\n \nto\n \nencode\n \nuint256\n \ntypes\n.\n\n\n\n \nint\n\\\nM\n\\\n:\n \nenc\n(\nX\n)\n \nis\n \nthe\n \nbig\n-\nendian\n \ntwo\n\\\ns\n \ncomplement\n \nencoding\n \nof\n \nX\n,\n \npadded\n \non\n \nthe\n \nhigher\n-\noder\n \n(\nleft\n)\n \nside\n \nwith\n \n0xff\n \nfor\n \nnegative\n \nX\n \nand\n \nwith\n \nzero\n \nbytes\n\n\n \nfor\n \npositive\n \nX\n \nsuch\n \nthat\n \nthe\n \nlength\n \nis\n \na\n \nmultiple\n \nof\n \n32\n \nbytes\n.\n\n\n\nThis\n \nencodes\n \nto\n\n\n`\n0000000000000000000000000000000000000000000000000000000000000006\n`\n.\n\n\n\nCombining\n \nthe\n \nfunction\n \nselector\n \nand\n \nthe\n \nencoded\n \nargument\n \nour\n \n`\ndata\n`\n \nwill\n\n\nbe\n\n\n`\n0xc6888fa10000000000000000000000000000000000000000000000000000000000000006\n`\n.\n\n\n\nLets\n \ntry\n \nit\n:\n\n\n\n```\n \n{.\nsourceCode\n \n.\nbash\n}\n\n\n \ncurl\n \n--\ndata\n \n{\njsonrpc\n:\n2.0\n,\nmethod\n:\n \neth_sendTransaction\n,\n \nparams\n:\n \n[{\nfrom\n:\n \n0x9b1d35635cc34752ca54713bb99d38614f63c955\n,\n \nto\n:\n \n0x4d03d617d700cf81935d7f797f4e2ae719648262\n,\n \ndata\n:\n \n0xc6888fa10000000000000000000000000000000000000000000000000000000000000006\n}],\n \nid\n:\n \n8\n}\n \n-\nH\n \nContent-Type: application/json\n \nlocalhost\n:\n8545\n\n\n{\nid\n:\n8\n,\njsonrpc\n:\n2.0\n,\nresult\n:\n0x50905bea8043e1166703a2a72390f6e6eb4f23150c8e7d13094a6d82ce89a054\n}\n\n\n\n\n\n\nSince we sent a transaction we got the transaction hash returned. If we\nretrieve the receipt we can see something new:\n\n\n``` {.sourceCode .js}\n{\n  blockHash: \"0x55262092dc46db5c7d3595decd4317780896c765c4db69cf2d5f650e46249b13\",\n  blockNumber: 6,\n  contractAddress: null,\n  cumulativeGasUsed: 22774,\n  from: \"0x9b1d35635cc34752ca54713bb99d38614f63c955\",\n  gasUsed: 22774,\n  logs: [{\n      address: \"0x4d03d617d700cf81935d7f797f4e2ae719648262\",\n      blockHash: \"0x55262092dc46db5c7d3595decd4317780896c765c4db69cf2d5f650e46249b13\",\n      blockNumber: 6,\n      data: \"0x000000000000000000000000000000000000000000000000000000000000002a\",\n      logIndex: 0,\n      removed: false,\n      topics: [\"0x24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da\"],\n      transactionHash: \"0x50905bea8043e1166703a2a72390f6e6eb4f23150c8e7d13094a6d82ce89a054\",\n      transactionIndex: 0\n  }],\n  logsBloom: \"0x00000000000008000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000020800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n  status: \"0x1\",\n  to: \"0x4d03d617d700cf81935d7f797f4e2ae719648262\",\n  transactionHash: \"0x50905bea8043e1166703a2a72390f6e6eb4f23150c8e7d13094a6d82ce89a054\",\n  transactionIndex: 0\n}\n\nThe receipt contains a log. This log was generated by the EVM on\ntransaction execution and included in the receipt. If we look at the\nmultipy function we can see that the Print event was raised with the\ninput times 7. Since the argument for the Print event was a uint256 we\ncan decode it according to the ABI rules which will leave us with the\nexpected decimal 42.\n\n``` {.sourceCode .bash}\n\n echo $((0x000000000000000000000000000000000000000000000000000000000000002a))\n42\n\n\n\nApart from the data it is worth noting that topics can be used to\ndetermine which event created the log:\n\n\n``` {.sourceCode .js}\n\n\n\n\nweb3.sha3(\"Print(uint256)\")\n\"24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da\"\n\nYou\n \ncan\n \nread\n \nmore\n \nabout\n \nevents\n,\n \ntopics\n \nand\n \nindexing\n \nin\n \nthe\n \n[\nSolidity\n\n\ntutorial\n](\nhttp\n:\n//solidity.readthedocs.org/en/latest/contracts.html#events).\n\n\n\nThis\n \nwas\n \njust\n \na\n \nbrief\n \nintroduction\n \ninto\n \nsome\n \nof\n \nthe\n \nmost\n \ncommon\n \ntasks\n.\n\n\nSee\n \nfor\n \na\n \nfull\n \nlist\n \nof\n \navailable\n \nRPC\n \nmethods\n \nthe\n \n[\nRPC\n \nwiki\n\n\npage\n](\nhttps\n:\n//github.com/ethereum/wiki/wiki/JSON-RPC#json-rpc-methods).\n\n\n\nWeb3\n.\njs\n \n{\n#\nusing_web3\n.\njs\n}\n\n\n-------\n\n\n\nAs\n \nwe\n \nhave\n \nseen\n \nin\n \nthe\n \nprevious\n \nexample\n \nusing\n \nthe\n \nJSON\n-\nRPC\n \ninterface\n \ncan\n\n\nbe\n \nquite\n \ntedious\n \nand\n \nerror\n-\nprone\n,\n \nespecially\n \nwhen\n \nwe\n \nhave\n \nto\n \ndeal\n \nwith\n\n\nthe\n \nABI\n.\n \nWeb3\n.\njs\n \nis\n \na\n \njavascript\n \nlibrary\n \nthat\n \nworks\n \non\n \ntop\n \nof\n \nthe\n\n\nEthereum\n \nRPC\n \ninterface\n.\n \nIts\n \ngoal\n \nis\n \nto\n \nprovide\n \na\n \nmore\n \nuser\n \nfriendly\n\n\ninterface\n \nand\n \nreducing\n \nthe\n \nchance\n \nfor\n \nerrors\n.\n\n\n\nDeploying\n \nthe\n \nMultiply7\n \ncontract\n \nusing\n \nweb3\n \nwould\n \nlook\n \nlike\n:\n\n\n\n``` {.sourceCode .js}\n\n\nvar source = \ncontract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input * 7); return input * 7; } }\n;\n\n\nvar compiled = web3.eth.compile.solidity(source);\n\n\nvar code = compiled.Multiply7.code;\n\n\nvar abi = compiled.Multiply7.info.abiDefinition;\n\n\n\nweb3.eth.contract(abi).new({from: \n0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a\n, data: code}, function (err, contract) {\n\n\n   if (!err \n contract.address)\n\n\n      console.log(\ndeployed on:\n, contract.address);\n\n\n   }\n\n\n);\n\n\n\ndeployed on: 0x0ab60714033847ad7f0677cc7514db48313976e2\n\n\n\n\n\n\nLoad a deployed contract and send a transaction:\n\n\n``` {.sourceCode .js}\nvar source = 'contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input * 7); return input * 7; } }';\nvar compiled = web3.eth.compile.solidity(source);\nvar Multiply7 = web3.eth.contract(compiled.Multiply7.info.abiDefinition);\nvar multi = Multiply7.at(\"0x0ab60714033847ad7f0677cc7514db48313976e2\")\nmulti.multiply.sendTransaction(6, {from: \"0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a\"})\n\nRegister a callback which is called when the `Print` event created a\nlog.\n\n``` {.sourceCode .js}\nmulti.Print(function(err, data) { console.log(JSON.stringify(data)) })\n{\naddress\n:\n0x0ab60714033847ad7f0677cc7514db48313976e2\n,\nargs\n: {\n:\n21\n},\nblockHash\n:\n0x259c7dc07c99eed9dd884dcaf3e00a81b2a1c83df2d9855ce14c464b59f0c8b3\n,\nblockNumber\n:539,\nevent\n:\nPrint\n,\nlogIndex\n:0, \ntransactionHash\n:\n0x5c115aaa5418118457e96d3c44a3b66fe9f2bead630d79455d0ecd832dc88d48\n,\ntransactionIndex\n:0}\n\n\n\nSee for more information the\n\nweb3.js\n wiki\npage.\n\n\nConsole\n\n\nThe geth\n\nconsole\n\noffers a command line interface with a javascript runtime. It can\nconnect to a local or remote geth or eth node. It will load the web3.js\nlibrary that users can use. This allows users to deploy and interact\nwith smart contract from the console using web3.js. In fact the examples\nin the [Web3.js \\\nusing_web3.js>]{role=\"ref\"} section can by copied\ninto the console.\n\n\nViewing Contracts and Transactions\n\n\nThere are several online blockchain explorers available that will allow\nyou to inspect the Ethereum blockchain. See for a list:\n[Blockchain explorers \\\nblockchain_explorers>]{role=\"ref\"}.\n\n\nHosted blockchain explorers {#blockchain_explorers}\n\n\n\n\nEtherChain\n\n\nEtherCamp\n\n\nEtherScan\n (and for\n    \nTestnet\n)\n\n\n\n\nOther Resources\n\n\n\n\nEtherNodes\n - Geographic distribution of\n    nodes and split by client\n\n\nEtherListen\n - Realtime Ethereum\n    transaction visualizer and audializer", 
            "title": "\u8bbf\u95ee\u5408\u7ea6\u548c\u4ea4\u6613"
        }, 
        {
            "location": "/contracts-and-transactions/accessing-contracts-and-transactions/#accessing-contracts-and-transactions-accessing-contracts-and-transactions", 
            "text": "", 
            "title": "Accessing Contracts and Transactions {#Accessing Contracts and Transactions}"
        }, 
        {
            "location": "/contracts-and-transactions/accessing-contracts-and-transactions/#rpc", 
            "text": "In previous sections we have seen how contracts can be written, deployed\nand interacted with. Now it\\'s time to dive in the details of\ncommunicating with the Ethereum network and smart contracts.  An Ethereum node offers a RPC  interface. This\ninterface gives \u00d0app\\'s access to the Ethereum blockchain and\nfunctionality that the node provides, such as compiling smart contract\ncode. It uses a subset of the  JSON-RPC\n2.0  specification (no support for\nnotifications or named parameters) as serialisation protocol and is\navailable over HTTP and IPC (unix domain sockets on linux/OSX and named\npipe\\'s on Windows).  If you are not interested in the details but are looking for an easy to\nuse javascript library you can skip the following sections and continue\nwith [Using Web3 \\ using_web3.js>]{role=\"ref\"}.", 
            "title": "RPC"
        }, 
        {
            "location": "/contracts-and-transactions/accessing-contracts-and-transactions/#conventions", 
            "text": "The RPC interface uses a couple of conventions that are not part of the\nJSON-RPC 2.0 specification:   Numbers are hex encoded. This decision was made because some\n    languages have no or limited support for working with extremly large\n    numbers. To prevent these type of errors numbers are hex encoded and\n    it is up to the developer to parse these numbers and handle them\n    appropriately. See the  hex encoding\n    section \n    on the wiki for examples.  Default block number, several RPC methods accept a block number. In\n    some cases it\\'s not possible to give a block number or not very\n    convenient. For these cases the default block number can be one of\n    these strings [\\\"earliest\\\", \\\"latest\\\", \\\"pending\\\"]. See the\n     wiki\n    page \n    for a list of RPC methods that use the default block parameters.", 
            "title": "Conventions"
        }, 
        {
            "location": "/contracts-and-transactions/accessing-contracts-and-transactions/#deploy-contract", 
            "text": "We will go through the different steps to deploy the following contract\nusing only the RPC interface.  ``` {.sourceCode .js}\ncontract Multiply7 {\n   event Print(uint);\n   function multiply(uint input) returns (uint) {\n      Print(input * 7);\n      return input * 7;\n   }\n} The first thing to do is make sure the HTTP RPC interface is enabled.\nThis means for geth we supply the `--rpc` flag on startup and for eth\nthe `-j` flag. In this example we use the geth node on a private\ndevelopment chain. Using this approach we don\\ t need ether on the real\nnetwork.\n\n``` {.sourceCode .bash}  geth --rpc --dev --mine --minerthreads 1 --unlock 0 console 2 geth.log  This will start the HTTP RPC interface on  http://localhost:8545 .  ::: {.note}\n::: {.admonition-title}\nNote\n:::  geth supports CORS , see\nthe  --rpccorsdomain  flag for more information.\n:::  We can verify that the interface is running by retrieving the coinbase\naddress and balance using  curl .\nPlease note that data in these examples will differ on your local node.\nIf you want to try these command replace the request params accordingly.  ``` {.sourceCode .bash}   curl --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_coinbase\", \"id\":1}' -H \"Content-Type: application/json\" localhost:8545\n{\"id\":1,\"jsonrpc\":\"2.0\",\"result\":[\"0x9b1d35635cc34752ca54713bb99d38614f63c955\"]}  curl --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBalance\", \"params\": [\"0x9b1d35635cc34752ca54713bb99d38614f63c955\", \"latest\"], \"id\":2}' -H \"Content-Type: application/json\" localhost:8545\n{\"id\":2,\"jsonrpc\":\"2.0\",\"result\":\"0x1639e49bba16280000\"} Remember when we said that numbers are hex encoded? In this case the\nbalance is returned in wei as a hex string. If we want to have the\nbalance in ether as a number we can use web3 from the geth console.\n\n``` {.sourceCode .js}  web3.fromWei( 0x1639e49bba16280000 ,  ether ) 410    Now that we have some ether on our private development chain we can\ndeploy the contract. The first step is to compile the Multiply7 contract\nto byte code that can be sent to the EVM. Follow these these \ninstructions to install solc, the solidity compiler.  The next step is to compile the Multiply7 contract to byte code that can\nbe send to the EVM.  ``` {.sourceCode .bash}   echo 'pragma solidity ^0.4.16; contract Multiply7 { event Print(uint); function multiply(uint input) public returns (uint) { Print(input * 7); return input * 7; } }' | solc --bin\n=======  :Multiply7 =======\nBinary: \n6060604052341561000f57600080fd5b60eb8061001d6000396000f300606060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063c6888fa1146044575b600080fd5b3415604e57600080fd5b606260048080359060200190919050506078565b6040518082815260200191505060405180910390f35b60007f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da600783026040518082815260200191505060405180910390a16007820290509190505600a165627a7a7230582040383f19d9f65246752244189b02f56e8d0980ed44e7a56c0b200458caad20bb0029 Now that we have the compiled code we need to determine how much gas it\ncosts to deploy it. The RPC interface has an `eth_estimateGas` method\nthat will give us an estimate.\n\n``` {.sourceCode .bash}  curl --data  { jsonrpc : 2.0 , method :  eth_estimateGas ,  params : [{ from :  0x9b1d35635cc34752ca54713bb99d38614f63c955 ,  data :  0x6060604052341561000f57600080fd5b60eb8061001d6000396000f300606060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063c6888fa1146044575b600080fd5b3415604e57600080fd5b606260048080359060200190919050506078565b6040518082815260200191505060405180910390f35b60007f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da600783026040518082815260200191505060405180910390a16007820290509190505600a165627a7a7230582040383f19d9f65246752244189b02f56e8d0980ed44e7a56c0b200458caad20bb0029 }],  id : 5}  -H  Content-Type: application/json  localhost:8545\n{ jsonrpc : 2.0 , id :5, result : 0x1c31e }   And finally deploy the contract.  ``` {.sourceCode .bash}   curl --data '{\"jsonrpc\":\"2.0\",\"method\": \"eth_sendTransaction\", \"params\": [{\"from\": \"0x9b1d35635cc34752ca54713bb99d38614f63c955\", \"gas\": \"0x1c31e\", \"data\": \"0x6060604052341561000f57600080fd5b60eb8061001d6000396000f300606060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063c6888fa1146044575b600080fd5b3415604e57600080fd5b606260048080359060200190919050506078565b6040518082815260200191505060405180910390f35b60007f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da600783026040518082815260200191505060405180910390a16007820290509190505600a165627a7a7230582040383f19d9f65246752244189b02f56e8d0980ed44e7a56c0b200458caad20bb0029\"}], \"id\": 6}' -H \"Content-Type: application/json\" localhost:8545\n{\"id\":6,\"jsonrpc\":\"2.0\",\"result\":\"0xe1f3095770633ab2b18081658bad475439f6a08c902d0915903bafff06e6febf\"} The transaction is accepted by the node and a transaction hash is\nreturned. We can use this hash to track the transaction.\n\nThe next step is to determine the address where our contract is\ndeployed. Each executed transaction will create a receipt. This receipt\ncontains various information about the transaction such as in which\nblock the transaction was included and how much gas was used by the EVM.\nIf a transaction creates a contract it will also contain the contract\naddress. We can retrieve the receipt with the\n`eth_getTransactionReceipt` RPC method.\n\n``` {.sourceCode .bash}  curl --data  { jsonrpc : 2.0 , method :  eth_getTransactionReceipt ,  params : [ 0xe1f3095770633ab2b18081658bad475439f6a08c902d0915903bafff06e6febf ],  id : 7}  -H  Content-Type: application/json  localhost:8545\n{ jsonrpc : 2.0 , id :7, result :{ blockHash : 0x77b1a4f6872b9066312de3744f60020cbd8102af68b1f6512a05b7619d527a4f , blockNumber : 0x1 , contractAddress : 0x4d03d617d700cf81935d7f797f4e2ae719648262 , cumulativeGasUsed : 0x1c31e , from : 0x9b1d35635cc34752ca54713bb99d38614f63c955 , gasUsed : 0x1c31e , logs :[], logsBloom : 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 , status : 0x1 , to :null, transactionHash : 0xe1f3095770633ab2b18081658bad475439f6a08c902d0915903bafff06e6febf , transactionIndex : 0x0 }}   We can see that our contract was created on 0x4d03d617d700cf81935d7f797f4e2ae719648262 . If you got null instead of\na receipt the transaction has not been included in a block yet. Wait for\na moment and check if your miner is running and retry it.", 
            "title": "Deploy contract"
        }, 
        {
            "location": "/contracts-and-transactions/accessing-contracts-and-transactions/#interacting-with-smart-contracts", 
            "text": "Now that our contract is deployed we can interact with it. There are 2\nmethods for this, sending a transaction or\n[using call as previously explained \\ interacting_with_a_contract>]{role=\"ref\"}.\nIn this example we will be sending a transaction to the multiply method\nof the contract.  If we look at the documentation for the eth_sendTransaction \nwe can see that we need to supply several arguments. In our case we need\nto specify the  from ,  to  and  data  arguments.  From  is the public\naddress of our account and  to  the contract address. The  data \nargument is a bit harder. It contains a payload that defines which\nmethod must be called and with which arguments. This is were the ABI\ncomes into play. The ABI defines how to define and encode data for the\nEVM. You can read  all the details about the ABI\nhere .  The bytes of the payload is the function selector and defines which\nmethod is called. This is done by taking the first 4 bytes from the\nKeccak hash over the function name and its argument types and hex encode\nit. The multiply function accepts an uint which is an alias \nfor uint256. This leaves us with:  ``` {.sourceCode .js}   web3.sha3(\"multiply(uint256)\").substring(0, 10)\n\"0xc6888fa1\" See   for   details   [ this  page ]( https : //github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#function-selector).  The   next   step   is   to   encode   the   arguments .   We   only   have   one   uint256 ,   lets  assume   we   supply   the   value   6.   The   ABI   has   a  [ section ]( https : //github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#argument-encoding)  which   specifies   how   to   encode   uint256   types .    int \\ M \\ :   enc ( X )   is   the   big - endian   two \\ s   complement   encoding   of   X ,   padded   on   the   higher - oder   ( left )   side   with   0xff   for   negative   X   and   with   zero   bytes    for   positive   X   such   that   the   length   is   a   multiple   of   32   bytes .  This   encodes   to  ` 0000000000000000000000000000000000000000000000000000000000000006 ` .  Combining   the   function   selector   and   the   encoded   argument   our   ` data `   will  be  ` 0xc6888fa10000000000000000000000000000000000000000000000000000000000000006 ` .  Lets   try   it :  ```   {. sourceCode   . bash }    curl   -- data   { jsonrpc : 2.0 , method :   eth_sendTransaction ,   params :   [{ from :   0x9b1d35635cc34752ca54713bb99d38614f63c955 ,   to :   0x4d03d617d700cf81935d7f797f4e2ae719648262 ,   data :   0xc6888fa10000000000000000000000000000000000000000000000000000000000000006 }],   id :   8 }   - H   Content-Type: application/json   localhost : 8545  { id : 8 , jsonrpc : 2.0 , result : 0x50905bea8043e1166703a2a72390f6e6eb4f23150c8e7d13094a6d82ce89a054 }    Since we sent a transaction we got the transaction hash returned. If we\nretrieve the receipt we can see something new:  ``` {.sourceCode .js}\n{\n  blockHash: \"0x55262092dc46db5c7d3595decd4317780896c765c4db69cf2d5f650e46249b13\",\n  blockNumber: 6,\n  contractAddress: null,\n  cumulativeGasUsed: 22774,\n  from: \"0x9b1d35635cc34752ca54713bb99d38614f63c955\",\n  gasUsed: 22774,\n  logs: [{\n      address: \"0x4d03d617d700cf81935d7f797f4e2ae719648262\",\n      blockHash: \"0x55262092dc46db5c7d3595decd4317780896c765c4db69cf2d5f650e46249b13\",\n      blockNumber: 6,\n      data: \"0x000000000000000000000000000000000000000000000000000000000000002a\",\n      logIndex: 0,\n      removed: false,\n      topics: [\"0x24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da\"],\n      transactionHash: \"0x50905bea8043e1166703a2a72390f6e6eb4f23150c8e7d13094a6d82ce89a054\",\n      transactionIndex: 0\n  }],\n  logsBloom: \"0x00000000000008000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000020800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n  status: \"0x1\",\n  to: \"0x4d03d617d700cf81935d7f797f4e2ae719648262\",\n  transactionHash: \"0x50905bea8043e1166703a2a72390f6e6eb4f23150c8e7d13094a6d82ce89a054\",\n  transactionIndex: 0\n} The receipt contains a log. This log was generated by the EVM on\ntransaction execution and included in the receipt. If we look at the\nmultipy function we can see that the Print event was raised with the\ninput times 7. Since the argument for the Print event was a uint256 we\ncan decode it according to the ABI rules which will leave us with the\nexpected decimal 42.\n\n``` {.sourceCode .bash}  echo $((0x000000000000000000000000000000000000000000000000000000000000002a))\n42  Apart from the data it is worth noting that topics can be used to\ndetermine which event created the log:  ``` {.sourceCode .js}   web3.sha3(\"Print(uint256)\")\n\"24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da\" You   can   read   more   about   events ,   topics   and   indexing   in   the   [ Solidity  tutorial ]( http : //solidity.readthedocs.org/en/latest/contracts.html#events).  This   was   just   a   brief   introduction   into   some   of   the   most   common   tasks .  See   for   a   full   list   of   available   RPC   methods   the   [ RPC   wiki  page ]( https : //github.com/ethereum/wiki/wiki/JSON-RPC#json-rpc-methods).  Web3 . js   { # using_web3 . js }  -------  As   we   have   seen   in   the   previous   example   using   the   JSON - RPC   interface   can  be   quite   tedious   and   error - prone ,   especially   when   we   have   to   deal   with  the   ABI .   Web3 . js   is   a   javascript   library   that   works   on   top   of   the  Ethereum   RPC   interface .   Its   goal   is   to   provide   a   more   user   friendly  interface   and   reducing   the   chance   for   errors .  Deploying   the   Multiply7   contract   using   web3   would   look   like :  ``` {.sourceCode .js}  var source =  contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input * 7); return input * 7; } } ;  var compiled = web3.eth.compile.solidity(source);  var code = compiled.Multiply7.code;  var abi = compiled.Multiply7.info.abiDefinition;  web3.eth.contract(abi).new({from:  0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a , data: code}, function (err, contract) {     if (!err   contract.address)        console.log( deployed on: , contract.address);     }  );  deployed on: 0x0ab60714033847ad7f0677cc7514db48313976e2    Load a deployed contract and send a transaction:  ``` {.sourceCode .js}\nvar source = 'contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input * 7); return input * 7; } }';\nvar compiled = web3.eth.compile.solidity(source);\nvar Multiply7 = web3.eth.contract(compiled.Multiply7.info.abiDefinition);\nvar multi = Multiply7.at(\"0x0ab60714033847ad7f0677cc7514db48313976e2\")\nmulti.multiply.sendTransaction(6, {from: \"0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a\"}) Register a callback which is called when the `Print` event created a\nlog.\n\n``` {.sourceCode .js}\nmulti.Print(function(err, data) { console.log(JSON.stringify(data)) })\n{ address : 0x0ab60714033847ad7f0677cc7514db48313976e2 , args : { : 21 }, blockHash : 0x259c7dc07c99eed9dd884dcaf3e00a81b2a1c83df2d9855ce14c464b59f0c8b3 , blockNumber :539, event : Print , logIndex :0,  transactionHash : 0x5c115aaa5418118457e96d3c44a3b66fe9f2bead630d79455d0ecd832dc88d48 , transactionIndex :0}  See for more information the web3.js  wiki\npage.", 
            "title": "Interacting with smart contracts"
        }, 
        {
            "location": "/contracts-and-transactions/accessing-contracts-and-transactions/#console", 
            "text": "The geth console \noffers a command line interface with a javascript runtime. It can\nconnect to a local or remote geth or eth node. It will load the web3.js\nlibrary that users can use. This allows users to deploy and interact\nwith smart contract from the console using web3.js. In fact the examples\nin the [Web3.js \\ using_web3.js>]{role=\"ref\"} section can by copied\ninto the console.", 
            "title": "Console"
        }, 
        {
            "location": "/contracts-and-transactions/accessing-contracts-and-transactions/#viewing-contracts-and-transactions", 
            "text": "There are several online blockchain explorers available that will allow\nyou to inspect the Ethereum blockchain. See for a list:\n[Blockchain explorers \\ blockchain_explorers>]{role=\"ref\"}.", 
            "title": "Viewing Contracts and Transactions"
        }, 
        {
            "location": "/contracts-and-transactions/accessing-contracts-and-transactions/#hosted-blockchain-explorers-blockchain_explorers", 
            "text": "EtherChain  EtherCamp  EtherScan  (and for\n     Testnet )", 
            "title": "Hosted blockchain explorers {#blockchain_explorers}"
        }, 
        {
            "location": "/contracts-and-transactions/accessing-contracts-and-transactions/#other-resources", 
            "text": "EtherNodes  - Geographic distribution of\n    nodes and split by client  EtherListen  - Realtime Ethereum\n    transaction visualizer and audializer", 
            "title": "Other Resources"
        }, 
        {
            "location": "/contracts-and-transactions/mix/", 
            "text": "Mix {#sec:mix}\n\n\nThe IDE Mix is intended to help you as a developer to create, debug and\ndeploy contracts and dapps (both contracts backend and frontend).\n\n\nWARNING - There are numerous reports of crash-at-boot issues for Mix\non OS X. The issue is a\n\n\nHeisenbug\n \nwhich we have\nbeen chasing for a month or two. The best workaround we have for right\nnow is to use the Debug configuration, like so:\n :\n\n\ncmake -DCMAKE_BUILD_TYPE=Debug ..\n\n\n\n\n\nWARNING - A replacement for Mix called\n\n\nRemix\n\n\nis being worked on, so if you are experiencing issues with Mix, you\nmight be better to look for alternatives until Remix is more mature.\n\n\nStart by creating a new project that consists of\n\n\n\n\ncontracts\n\n\nhtml files\n\n\nJavaScript files\n\n\nstyle files\n\n\nimage files\n\n\n\n\n::: {.toctree}\nmix/project-editor.rst mix/scenario-editor.rst mix/state-viewer.rst\nmix/transaction-explorer.rst mix/javascript-console.rst\nmix/transaction-debugger.rst mix/dapp-deployment.rst mix/codeeditor.rst\n:::", 
            "title": "mix"
        }, 
        {
            "location": "/contracts-and-transactions/mix/#mix-secmix", 
            "text": "The IDE Mix is intended to help you as a developer to create, debug and\ndeploy contracts and dapps (both contracts backend and frontend).  WARNING - There are numerous reports of crash-at-boot issues for Mix\non OS X. The issue is a  Heisenbug   which we have\nbeen chasing for a month or two. The best workaround we have for right\nnow is to use the Debug configuration, like so:  :  cmake -DCMAKE_BUILD_TYPE=Debug ..  WARNING - A replacement for Mix called  Remix  is being worked on, so if you are experiencing issues with Mix, you\nmight be better to look for alternatives until Remix is more mature.  Start by creating a new project that consists of   contracts  html files  JavaScript files  style files  image files   ::: {.toctree}\nmix/project-editor.rst mix/scenario-editor.rst mix/state-viewer.rst\nmix/transaction-explorer.rst mix/javascript-console.rst\nmix/transaction-debugger.rst mix/dapp-deployment.rst mix/codeeditor.rst\n:::", 
            "title": "Mix {#sec:mix}"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/", 
            "text": "Dapps\n\n\nA dapp is a service that enables direct interaction between end users\nand providers (e.g. connecting buyers and sellers in some marketplace,\nowners and storers in file storage). Ethereum dapps typically interface\nusers via an HTML/Javascript web application using a Javascript API to\ncommunicate with the blockchain. Dapps would typically have their own\nsuite of associated contracts on the blockchain which they use to encode\nbusiness logic and allow persistent storage of their consensus-critical\nstate. Remember that because of the redundant nature of computation on\nthe Ethereum network, the gas costs of execution will always be higher\nthan private execution offchain. This incentivizes dapp developers to\nrestrict the amount of code they execute and amount of data they store\non the blockchain.\n\n\nDapp directories\n\n\nDapps that use Ethereum are compiled to the following lists. They are\nlisted in various stages of development (concept, working prototype,\nlive/deployed). If you are developing a dapp, consider adding an entry\nto these listings:\n\n\n\n\nEthercasts State of the \u00d0apps\n\n\n\n\nThe offered decentralised services listed cover a wide range of areas\nincluding finance, insurance, prediction markets, social networks,\ndistributed computation and storage, gambling, marketplace, internet of\nthings, governance, collaboration, development and games.\n\n\n\n\nWhat apps can we eventually expect?\n    \nhttps://www.reddit.com/r/ethereum/comments/2mnl7f/the_top_10_ether_dapps_of_2015/cm63nsf\n\n\n\n\nIn the future, dapps are likely to be listed and distributed in\ndappstores integrated in dapp browsers.\n\n\nDapp browsers\n\n\n\n\nMist\n - official GUI dapp browser\n    developed by the foundation, alpha stage. Mist as Wallet dapp is in\n    beta.\n\n\nStatus\n - Mobile Ethereum browser (alpha)\n\n\nMetaMask\n - Aaron Kumavis Davis\\'s in-browser\n    GUI. \nEpicenter Bitcoin interview on\n    github\n -\n    supported by DEVgrants\n\n\nAlethZero\n - C++ eth client\n    GUI, (discontinued).\n\n\nSupernova\n - (discontinued).\n\n\n\n\nDeveloper Tools\n\n\nDapp development requires an understanding of the Web3 Javascript API,\nthe JSON RPC API, and the Solidity programming language.\n\n\n::: {.note}\n::: {.admonition-title}\nNote\n:::\n\n\nThere are developer tools that help you develop, test, and deploy dapps\nin a way that automatically utilizes the resources listed below.\n:::\n\n\n\n\nWeb3 JavaScript\n    API\n - This is\n    the main JavaScript SDK to use when you want to interact with an\n    Ethereum node.\n\n\nJSON RPC API\n -\n    This is the low level JSON RPC 2.0 interface to interface with a\n    node. This API is used by the \nWeb3 JavaScript\n    API\n.\n\n\nSolidity Docs\n\n    -Solidity is the Ethereum developed Smart Contract language, which\n    compiles to EVM (Ethereum Virtual Machine) opcodes.\n\n\nSolium\n -Linter to identify\n    and fix style and security issues in Solidity.\n\n\nSolhint\n -Solidity linter\n    that provides security, style guide and best practice rules for\n    smart contract validation.\n\n\n[test-networks]{role=\"ref\"} - Test networks help developers develop\n    and test Ethereum code and network interactions without spending\n    their own ether on the main network. Test network options are listed\n    below.\n\n\n[IDE-or-development-framework]{role=\"ref\"}. This assists you in\n    developing, debugging, and deploying Ethereum applications.\n\n\n\n\nDapp development resources {#IDE-or-development-framework}\n\n\n\n\nSmart contracts\n    ELI5\n\n\nhttps://blog.slock.it/a-primer-to-the-decentralized-autonomous-organization-dao-69fb125bd3cd\n\n\nA 101 noob\\'s intro to programming smart\n    contracts\n\n\nStandardised contract APIs\n    listing\n\n\n\n\nExamples\n\n\n\n\nexample use of pricefeed - web3 script printing all account\n    balances\n\n\nExample Ethereum\n    contracts\n\n\n\n\nhttps://dappsforbeginners.wordpress.com/tutorials/your-first-dapp/\n\n\nhttps://github.com/ethereum/wiki/wiki/Dapp-Developer-Resources\n\n\nTutorials\n\n\n\n\nDapp tutorials on ethereum.org\n\n\nDapps for beginners tutorial\n    series\n\n\nEris\\' Solidity Tutorial\n    Series\n\n\nTutorials on advanced\n    Solidity\n\n\nhttp://ethereumj.io/blog/2015/09/09/friendly-ether-bot/\n\n\nhttps://github.com/ConsenSys/ether-pudding\n\n\n\n\nMix-IDE\n\n\nMix is the official Ethereum IDE that allows developers to build and\ndeploy contracts and decentralized applications on top of the Ethereum\nblockchain. It includes a Solidity source code debugger.\n[sec:mix]{role=\"ref\"} (discontinued)\n\n\nIDEs/Frameworks\n\n\nBelow are developer frameworks and IDEs used for writing Ethereum dapps.\n\n\n\n\nTruffle\n - Truffle is a\n    development environment, testing framework and asset pipeline for\n    Ethereum.\n\n\nDapple\n - Dapple is a tool for\n    Solidity developers to help build and manage complex contract\n    systems on Ethereum-like blockchains.\n\n\nPopulus\n - Populus is a\n    Smart Contract development framework written in python.\n\n\nEris-PM\n -\n    The Eris Package Manager deploys and tests smart contract systems on\n    private and public chains.\n\n\nEmbark\n - Embark is\n    a \u00d0app development framework written in JavaScript.\n\n\nEtherScripter (obsolete,\n    discontinued)\n\n\nResilience Raw Transaction\n    Broadcaster\n\n\n\n\nEthereum-console\n\n\nCommand-line console for Ethereum nodes.\n\n\nEthconsole\n connects to\nan Ethereum node running in the background (tested with eth and geth)\nvia IPC and provides an interactive javascript console containing the\nweb3 object with admin additions.\n\n\nHere you could find a list of available commands \nethereum node control\ncommands\n\n\nTo use this console you would need to start a local ethereum node with\nipc communication socket enabled (file \ngeth.ipc\n in data directory). By\ndefault ipc socket should be located at you local home directory in\n.ethereum after you started a node. You could also set \n--test\n option\nto use specific node test commands.\n\n\n``` {.sourceCode .Console}\n\n\n\n\neth --test\nethconsole ipc://path/to/geth.ipc\n\nIn the console you could then type\n\n``` {.sourceCode .Console}\n\n web3.eth.\ncommand name\n (arguments, function(){})\n\n\n\n\n\nHere the defenition of \n--test\n mode node commands:\n\n\n``` {.sourceCode .Console}\n\n\n\n\nweb3.test.addBlock(\"[RLP]\", function(){}) - Add a block from a string containing its hex RLP\nweb3.test.rewindToBlock:(\"[int]\", function(){}) - Reset the blockchain to specified block number\nweb3.test.mineBlocks:(\"[int]\", function(){}) - Mine a certain amount of NoProof blocks into chain\nweb3.test.modifyTimestamp:(\"[int]\", function(){}) - Set current block timestamp\nweb3.test.setChainParams:(\"[json]\", function(){}) - Reset the blockchain with given node configuration file\n```\n\n\n\n\nMore information about node\n\nconfiguration\n file.\n\n\nBase layer services\n\n\nWhisper\n\n\n\n\nWhat is Whisper and what is it used\n    for\n -\n    stackexchange Q\nA\n\n\nGavin Wood: Shh!\n    Whisper\n - DEVCON-1\n    talk youtube video\n\n\nWhisper overview and dream API\n    usage\n -\n\n\nELI5\n\n\n\n\nSwarm\n\n\nSwarm is a distributed storage platform and content distribution\nservice, a native base layer service of the Ethereum web 3 stack. The\nprimary objective of Swarm is to provide a sufficiently decentralized\nand redundant store of Ethereum\\'s public record, in particular to store\nand distribute dapp code and data as well as block chain data. From an\neconomic point of view, it allows participants to efficiently pool their\nstorage and bandwidth resources in order to provide the aforementioned\nservices to all participants.\n\n\nFrom the end user\\'s perspective, Swarm is not that different from WWW,\nexcept that uploads are not to a specific server. The objective is to\npeer-to-peer storage and serving solution that is DDOS-resistant,\nzero-downtime, fault-tolerant and censorship-resistant as well as\nself-sustaining due to a built-in incentive system which uses peer to\npeer accounting and allows trading resources for payment. Swarm is\ndesigned to deeply integrate with the devp2p multiprotocol network layer\nof Ethereum as well as with the Ethereum blockchain for domain name\nresolution, service payments and content availability insurance.\n\n\n\u00d0\u039eVcon talks on swarm\n\n\n\n\nViktor Tr\u00f3n, Daniel A. Nagy:\n    Swarm\n - Ethereum\n    \u00d0\u039eVcon-1 talk on youtube\n\n\nDaniel A. Nagy: Keeping the Public Record Safe and\n    Accessible\n -\n    Ethereum \u00d0\u039eVcon-0 talk on youtube\n\n\n\n\nCode and status\n\n\n\n\n[source](\nhttps://github.com/ethereum/go-ethereum/tree/swarm\n)\n\n\n[issues on\n    github](\nhttps://github.com/ethereum/go-ethereum/labels/swarm\n)\n\n\n[development roadmap]()\n\n\nethersphere on twitter\n\n\nswarm gitter room\n\n\nswarm subreddit\n\n\n\n\nStorage on and offchain\n\n\n\n\nhttps://www.reddit.com/r/ethereum/comments/3hkv2f/eli5_storage_in_the_ethereum_blockchain/\n\n\nhttps://www.reddit.com/r/ethereum/comments/3npsoz/ethereum_ipfs_and_filecoin/\n\n\nWhat is swarm and what is it used\n    for?\n -\n    stackexchange Q\nA\n\n\n\n\nEthereum Alarm Clock\n\n\n\n\nAuthor:\n Piper Merriam\n\n\nWebsite:\n\n    \nalarm_main_website\n.\n\n\nDocumentation:\n\n    \nalarm_documentation\n.\n\n\n\n\nA marketplace that facilitates scheduling transactions to occur at a\nlater time. Serves a similar role to things like \ncrontab\n in unix, or\n\nsetTimeout\n in javascript.\n\n\n\n\nDecentralized cron service in Ethereum\n    proposal\n -\n    by Peter Szilagyi\n\n\n\n\nEthereum Computation Market\n\n\n\n\nAuthor:\n Piper Merriam\n\n\nWebsite:\n\n    \ncomputation_market_main_website\n.\n\n\nDocumentation:\n\n    \ncomputation_market_documentation\n.\n\n\n\n\nA marketplace that facilitates verifiable execution of computations\noff-chain. Allows for very expernsive computations to be used within the\nEVM without having to actually pay the high gas costs of executing them\non-chain.\n\n\nBTCRelay\n\n\nBTCrelay\n\n\n:   -   \nMore\n        information\n\n        (about ETH/BTC 2-way peg without modifying bitcoin code).\n    -   \nBTCrelay\n        audit\n\n\nRANDAO\n\n\nRandom number *\n\nhttps://www.reddit.com/r/ethereum/comments/49yld7/eli5_how_does_a_service_like_szabodice_grab_a/\n\n\nThe EVM {#the-EVM}\n\n\nThe Ethereum Virtual Machine (EVM) is the runtime environment for smart\ncontracts in Ethereum. It is not only sandboxed, but actually completely\nisolated, which means that code running inside the EVM has no access to\nnetwork, filesystem, or other processes. Smart contracts even have\nlimited access to other smart contracts.\n\n\nContracts live on the blockchain in an Ethereum-specific binary format\n(EVM bytecode). However, contracts are typically written in an Ethereum\nhigh level language, compiled into byte code using an EVM compiler, and\nfinally uploaded on the blockchain using an Ethereum client.", 
            "title": "dapps"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#dapps", 
            "text": "A dapp is a service that enables direct interaction between end users\nand providers (e.g. connecting buyers and sellers in some marketplace,\nowners and storers in file storage). Ethereum dapps typically interface\nusers via an HTML/Javascript web application using a Javascript API to\ncommunicate with the blockchain. Dapps would typically have their own\nsuite of associated contracts on the blockchain which they use to encode\nbusiness logic and allow persistent storage of their consensus-critical\nstate. Remember that because of the redundant nature of computation on\nthe Ethereum network, the gas costs of execution will always be higher\nthan private execution offchain. This incentivizes dapp developers to\nrestrict the amount of code they execute and amount of data they store\non the blockchain.", 
            "title": "Dapps"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#dapp-directories", 
            "text": "Dapps that use Ethereum are compiled to the following lists. They are\nlisted in various stages of development (concept, working prototype,\nlive/deployed). If you are developing a dapp, consider adding an entry\nto these listings:   Ethercasts State of the \u00d0apps   The offered decentralised services listed cover a wide range of areas\nincluding finance, insurance, prediction markets, social networks,\ndistributed computation and storage, gambling, marketplace, internet of\nthings, governance, collaboration, development and games.   What apps can we eventually expect?\n     https://www.reddit.com/r/ethereum/comments/2mnl7f/the_top_10_ether_dapps_of_2015/cm63nsf   In the future, dapps are likely to be listed and distributed in\ndappstores integrated in dapp browsers.", 
            "title": "Dapp directories"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#dapp-browsers", 
            "text": "Mist  - official GUI dapp browser\n    developed by the foundation, alpha stage. Mist as Wallet dapp is in\n    beta.  Status  - Mobile Ethereum browser (alpha)  MetaMask  - Aaron Kumavis Davis\\'s in-browser\n    GUI.  Epicenter Bitcoin interview on\n    github  -\n    supported by DEVgrants  AlethZero  - C++ eth client\n    GUI, (discontinued).  Supernova  - (discontinued).", 
            "title": "Dapp browsers"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#developer-tools", 
            "text": "Dapp development requires an understanding of the Web3 Javascript API,\nthe JSON RPC API, and the Solidity programming language.  ::: {.note}\n::: {.admonition-title}\nNote\n:::  There are developer tools that help you develop, test, and deploy dapps\nin a way that automatically utilizes the resources listed below.\n:::   Web3 JavaScript\n    API  - This is\n    the main JavaScript SDK to use when you want to interact with an\n    Ethereum node.  JSON RPC API  -\n    This is the low level JSON RPC 2.0 interface to interface with a\n    node. This API is used by the  Web3 JavaScript\n    API .  Solidity Docs \n    -Solidity is the Ethereum developed Smart Contract language, which\n    compiles to EVM (Ethereum Virtual Machine) opcodes.  Solium  -Linter to identify\n    and fix style and security issues in Solidity.  Solhint  -Solidity linter\n    that provides security, style guide and best practice rules for\n    smart contract validation.  [test-networks]{role=\"ref\"} - Test networks help developers develop\n    and test Ethereum code and network interactions without spending\n    their own ether on the main network. Test network options are listed\n    below.  [IDE-or-development-framework]{role=\"ref\"}. This assists you in\n    developing, debugging, and deploying Ethereum applications.", 
            "title": "Developer Tools"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#dapp-development-resources-ide-or-development-framework", 
            "text": "Smart contracts\n    ELI5  https://blog.slock.it/a-primer-to-the-decentralized-autonomous-organization-dao-69fb125bd3cd  A 101 noob\\'s intro to programming smart\n    contracts  Standardised contract APIs\n    listing", 
            "title": "Dapp development resources {#IDE-or-development-framework}"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#examples", 
            "text": "example use of pricefeed - web3 script printing all account\n    balances  Example Ethereum\n    contracts   https://dappsforbeginners.wordpress.com/tutorials/your-first-dapp/  https://github.com/ethereum/wiki/wiki/Dapp-Developer-Resources", 
            "title": "Examples"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#tutorials", 
            "text": "Dapp tutorials on ethereum.org  Dapps for beginners tutorial\n    series  Eris\\' Solidity Tutorial\n    Series  Tutorials on advanced\n    Solidity  http://ethereumj.io/blog/2015/09/09/friendly-ether-bot/  https://github.com/ConsenSys/ether-pudding", 
            "title": "Tutorials"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#mix-ide", 
            "text": "Mix is the official Ethereum IDE that allows developers to build and\ndeploy contracts and decentralized applications on top of the Ethereum\nblockchain. It includes a Solidity source code debugger.\n[sec:mix]{role=\"ref\"} (discontinued)", 
            "title": "Mix-IDE"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#idesframeworks", 
            "text": "Below are developer frameworks and IDEs used for writing Ethereum dapps.   Truffle  - Truffle is a\n    development environment, testing framework and asset pipeline for\n    Ethereum.  Dapple  - Dapple is a tool for\n    Solidity developers to help build and manage complex contract\n    systems on Ethereum-like blockchains.  Populus  - Populus is a\n    Smart Contract development framework written in python.  Eris-PM  -\n    The Eris Package Manager deploys and tests smart contract systems on\n    private and public chains.  Embark  - Embark is\n    a \u00d0app development framework written in JavaScript.  EtherScripter (obsolete,\n    discontinued)  Resilience Raw Transaction\n    Broadcaster", 
            "title": "IDEs/Frameworks"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#ethereum-console", 
            "text": "Command-line console for Ethereum nodes.  Ethconsole  connects to\nan Ethereum node running in the background (tested with eth and geth)\nvia IPC and provides an interactive javascript console containing the\nweb3 object with admin additions.  Here you could find a list of available commands  ethereum node control\ncommands  To use this console you would need to start a local ethereum node with\nipc communication socket enabled (file  geth.ipc  in data directory). By\ndefault ipc socket should be located at you local home directory in\n.ethereum after you started a node. You could also set  --test  option\nto use specific node test commands.  ``` {.sourceCode .Console}   eth --test\nethconsole ipc://path/to/geth.ipc In the console you could then type\n\n``` {.sourceCode .Console}  web3.eth. command name  (arguments, function(){})   Here the defenition of  --test  mode node commands:  ``` {.sourceCode .Console}   web3.test.addBlock(\"[RLP]\", function(){}) - Add a block from a string containing its hex RLP\nweb3.test.rewindToBlock:(\"[int]\", function(){}) - Reset the blockchain to specified block number\nweb3.test.mineBlocks:(\"[int]\", function(){}) - Mine a certain amount of NoProof blocks into chain\nweb3.test.modifyTimestamp:(\"[int]\", function(){}) - Set current block timestamp\nweb3.test.setChainParams:(\"[json]\", function(){}) - Reset the blockchain with given node configuration file\n```   More information about node configuration  file.", 
            "title": "Ethereum-console"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#base-layer-services", 
            "text": "", 
            "title": "Base layer services"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#whisper", 
            "text": "What is Whisper and what is it used\n    for  -\n    stackexchange Q A  Gavin Wood: Shh!\n    Whisper  - DEVCON-1\n    talk youtube video  Whisper overview and dream API\n    usage  -  ELI5", 
            "title": "Whisper"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#swarm", 
            "text": "Swarm is a distributed storage platform and content distribution\nservice, a native base layer service of the Ethereum web 3 stack. The\nprimary objective of Swarm is to provide a sufficiently decentralized\nand redundant store of Ethereum\\'s public record, in particular to store\nand distribute dapp code and data as well as block chain data. From an\neconomic point of view, it allows participants to efficiently pool their\nstorage and bandwidth resources in order to provide the aforementioned\nservices to all participants.  From the end user\\'s perspective, Swarm is not that different from WWW,\nexcept that uploads are not to a specific server. The objective is to\npeer-to-peer storage and serving solution that is DDOS-resistant,\nzero-downtime, fault-tolerant and censorship-resistant as well as\nself-sustaining due to a built-in incentive system which uses peer to\npeer accounting and allows trading resources for payment. Swarm is\ndesigned to deeply integrate with the devp2p multiprotocol network layer\nof Ethereum as well as with the Ethereum blockchain for domain name\nresolution, service payments and content availability insurance.", 
            "title": "Swarm"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#vcon-talks-on-swarm", 
            "text": "Viktor Tr\u00f3n, Daniel A. Nagy:\n    Swarm  - Ethereum\n    \u00d0\u039eVcon-1 talk on youtube  Daniel A. Nagy: Keeping the Public Record Safe and\n    Accessible  -\n    Ethereum \u00d0\u039eVcon-0 talk on youtube", 
            "title": "\u00d0\u039eVcon talks on swarm"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#code-and-status", 
            "text": "[source]( https://github.com/ethereum/go-ethereum/tree/swarm )  [issues on\n    github]( https://github.com/ethereum/go-ethereum/labels/swarm )  [development roadmap]()  ethersphere on twitter  swarm gitter room  swarm subreddit   Storage on and offchain   https://www.reddit.com/r/ethereum/comments/3hkv2f/eli5_storage_in_the_ethereum_blockchain/  https://www.reddit.com/r/ethereum/comments/3npsoz/ethereum_ipfs_and_filecoin/  What is swarm and what is it used\n    for?  -\n    stackexchange Q A", 
            "title": "Code and status"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#ethereum-alarm-clock", 
            "text": "Author:  Piper Merriam  Website: \n     alarm_main_website .  Documentation: \n     alarm_documentation .   A marketplace that facilitates scheduling transactions to occur at a\nlater time. Serves a similar role to things like  crontab  in unix, or setTimeout  in javascript.   Decentralized cron service in Ethereum\n    proposal  -\n    by Peter Szilagyi", 
            "title": "Ethereum Alarm Clock"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#ethereum-computation-market", 
            "text": "Author:  Piper Merriam  Website: \n     computation_market_main_website .  Documentation: \n     computation_market_documentation .   A marketplace that facilitates verifiable execution of computations\noff-chain. Allows for very expernsive computations to be used within the\nEVM without having to actually pay the high gas costs of executing them\non-chain.", 
            "title": "Ethereum Computation Market"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#btcrelay", 
            "text": "BTCrelay  :   -    More\n        information \n        (about ETH/BTC 2-way peg without modifying bitcoin code).\n    -    BTCrelay\n        audit", 
            "title": "BTCRelay"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#randao", 
            "text": "Random number * https://www.reddit.com/r/ethereum/comments/49yld7/eli5_how_does_a_service_like_szabodice_grab_a/", 
            "title": "RANDAO"
        }, 
        {
            "location": "/contracts-and-transactions/developer-tools/#the-evm-the-evm", 
            "text": "The Ethereum Virtual Machine (EVM) is the runtime environment for smart\ncontracts in Ethereum. It is not only sandboxed, but actually completely\nisolated, which means that code running inside the EVM has no access to\nnetwork, filesystem, or other processes. Smart contracts even have\nlimited access to other smart contracts.  Contracts live on the blockchain in an Ethereum-specific binary format\n(EVM bytecode). However, contracts are typically written in an Ethereum\nhigh level language, compiled into byte code using an EVM compiler, and\nfinally uploaded on the blockchain using an Ethereum client.", 
            "title": "The EVM {#the-EVM}"
        }, 
        {
            "location": "/contracts-and-transactions/ethereum-tests/", 
            "text": "Ethereum Tests {#Ethereum Tests}\n\n\nEthereum Testing Docs have been moved to\n\nhttp://ethereum-tests.readthedocs.io/\n.", 
            "title": "\u6d4b\u8bd5"
        }, 
        {
            "location": "/contracts-and-transactions/ethereum-tests/#ethereum-tests-ethereum-tests", 
            "text": "Ethereum Testing Docs have been moved to http://ethereum-tests.readthedocs.io/ .", 
            "title": "Ethereum Tests {#Ethereum Tests}"
        }, 
        {
            "location": "/contracts-and-transactions/web3-base-layer-services/", 
            "text": "Web3 Base Layer Services\n\n\nIn addition to the Ethereum blockchain, more components are being\ndeveloped that decentralise other important aspects of web applications.\n\n\n\n\nSwarm - Decentralised data storage and distribution\n\n\nSwarm is a peer to peer data sharing network in which files are\naddressed by the hash of their content. Similar to Bittorrent, it is\npossible to fetch the data from many nodes at once and as long as a\nsingle node hosts a piece of data, it will remain accessible everywhere.\nThis approach makes it possible to distribute data without having to\nhost any kind of server - data accessibility is location independent.\n\n\nOther nodes in the network can be incentivised to replicate and store\nthe data themselves, obviating the need for hosting services when the\noriginal nodes are not connected to the network.\n\n\nWhisper - Decentralised messaging\n\n\nA protocol for private, secure communication directly between nodes.\n\n\n\n\nFurthermore, standard contracts are being created to make the\ndevelopment and usage of distributed applications easier:\n\n\nName registry\n\n\nBecause dapps can be stored anywhere, including the Swarm network, the\nname registry maps names to their content or location. This is a\ndecentralised alternative to the Domain Name System (DNS).\n\n\nSee \nhttps://github.com/ethereum/EIPs/issues/26\n\n\nContract registry\n\n\nTo publish the source code of a specific contract, its address has to be\nmapped to it. The contract registry stores this mapping. Users can then\nlook up this mapping and verify the contract byte code.\n\n\nSee * global registrar code * namereg API", 
            "title": "WEB3\u57fa\u672c\u5c42\u670d\u52a1"
        }, 
        {
            "location": "/contracts-and-transactions/web3-base-layer-services/#web3-base-layer-services", 
            "text": "In addition to the Ethereum blockchain, more components are being\ndeveloped that decentralise other important aspects of web applications.", 
            "title": "Web3 Base Layer Services"
        }, 
        {
            "location": "/contracts-and-transactions/web3-base-layer-services/#swarm-decentralised-data-storage-and-distribution", 
            "text": "Swarm is a peer to peer data sharing network in which files are\naddressed by the hash of their content. Similar to Bittorrent, it is\npossible to fetch the data from many nodes at once and as long as a\nsingle node hosts a piece of data, it will remain accessible everywhere.\nThis approach makes it possible to distribute data without having to\nhost any kind of server - data accessibility is location independent.  Other nodes in the network can be incentivised to replicate and store\nthe data themselves, obviating the need for hosting services when the\noriginal nodes are not connected to the network.", 
            "title": "Swarm - Decentralised data storage and distribution"
        }, 
        {
            "location": "/contracts-and-transactions/web3-base-layer-services/#whisper-decentralised-messaging", 
            "text": "A protocol for private, secure communication directly between nodes.   Furthermore, standard contracts are being created to make the\ndevelopment and usage of distributed applications easier:", 
            "title": "Whisper - Decentralised messaging"
        }, 
        {
            "location": "/contracts-and-transactions/web3-base-layer-services/#name-registry", 
            "text": "Because dapps can be stored anywhere, including the Swarm network, the\nname registry maps names to their content or location. This is a\ndecentralised alternative to the Domain Name System (DNS).  See  https://github.com/ethereum/EIPs/issues/26", 
            "title": "Name registry"
        }, 
        {
            "location": "/contracts-and-transactions/web3-base-layer-services/#contract-registry", 
            "text": "To publish the source code of a specific contract, its address has to be\nmapped to it. The contract registry stores this mapping. Users can then\nlook up this mapping and verify the contract byte code.  See * global registrar code * namereg API", 
            "title": "Contract registry"
        }, 
        {
            "location": "/faq/faq/", 
            "text": "Frequently Asked Questions\n\n\n::: {.contents}\n:::\n\n\n\n\nlocal\n\n\n:   \n\n\ndepth\n\n\n:   2\n\n\nQuestions\n\n\n\n\n\n\nWhat is Ethereum?\n\n\nEthereum is a decentralized smart contracts platform that is powered by\na cryptocurrency called Ether. A good starting point to learn more about\nits workings would be the \\\"[what-is-ethereum]{role=\"ref\"}\\\" page.\n\n\nI have heard of Ethereum, but what are Geth, Mist, Ethminer, Mix?\n\n\n\n\nGeth\n: This is the Go implementation of an Ethereum node, and is\n    the basis for any interactions with the Ethereum blockchain. Running\n    this locally will allow you to easily interact with the Ethereum\n    blockchain. Read the \ngo-ethereum installation\n    instructions\n.\n\n\nMist\n: This is the equivalent of a web browser, but for the\n    Ethereum platform. It acts as a GUI to display the accounts and\n    contracts that you interact with. It also allows you to create and\n    interact with contracts in a graphical user interface without ever\n    touching the command line. If you are not a developer and just want\n    to store ether and interact with Ethereum contracts, then Mist is\n    the program to use. Downloads can be found on the \nMist releases\n    page\n.\n\n\nEthminer\n: A standalone miner. This can be used to mine or\n    benchmark a mining set-up. It is compatible with eth, geth, and\n    pyethereum. Check out the [mining]{role=\"ref\"} page for more\n    information.\n\n\nMix\n: The integrated development environment for DApp authoring.\n    Quickly prototype and debug decentralised applications on the\n    Ethereum platform. More information can be found at the \nMix GitHub\n    Page\n.\n\n\n\n\nHow can I store big files on the blockchain?\n\n\nIn general you do not want to store large files or pieces of data in the\nEthereum blockchain because of the high cost of storage. You will need\nto use a third party storage solution, such as Swarm or IPFS. Swarm is\nan Ethereum-specific project for distributed file storage. IPFS is an\nnon-Ethereum project which has close ties to Ethereum; it will be used\nindependently and may be used as an added layer underlying Swarm in the\nfuture. See \nthis Ethereum StackExchange post on the\ntopic\n\nfor more information.\n\n\nIs Ethereum based on Bitcoin?\n\n\nOnly in the sense that it uses a blockchain, which Bitcoin pioneered.\nEthereum has a separate blockchain that has several significant\ntechnical differences from Bitcoin\\'s blockchain. See \nthis Ethereum\nStackExchange\nanswer\n\nfor a detailed explanation.\n\n\nWhat\\'s the future of Ethereum?\n\n\nEthereum developers are planning a switch from a Proof-of-Work consensus\nmodel to a Proof-of-Stake consensus model in the future. They are also\ninvestigating scalability solutions and how to store secrets on the\nblockchain.\n\n\nWhat\\'s the difference between account and \\\"wallet contract\\\"?\n\n\nAn account is your public / private key pair file that serves as your\nidentity on the blockchain. See \\\"account\\\" in the glossary. A \\\"wallet\ncontract\\\" is an Ethereum contract that secures your ether and identity\nwith features such as multisignature signing and programmed\ndeposit/withdrawal limits. A wallet contract can be easily created in\nthe Mist Ethereum Wallet GUI client.\n\n\nAre keyfiles only accessible from the computer you downloaded the client on?\n\n\nNo, you are welcome to export or move the keyfile, but always remember\nto backup your keyfiles and be aware of which computers you store your\nkeyfile on.\n\n\nHow long should it take to download the blockchain?\n\n\nThe Ethereum blockchain is constantly growing, and is nearing 10GB as of\nMarch 2016. The amount of time it will take to download depends on the\namount of peers you are able to connect to, your internet connection\nspeed, and other factors. See the\n[download-the-blockchain-faster]{role=\"ref\"} section for tips on syncing\nthe blockchain more quickly.\n\n\nHow do I get a list of transactions into/out of an address?\n\n\nYou would have to pull the transactions manually out of the blockchain\nto achieve this. Alternatively, you can rely on third party explorers\\'\nAPI\\'s like \nEtherchain\n. For contract\nexecution transactions however, you can filter the contract logs to\nachieve this.\n\n\nCan a contract pay for its execution?\n\n\nNo this is not possible. The gas for the execution must be provided by\nthe address submitting the execution request.\n\n\nCan a contract call another contract?\n\n\nYes, this is possible, read \nabout interactions between\ncontracts\n.\n\n\nCan a transaction be signed offline and then submitted on another online device?\n\n\nYes, you can refer to the solution from\n\nIcebox\n.\n\n\nHow to get testnet Ether?\n\n\nSee [test-networks]{role=\"ref\"}.\n\n\nCan a transaction be sent by a third party? i.e can transaction broadcasting be outsourced\n\n\nTechnically yes, but there is an important restriction as opposed to\nbitcoin signed transactions: in ethereum the transaction has a nonce\n(more precisely, each account increases a counter when sending a\ntransaction based on how many transactions total have been sent. If 3\ntransactions have ever been sent from the account, the account nonce\nwould be 3).\n\n\nCan Ethereum contracts pull data using third-party APIs?\n\n\nNo, Ethereum contracts cannot pull data from external information\nsources in this way. It is however possible to push data from external\nsites (e.g. weather sites, stock prices) to Ethereum contracts through\ntransactions. There are \\\"oracle\\\" services that are compatible with the\nEthereum network that will pull/push data to the Ethereum network for a\nfee.\n\n\nIs the content of the data and contracts sent over the Ethereum network encrypted?\n\n\nData and contracts on the Ethereum network are encoded, but not\nencrypted. Everyone can audit the behavior of the contracts and the data\nsent to them. However, you are always free to encrypt data locally\nbefore broadcasting it to the network.\n\n\nCan I store secrets or passwords on the Ethereum network?\n\n\nAll data on Ethereum is public. It is not possible to store secrets or\npasswords in Ethereum contracts without it being seen by all. There is\nwork being done to make this a possibility through code obfuscation and\nother techniques. A good read would be \\\"\nPrivacy on the\nBlockchain\n\\\"\nby Vitalik Buterin.\n\n\nHow will Ethereum combat centralisation of mining pools?\n\n\nThere are two primary ways that the Ethereum PoW based consensus\nalgorithm combats mining centralisation\n(\nSource\n).\n\n\n\n\nThe first is by reducing losses due to orphaned blocks, which\n    independent miners are more likely to experience.\n\n\nThis portion of the Ethereum mining algorithm, a technique\n    referred to as GHOST, includes the headers only of recently\n    orphaned blocks in return for a reduced reward to both the block\n    producer and the includer of the (otherwise orphaned) block.\n    These included orphans from \\\"grandparent\\\" or earlier blocks\n    are frequently referred to as \\\"uncle\\\" blocks because the\n    gender neutral term \\\"ommer\\\" isn\\'t widely known or understood.\n\n\n\n\n\n\nThe second way that the Ethereum PoW consensus algorithm combats\n    mining centralisation is by its use of a Proof of Work function that\n    is ASIC resistant.\n\n\nBy preventing mining from becoming dominated by specially\n    designed and produced hardware, independent miners are kept\n    competitive or even given an advantage in terms of their profits\n    and/or levels of hardware investment, because they can make use\n    of readily available commodity hardware (i.e. consumer graphics\n    cards).\n\n\n\n\n\n\n\n\nHow will Ethereum deal with ever increasing blockchain size?\n\n\nThere are many discussions around blockchain scalability. This\nquestioned has been partially answered on \nthis Ethereum StackExchange\npost\n\nand \nthis blog post from Vitalik\nButerin\n.\n\n\nHow will Ethereum ensure the network is capable of making 10,000+ transactions-per-second?\n\n\nEthereum is planning on implementing a proof-of-stake consensus protocol\nchange during the Serenity phase of their development roadmap. More\ninformation on the likely Ethereum PoS candidate and how it may increase\ntransactions-per-second can be \nfound\nhere\n.\n\n\nWhere do the contracts reside?\n\n\nTODO\n\n\nYour question is still not answered?\n\n\nAsk the community on \nEthereum\nStackExchange\n.", 
            "title": "\u5e38\u89c1\u95ee\u9898"
        }, 
        {
            "location": "/faq/faq/#frequently-asked-questions", 
            "text": "::: {.contents}\n:::   local  :     depth  :   2  Questions", 
            "title": "Frequently Asked Questions"
        }, 
        {
            "location": "/faq/faq/#what-is-ethereum", 
            "text": "Ethereum is a decentralized smart contracts platform that is powered by\na cryptocurrency called Ether. A good starting point to learn more about\nits workings would be the \\\"[what-is-ethereum]{role=\"ref\"}\\\" page.", 
            "title": "What is Ethereum?"
        }, 
        {
            "location": "/faq/faq/#i-have-heard-of-ethereum-but-what-are-geth-mist-ethminer-mix", 
            "text": "Geth : This is the Go implementation of an Ethereum node, and is\n    the basis for any interactions with the Ethereum blockchain. Running\n    this locally will allow you to easily interact with the Ethereum\n    blockchain. Read the  go-ethereum installation\n    instructions .  Mist : This is the equivalent of a web browser, but for the\n    Ethereum platform. It acts as a GUI to display the accounts and\n    contracts that you interact with. It also allows you to create and\n    interact with contracts in a graphical user interface without ever\n    touching the command line. If you are not a developer and just want\n    to store ether and interact with Ethereum contracts, then Mist is\n    the program to use. Downloads can be found on the  Mist releases\n    page .  Ethminer : A standalone miner. This can be used to mine or\n    benchmark a mining set-up. It is compatible with eth, geth, and\n    pyethereum. Check out the [mining]{role=\"ref\"} page for more\n    information.  Mix : The integrated development environment for DApp authoring.\n    Quickly prototype and debug decentralised applications on the\n    Ethereum platform. More information can be found at the  Mix GitHub\n    Page .", 
            "title": "I have heard of Ethereum, but what are Geth, Mist, Ethminer, Mix?"
        }, 
        {
            "location": "/faq/faq/#how-can-i-store-big-files-on-the-blockchain", 
            "text": "In general you do not want to store large files or pieces of data in the\nEthereum blockchain because of the high cost of storage. You will need\nto use a third party storage solution, such as Swarm or IPFS. Swarm is\nan Ethereum-specific project for distributed file storage. IPFS is an\nnon-Ethereum project which has close ties to Ethereum; it will be used\nindependently and may be used as an added layer underlying Swarm in the\nfuture. See  this Ethereum StackExchange post on the\ntopic \nfor more information.", 
            "title": "How can I store big files on the blockchain?"
        }, 
        {
            "location": "/faq/faq/#is-ethereum-based-on-bitcoin", 
            "text": "Only in the sense that it uses a blockchain, which Bitcoin pioneered.\nEthereum has a separate blockchain that has several significant\ntechnical differences from Bitcoin\\'s blockchain. See  this Ethereum\nStackExchange\nanswer \nfor a detailed explanation.", 
            "title": "Is Ethereum based on Bitcoin?"
        }, 
        {
            "location": "/faq/faq/#whats-the-future-of-ethereum", 
            "text": "Ethereum developers are planning a switch from a Proof-of-Work consensus\nmodel to a Proof-of-Stake consensus model in the future. They are also\ninvestigating scalability solutions and how to store secrets on the\nblockchain.", 
            "title": "What\\'s the future of Ethereum?"
        }, 
        {
            "location": "/faq/faq/#whats-the-difference-between-account-and-wallet-contract", 
            "text": "An account is your public / private key pair file that serves as your\nidentity on the blockchain. See \\\"account\\\" in the glossary. A \\\"wallet\ncontract\\\" is an Ethereum contract that secures your ether and identity\nwith features such as multisignature signing and programmed\ndeposit/withdrawal limits. A wallet contract can be easily created in\nthe Mist Ethereum Wallet GUI client.", 
            "title": "What\\'s the difference between account and \\\"wallet contract\\\"?"
        }, 
        {
            "location": "/faq/faq/#are-keyfiles-only-accessible-from-the-computer-you-downloaded-the-client-on", 
            "text": "No, you are welcome to export or move the keyfile, but always remember\nto backup your keyfiles and be aware of which computers you store your\nkeyfile on.", 
            "title": "Are keyfiles only accessible from the computer you downloaded the client on?"
        }, 
        {
            "location": "/faq/faq/#how-long-should-it-take-to-download-the-blockchain", 
            "text": "The Ethereum blockchain is constantly growing, and is nearing 10GB as of\nMarch 2016. The amount of time it will take to download depends on the\namount of peers you are able to connect to, your internet connection\nspeed, and other factors. See the\n[download-the-blockchain-faster]{role=\"ref\"} section for tips on syncing\nthe blockchain more quickly.", 
            "title": "How long should it take to download the blockchain?"
        }, 
        {
            "location": "/faq/faq/#how-do-i-get-a-list-of-transactions-intoout-of-an-address", 
            "text": "You would have to pull the transactions manually out of the blockchain\nto achieve this. Alternatively, you can rely on third party explorers\\'\nAPI\\'s like  Etherchain . For contract\nexecution transactions however, you can filter the contract logs to\nachieve this.", 
            "title": "How do I get a list of transactions into/out of an address?"
        }, 
        {
            "location": "/faq/faq/#can-a-contract-pay-for-its-execution", 
            "text": "No this is not possible. The gas for the execution must be provided by\nthe address submitting the execution request.", 
            "title": "Can a contract pay for its execution?"
        }, 
        {
            "location": "/faq/faq/#can-a-contract-call-another-contract", 
            "text": "Yes, this is possible, read  about interactions between\ncontracts .", 
            "title": "Can a contract call another contract?"
        }, 
        {
            "location": "/faq/faq/#can-a-transaction-be-signed-offline-and-then-submitted-on-another-online-device", 
            "text": "Yes, you can refer to the solution from Icebox .", 
            "title": "Can a transaction be signed offline and then submitted on another online device?"
        }, 
        {
            "location": "/faq/faq/#how-to-get-testnet-ether", 
            "text": "See [test-networks]{role=\"ref\"}.", 
            "title": "How to get testnet Ether?"
        }, 
        {
            "location": "/faq/faq/#can-a-transaction-be-sent-by-a-third-party-ie-can-transaction-broadcasting-be-outsourced", 
            "text": "Technically yes, but there is an important restriction as opposed to\nbitcoin signed transactions: in ethereum the transaction has a nonce\n(more precisely, each account increases a counter when sending a\ntransaction based on how many transactions total have been sent. If 3\ntransactions have ever been sent from the account, the account nonce\nwould be 3).", 
            "title": "Can a transaction be sent by a third party? i.e can transaction broadcasting be outsourced"
        }, 
        {
            "location": "/faq/faq/#can-ethereum-contracts-pull-data-using-third-party-apis", 
            "text": "No, Ethereum contracts cannot pull data from external information\nsources in this way. It is however possible to push data from external\nsites (e.g. weather sites, stock prices) to Ethereum contracts through\ntransactions. There are \\\"oracle\\\" services that are compatible with the\nEthereum network that will pull/push data to the Ethereum network for a\nfee.", 
            "title": "Can Ethereum contracts pull data using third-party APIs?"
        }, 
        {
            "location": "/faq/faq/#is-the-content-of-the-data-and-contracts-sent-over-the-ethereum-network-encrypted", 
            "text": "Data and contracts on the Ethereum network are encoded, but not\nencrypted. Everyone can audit the behavior of the contracts and the data\nsent to them. However, you are always free to encrypt data locally\nbefore broadcasting it to the network.", 
            "title": "Is the content of the data and contracts sent over the Ethereum network encrypted?"
        }, 
        {
            "location": "/faq/faq/#can-i-store-secrets-or-passwords-on-the-ethereum-network", 
            "text": "All data on Ethereum is public. It is not possible to store secrets or\npasswords in Ethereum contracts without it being seen by all. There is\nwork being done to make this a possibility through code obfuscation and\nother techniques. A good read would be \\\" Privacy on the\nBlockchain \\\"\nby Vitalik Buterin.", 
            "title": "Can I store secrets or passwords on the Ethereum network?"
        }, 
        {
            "location": "/faq/faq/#how-will-ethereum-combat-centralisation-of-mining-pools", 
            "text": "There are two primary ways that the Ethereum PoW based consensus\nalgorithm combats mining centralisation\n( Source ).   The first is by reducing losses due to orphaned blocks, which\n    independent miners are more likely to experience.  This portion of the Ethereum mining algorithm, a technique\n    referred to as GHOST, includes the headers only of recently\n    orphaned blocks in return for a reduced reward to both the block\n    producer and the includer of the (otherwise orphaned) block.\n    These included orphans from \\\"grandparent\\\" or earlier blocks\n    are frequently referred to as \\\"uncle\\\" blocks because the\n    gender neutral term \\\"ommer\\\" isn\\'t widely known or understood.    The second way that the Ethereum PoW consensus algorithm combats\n    mining centralisation is by its use of a Proof of Work function that\n    is ASIC resistant.  By preventing mining from becoming dominated by specially\n    designed and produced hardware, independent miners are kept\n    competitive or even given an advantage in terms of their profits\n    and/or levels of hardware investment, because they can make use\n    of readily available commodity hardware (i.e. consumer graphics\n    cards).", 
            "title": "How will Ethereum combat centralisation of mining pools?"
        }, 
        {
            "location": "/faq/faq/#how-will-ethereum-deal-with-ever-increasing-blockchain-size", 
            "text": "There are many discussions around blockchain scalability. This\nquestioned has been partially answered on  this Ethereum StackExchange\npost \nand  this blog post from Vitalik\nButerin .", 
            "title": "How will Ethereum deal with ever increasing blockchain size?"
        }, 
        {
            "location": "/faq/faq/#how-will-ethereum-ensure-the-network-is-capable-of-making-10000-transactions-per-second", 
            "text": "Ethereum is planning on implementing a proof-of-stake consensus protocol\nchange during the Serenity phase of their development roadmap. More\ninformation on the likely Ethereum PoS candidate and how it may increase\ntransactions-per-second can be  found\nhere .", 
            "title": "How will Ethereum ensure the network is capable of making 10,000+ transactions-per-second?"
        }, 
        {
            "location": "/faq/faq/#where-do-the-contracts-reside", 
            "text": "TODO", 
            "title": "Where do the contracts reside?"
        }, 
        {
            "location": "/faq/faq/#your-question-is-still-not-answered", 
            "text": "Ask the community on  Ethereum\nStackExchange .", 
            "title": "Your question is still not answered?"
        }, 
        {
            "location": "/glossary/", 
            "text": "\u8bcd\u6c47\u8868\n\n\nDAO - \u5206\u5e03\u5f0f\u81ea\u6cbb\u7ec4\u7ec7\n\u5206\u5e03\u5f0f\u81ea\u6cbb\u7ec4\u7ec7DAO\u662f\u533a\u5757\u94fe\u4e0a\u7684\u5408\u7ea6\u7c7b\u578b (\u6216\u4e00\u5957\u5408\u540c) \u8fd9\u662f\u5e94\u8be5\u7f16\u7e82\u7684, \u6267\u884c\u6216\u81ea\u52a8\u5316\u7ec4\u7ec7\u7684\u8fd0\u4f5c\uff0c\u5305\u62ec\u6cbb\u7406\uff0c\u7b79\u6b3e\uff0c\u8fd0\u8425\uff0c\u652f\u51fa\u548c\u6269\u5f20\u3002\nidentity\nA set of cryptographically verifiable interactions that have the\nproperty that they were all created by the same person.\ndigital identity\nThe set of cryptographically verifiable transactions signed by the\nsame public key define the digital identity\\'s behavior. In many\nreal world scenarios (voting) it is desireable that digital\nidentities coincide with real world identities. Ensuring this\nwithout violence is an unsolved problem.\nunique identity\nA set of cryptographically verifiable interactions that have the\nproperty that they were all created by the same person, with the\nadded constraint that one person cannot have multiple unique\nidentities.\nreputation\nThe property of an identity that other entities believe that\nidentity to be either (1) competent at some specific task, or (2)\ntrustworthy in some context, i.e., not likely to betray others even\nif short-term profitable.\nescrow\nIf two mutually-untrusting entities are engaged in commerce, they\nmay wish to pass funds through a mutually trusted third party and\ninstruct that party to send the funds to the payee only when\nevidence of product delivery has been shown. This reduces the risk\nof the payer or payee committing fraud. Both this construction and\nthe third party is called escrow.\ndeposit\nDigital property placed into a contract involving another party such\nthat if certain conditions are not satisfied that property is\nautomatically forfeited and either credited to a counterparty as\ninsurance against the conditions, or destroyed (= burnt = equally\ndistributed) or donated to some charitable funds.\nweb of trust\nThe idea that if A highly rates B, and B highly rates C, then A is\nlikely to trust C. Complicated and powerful mechanisms for\ndetermining the reliability of specific individuals in specific\nconcepts can theoretically be gathered from this principle.\nincentive compatibility\nA protocol is incentive-compatible if everyone is better off\n\\\"following the rules\\\" than attempting to cheat, at least unless a\nvery large number of people agree to cheat together at the same time\n(collusion).\ncollusion\nIn an incentivized protocol scenario, when a number of participants\nplay together\n (conspire) to game the rules to their own benefit.\ntoken system\nA fungible virtual good that can be traded. More formally, a token\nsystem is a database mapping addresses to numbers with the property\nthat the primary allowed operation is a transfer of N tokens from A\nto B, with the conditions that N is non-negative, N is not greater\nthan A\\'s current balance, and a document authorizing the transfer\nis digitally signed by A. Secondary \\\"issuance\\\" and \\\"consumption\\\"\noperations may also exist, transaction fees may also be collected,\nand simultaneous multi-transfers with many parties may be possible.\nTypical use cases include currencies, cryptographic tokens inside of\nnetworks, company shares and digital gift cards.\nblock\nA block is a package of data that contains zero or more\ntransactions, the hash of the previous block (\\\"parent\\\"), and\noptionally other data. The total set of blocks, with every block\nexcept for the initial \\\"genesis block\\\" containing the hash of its\nparent, is called the blockchain and contains the entire transaction\nhistory of a network. Note that some blockchain-based\ncryptocurrencies use the word \\\"ledger\\\" instead of blockchain; the\ntwo are roughly equivalent, although in systems that use the term\n\\\"ledger\\\" each block generally contains a full copy of the current\nstate (e.g. currency balances, partially fulfilled contracts,\nregistrations) of every account allowing users to discard outdated\nhistorical data.\naddress\nAn Ethereum address represents an account. For\n[EOA](EOAExternally%20Owned%20Account.%20An%20account%20controlled%20by%20a%20private%20key.%20If%20you%20own%20the%20private%20key%20associated%20with%20the%20EOA%20you%20have%20the%20ability%20to%20send%20ether%20and%20messages%20from%20it.%20Contract%20accounts%20also%20have%20an%20address,%20see%20:ref:%60Accounts%60.%20EOAs%20and%20contract%20accounts%20may%20be%20combined%20into%20a%20single%20account%20type%20during%20Serenity.),\nthe address is derived as the last 20 bytes of the public key\ncontrolling the account, e.g.,\ncd2a3d9f938e13cd947ec05abc7fe734df8dd826. This is a\n[hexadecimal](hexadecimalCommon%20representation%20format%20for%20byte%20sequencing.%20Its%20advantage%20is%20that%20values%20are%20represented%20in%20a%20compact%20format%20using%20two%20characters%20per%20byte%20(the%20characters%20%60%60%5B0-9%5D%5Ba-f%5D%60%60).)\nformat (base 16 notation), which is often indicated explicitly by\nappending 0x to the address. Web3.js and console functions accept\naddresses with or without this prefix but for transparency we\nencourage their use. Since each byte of the address is represented\nby 2 hex characters, a prefixed address is 42 characters long.\nSeveral apps and APIs are also meant to implement the new\n[checksum-enabled address\nscheme](\nhttps://github.com/ethereum/EIPs/issues/55\n) introduced in\nthe Mist Ethereum wallet as of version 0.5.0.\nether\nEther is the name of the currency used within Ethereum. It is used\nto pay for computations within the EVM. Ambiguously, ether is also\nthe name of a unit in the system;\ntransaction\nThe signed data package that stores a message to be sent from an\nexternally owned account. Simply put, a transaction describes a\ntransfer of information from an EOA to another EOA or a contract\naccount.\nmessage\nA data transfer mechanism contracts use to communicate with other\ncontracts. Messages can also be described as virtual objects that\nare never serialized and exist only in the Ethereum execution\nenvironment.\nWeb3\nThe exact definition of the Web3 paradigm is still taking form, but\nit generally refers to the phenomenon of increased connectedness\nbetween all kinds of devices, decentralization of services and\napplications, semantic storage of information online and application\nof artificial intelligence to the web.\nDAO\nSee Decentralized Autonomous Organization.\nepoch\nEpoch is the interval between each regeneration of the DAG used as\nseed by the PoW algorithm Ethash. The epoch in specified as 30000\nblocks.\nelliptic curve (cryptography)\nRefers to an approach to public-key cryptography based on the\nalgebraic structure of elliptic curves over finite fields. See\n[elliptic curve\ncryptography](\nhttps://en.wikipedia.org/wiki/Elliptic_curve_cryptography\n).\nwallet\nA wallet, in the most generic sense, refers to anything that can\nstore ether or any other crypto token. In the crypto space in\ngeneral, the term wallet is used to mean anything from a single\nprivate/public key pair (like a single paper wallet) all the way to\napplications that manage multiple key pairs, like the Mist Ethereum\nwallet.\ncontract\nA persistent piece of code on the Ethereum blockchain that\nencompasses a set of data and executable functions. These functions\nexecute when Ethereum transactions are made to them with certain\ninput parameters. Based on the input parameters, the functions will\nexecute and interact with data within and outside of the contract.\nsuicide\nSee self-destruct. selfdestruct acts as an alias to the deprecated\nsuicide terminology in accordance with [EIP 6 - Renaming SUICIDE\nOPCODE](\nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-6.md\n).\nselfdestruct\nA global variable in the Solidity language that allows you to\n[\\\"destroy the current contract, sending its funds to the given\naddress\\\"](\nhttps://solidity.readthedocs.org/en/latest/miscellaneous.html#global-variables\n).\nselfdestruct acts as an alias to the deprecated suicide terminology\nin accordance with [EIP 6 - Renaming SUICIDE\nOPCODE](\nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-6.md\n).\nIt frees up space on the blockchain and prevents future execution of\nthe contract. The contract\\'s address will still persist, but ether\nsent to it will be lost forever. The possibility to kill a contract\nhas to be implemented by the contract creator him/herself using the\nSolidity selfdestruct function.\ntransaction fee\nAlso known as gas cost, it is the amount of ether that the miners\nwill charge for the execution of your transaction.\nmining\nThe process of verifying transactions and contract execution on the\nEthereum blockchain in exchange for a reward in ether with the\nmining of every block.\nmining pool\nThe pooling of resources by miners, who share their processing power\nover a network, to split the reward equally, according to the amount\nof work they contributed to solving a block.\nmining reward\nThe amount of cryptographic tokens (in this case ether) that is\ngiven to the miner who mined a new block.\nstate\nRefers to a snapshot of all balances and data at a particular point\nin time on the blockchain, normally referring to the condition at a\nparticular block.\nblockchain\nAn ever-extending series of data blocks that grows as new\ntransactions are confirmed as part of a new block. Each new block is\nchained to the existing blockchain by a cryptographic proof-of-work.\npeer\nOther computers on the network also running an Ethereum node (Geth)\nwith an exact copy of the blockchain that you have.\nsigning\nProducing a piece of data from the data to be signed using your\nprivate key, to prove that the data originates from you.\ndiscovery (peer)\nThe process of \\'gossiping\\' with other nodes in the network to find\nout the state of other nodes on the network.\ngas price oracle\nA helper function of the Geth client that tries to find an\nappropriate default gas price when sending transactions.\nlight client\nA client program that allows users in low-capacity environments to\nstill be able to execute and check the execution of transactions\nwithout needing to run a full Ethereum node (Geth).\netherbase\nIt is the default name of the account on your node that acts as your\nprimary account. If you do mining, mining rewards will be credited\nto this account.\ncoinbase\nCoinbase is analogous to etherbase, but is a more generic term for\nall cryptocurrency platforms.\nbalance\nThe amount of cryptocurrency (in this case) belonging to an account.\nsolidity\nSolidity is a high-level language whose syntax is similar to that of\nJavaScript and it is designed to compile to code for the Ethereum\nVirtual Machine.\nserpent\nSerpent is a high-level language whose syntax is similar to that of\nPython and it is designed to compile to code for the Ethereum\nVirtual Machine.\nEVM\nEthereum Virtual Machine, the decentralized computing platform which\nforms the core of the Ethereum platform.\nvirtual machine\nIn computing, it refers to an emulation of a particular computer\n    system.\npeer to peer network\nA network of computers that are collectively able to perform\nfunctionalities normally only possible with centralized,\nserver-based services.\ndecentralization\nThe concept of moving the control and execution of computational\nprocesses away from a central entity.\ndistributed hash table\nA distributed hash table (DHT) is a class of a decentralized\ndistributed system that provides a lookup service similar to a hash\ntable    (key, value) pairs are stored in a DHT, and any participating\nnode can efficiently retrieve the value associated with a given key.\nNAT\nNetwork address translation (NAT) is a methodology of remapping one\nIP address space into another by modifying network address\ninformation in Internet Protocol (IP) datagram packet headers while\nthey are in transit across a traffic routing device.\nnonce\nNumber Used Once or Number Once. A nonce, in information technology,\nis a number generated for a specific use, such as session\nauthentication. Typically, a nonce is some value that varies with\ntime, although a very large random number is sometimes used. In\ngeneral usage, nonce means \\\"for the immediate occasion\\\" or \\\"for\nnow.\\\" In the case of Blockchain Proof of Work scenarios, the hash\nvalue, found by a Miner, matching the network\\'s Difficulty thus\nproving the Block Validity is called Nonce as well.\nproof-of-work\nOften seen in its abbreviated form \\\"PoW\\\", it refers to a\nmathematical value that can act as the proof of having solved a\nresource and time consuming computational problem.\nproof-of-stake\nAn alternative method of mining blocks that require miners to\ndemonstrate their possession of a certain amount of the currency of\nthe network in question. This works on the principle that miners\nwill be disincentivized to try to undermine a network in which they\nhave a stake. PoS is less wasteful than PoW, but is still often used\ntogether with it to provide added security to the network.\nCASPER\nCasper is a security-deposit based economic consensus protocol. This\nmeans that nodes, so called \\\"bonded validators\\\", have to place a\nsecurity deposit (an action we call \\\"bonding\\\") in order to serve\nthe consensus by producing blocks. If a validator produces anything\nthat Casper considers \\\"invalid\\\", the deposit is forfeited along\nwith the privilege of participating in the consensus process.\nconsensus\nThe agreement among all nodes in the network about the state of the\nEthereum network.\nhomestead\nHomestead is the second major version release of the Ethereum\nplatform. Homestead includes several protocol changes and a\nnetworking change that makes possible further network upgrades:\n[EIP-2 Main homestead hardfork\nchanges](\nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-2.mediawiki\n);\n[EIP-7 Hardfork EVM update\n(DELEGATECALL)](\nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-7.md\n);\n[EIP-8 devp2p forward\ncompatibility](\nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-8.md\n).\nHomestead will launch when block 1,150,000 is reached on the\nMainnet. On the Testnet, Homestead will launch at block 494,000.\nmetropolis\nThe third stage of Ethereum\\'s release. This is the stage when the\nuser interfaces come out (e.g. Mist), including a dapp store, and\nnon-technical users should feel comfortable joining at this point.\nserenity\nThe fourth stage of Ethereum\\'s release. This is when things are\ngoing to get fancy    the network is going to change its mining\nprocess from Proof-of-Work to Proof-of-Stake.\nfrontier\nEthereum was planned to be released in four major steps with\nFrontier being the name for the first phase. The Frontier release\nwent live on July 30th, 2015. The command line Frontier phase was\nmainly meant to get mining operations going with the full reward of\n5 ether per block and also to promote the emergence of ether\nexchanges. Frontier surpassed earlier modest expectations and has\nnurtured tremendous growth of the ecosystem.\nolympic\nThe Frontier pre-release, which launched on May 9th 2015. It was\nmeant for developers to help test the limits of the Ethereum\nblockchain.\nmorden\nMorden is the first Ethereum alternative testnet. It is expected to\ncontinue throughout the Frontier and Homestead era.\ntestnet\nA mirror network of the production Ethereum network that is meant\nfor testing. See Morden.\nprivate chain\nA fully private blockchain is a blockchain where write permissions\nare kept centralized to one organization.\nconsortium chain\nA blockchain where the consensus process is controlled by a\npre-selected set of nodes.\nmicropayment\nA micropayment is a financial transaction involving a very small sum\nof money (\\\n1 USD) and usually one that occurs online.\nsharding\nThe splitting of the space of possible accounts (contracts are\naccounts too) into subspaces, for example, based on first digits of\ntheir numerical addresses. This allows for contract executions to be\nexecuted within \\'shards\\' instead of network wide, allowing for\nfaster transactions and greater scalability.\nhash\nA cryptographic function which takes an input (or \\'message\\') and\nreturns a fixed-size alphanumeric string, which is called the hash\nvalue (sometimes called a message digest, a digital fingerprint, a\ndigest or a checksum). A hash function (or hash algorithm) is a\nprocess by which a document (i.e. a piece of data or file) is\nprocessed into a small piece of data (usually 32 bytes) which looks\ncompletely random, and from which no meaningful data can be\nrecovered about the document, but which has the important property\nthat the result of hashing one particular document is always the\nsame. Additionally, it is crucially important that it is\ncomputationally infeasible to find two documents that have the same\nhash. Generally, changing even one letter in a document will\ncompletely randomize the hash; for example, the SHA3 hash of\n\\\"Saturday\\\" is\nc38bbc8e93c09f6ed3fe39b5135da91ad1a99d397ef16948606cdcbd14929f9d,\nwhereas the SHA3 hash of \\\"Caturday\\\" is\nb4013c0eed56d5a0b448b02ec1d10dd18c1b3832068fbbdc65b98fa9b14b6dbf.\nHashes are usually used as a way of creating a globally agreed-upon\nidentifier for a particular document that cannot be forged.\ncrypto-fuel\nSimilar to \\'gas\\', referring to the amount of cryptocurrency\nrequired to power a transaction.\ncryptoeconomics\nThe economics of cryptocurrencies.\nprotocol\nA standard used to define a method of exchanging data over a\ncomputer network.\nblock validation\nThe checking of the coherence of the cryptographic signature of the\nblock with the history stored in the entire blockchain.\nblocktime\nThe average time interval between the mining of two blocks.\nnetwork hashrate\nThe number of hash calculations the network can make per second\ncollectively.\nhashrate\nThe number of hash calculations made per second.\nserialization\nThe process of converting a data structure into a sequence of bytes.\nEthereum internally uses an encoding format called recursive-length\nprefix encoding (RLP), described in the [RLP section of the\nwiki](\nhttps://github.com/ethereum/wiki/wiki/RLP\n).\ndouble spend\nA deliberate blockchain fork, where a user with a large amount of\nmining power sends a transaction to purchase some produce, then\nafter receiving the product creates another transaction sending the\nsame coins to themselves. The attacker then creates a block, at the\nsame level as the block containing the original transaction but\ncontaining the second transaction instead, and starts mining on the\nfork. If the attacker has more than 50% of all mining power, the\ndouble spend is guaranteed to succeed eventually at any block depth.\nBelow 50%, there is some probability of success, but it is usually\nonly substantial at a depth up to about 2-5; for this reason, most\ncryptocurrency exchanges, gambling sites and financial services wait\nuntil six blocks have been produced (\\\"six confirmations\\\") before\naccepting a payment.\nSPV client\nA client that downloads only a small part of the blockchain,\nallowing users of low-power or low-storage hardware like smartphones\nand laptops to maintain almost the same guarantee of security by\nsometimes selectively downloading small parts of the state without\nneeding to spend megabytes of bandwidth and gigabytes of storage on\nfull blockchain validation and maintenance. See light client.\nuncle\nUncles are blockchain blocks found by a miner, when a different\nminer has already found another block for the corresponding place in\nthe blockchain. They are called \\\"stale blocks\\\". The parent of an\nUncle is an ancestor of the inserting block, located at the tip of\nthe blockchain. In contrast to the Bitcoin network, Ethereum rewards\nstale blocks as well in order to avoid to penalize miners with a bad\nconnection to the network. This is less critical in the Bitcoin\nnetwork, because the Block Time there is much higher (\\~10 minutes)\nthan on the Ethereum network (aimed to \\~15 seconds).\nGHOST\nGreedy Heaviest-Observed Sub-Tree is an alternative chain-selection\nmethod that is designed to incentivize stale blocks (uncles) as\nwell, thus reducing the incentive for pool mining. In GHOST, even\nthe confirmation given by stale blocks to previous blocks are\nconsidered valid, and the miners of the stale blocks are also\nrewarded with a mining reward.\nmerkle patricia tree\nMerkle Patricia trees provide a cryptographically authenticated data\nstructure that can be used to store all (key, value) bindings. They\nare fully deterministic, meaning that a Patricia tree with the same\n(key,value) bindings is guaranteed to be exactly the same down to\nthe last byte and therefore have the same root hash, provide\nO(log(n)) efficiency for inserts, lookups and deletes, and are much\neasier to understand and code than more complex comparison-based\nalternatives like red-black trees.\nDAG\nDAG stands for Directed Acyclic Graph. It is a graph, a set of nodes\nand links between nodes, that has very special properties. Ethereum\nuses a DAG in Ethash, the Ethereum Proof of Work (POW) algorithm.The\nEthash DAG takes a long time to be generated, which is done by a\nMiner node into a cache file for each Epoch. The file data is then\nused when a value from this graph is required by the algorithm.\nuncle rate\nThe number of uncles produced per block.\nissuance\nThe minting and granting of new cryptocurrency to a miner who has\nfound a new block.\npresale\nSale of cryptocurrency before the actual launch of the network.\nstatic node\nA feature supported by Geth, the Golang Ethereum client, which makes\nit possible to always connect to specific peers. Static nodes are\nre-connected on disconnects. For details, see the [section on\nstatic nodes \\\ncr-static-nodes>]{role=\\\"ref\\\"}.\nbootnode\nThe nodes which can be used to initiate the discovery process when\nrunning a node. The endpoints of these nodes are recorded in the\nEthereum source code.\nexchange\nAn online marketplace which facilitates the exchange of crypto or\nfiat currencies based on the market exchange rate.\ncompiler\nA program that translates pieces of code written in high level\nlanguages into low level executable code.\ngenesis block\nThe first block in a blockchain.\nnetwork id\nA number which identifies a particular version of the Ethereum\nnetwork.\nblock header\nThe data in a block which is unique to its content and the\ncircumstances in which it was created. It includes the hash of the\nprevious block\\'s header, the version of the software the block is\nmined with, the timestamp and the merkle root hash of the contents\nof the block.\npending transaction\nA transaction that is not yet confirmed by the Ethereum network.\nblock propagation\nThe process of transmitting a confirmed block to all other nodes in\nthe network.\nsidechain\nA blockchain that branches off a main blockchain and checks in\nperiodically with the main blockchain. Besides that it runs\nindependently from the main chain, and any security compromises in\nthe sidechain will not affect the main chain.\npegging\nLocking down the exchange rate of the coins/tokens in two chains\n(usually a main and a side chain) in a certain direction.\n2-way pegging\nLocking down the exchange rate of the coins/tokens in two chains\n(usually a main and a side chain) in both directions.\ntrustless\nRefers to the ability of a network to trustworthily mediate\ntransactions without any of the involved parties needing to trust\nanyone else.\nfaucet\nA website that dispenses (normally testnet) cryptocurrencies for free.\nchecksum\nA count of the number of bits in a transmission that is included\nwith the unit so that the receiving end can verify that the entirety\nof the message has been transmitted.\nICAP\nInterexchange Client Address Protocol, an IBAN-compatible system for\nreferencing and transacting to client accounts aimed to streamline\nthe process of transferring funds, worry-free between exchanges and,\nultimately, making KYC and AML concerns a thing of the past.\nprivate key\nA private key is a string of characters known only to the owner,\nthat is paired with a public key to set off algorithms for text\nencryption and decryption.\npublic key\nA string of characters derived from a private key that can be made\npublic. The public key can be used to verify the authenticity of any\nsignature created using the private key.\nencryption\nEncryption is the conversion of electronic data into a form\nunreadable by anyone except the owner of the correct decryption key.\nIt can further be described as a process by which a document\n(plaintext) is combined with a shorter string of data, called a key\n(e.g.\nc85ef7d79691fe79573b1a7064c19c1a9819ebdbd1faaab1a8ec92344438aaf4),\nto produce an output (ciphertext) which can be \\\"decrypted\\\" back\ninto the original plaintext by someone else who has the key, but\nwhich is incomprehensible and computationally infeasible to decrypt\nfor anyone who does not have the key.\ndigital signature\nA mathematical scheme for demonstrating the authenticity of a\ndigital message or documents.\nport\nA network port is a communication endpoint used by a one of the\nexisting standards of establishing a network conversation (e.g. TCP,\nUDP).\nRPC\nRemote Procedure Call, a protocol that a program uses to request a\nservice from a program located in another computer in a network\nwithout having to understand the network details.\nIPC\nInterprocess communication (IPC) is a set of programming interfaces\nthat allow a programmer to coordinate activities among different\nprogram processes that can run concurrently in an operating system.\nattach\nThe command used to initiate the Ethereum Javascript console.\ndaemon\nA computer program that runs as a background process instead of in\ndirect control by an interactive user.\nsystem service\nSee base layer service\nbase layer service\nServices such as SWARM and Whisper which are built into the Ethereum platform.\njs\nJavascript.\nsyncing\nThe process of downloading the entire blockchain.\nfast sync\nInstead of processing the entire block-chain one link at a time, and\nreplay all transactions that ever happened in history, fast syncing\ndownloads the transaction receipts along the blocks, and pulls an\nentire recent state database.\nASIC\nApplication-specific integrated circuit, in this case referring to\nan integrated circuit custom built for cryptocurrency mining.\nmemory-hard\nMemory hard functions are processes that experience a drastic\ndecrease in speed or feasibility when the amount of available memory\neven slightly decreases.\nkeyfile\nEvery account\\'s private key/address pair exists as a single\nkeyfile. These are JSON text files which contains the encrypted\nprivate key of the account, which can only be decrypted with the\npassword entered during account creation.\nICAP format\nThe format of the IBANs defined using the [Inter-exchange Client\nAddress Protocol](\nhttps://github.com/ethereumjs/ethereumjs-icap\n).\nblock(chain) explorer\nA website that allows easy searching and extraction of data from the blockchain.\ngeth\nEthereum client implemented in the Golang programming language,\nbased on the protocol as defined in the Ethereum Yellow Paper.\neth\nEthereum client implemented in the C++ programming language, based\non the protocol as defined in the Ethereum Yellow Paper.\nethereumjs\nEthereum client implemented in the Javascript/Node programming\nlanguage, based on the protocol as defined in the Ethereum Yellow\nPaper.\npyethereum\nEthereum client implemented in the Python programming language,\nbased on the protocol as defined in the Ethereum Yellow Paper.\nethereumj\nEthereum client implemented in the Java programming language, based\non the protocol as defined in the Ethereum Yellow Paper.\nethereumh\nEthereum client implemented in the Haskell programming language,\nbased on the protocol as defined in the Ethereum Yellow Paper.\nparity\nEthereum client implemented in the Rust programming language, based\non the protocol as defined in the Ethereum Yellow Paper.\ndifficulty\nIn very general terms, the amount of effort required to mine a new\nblock. With the launch of Homestead, the [difficulty adjustment\nalgorithm will\nchange](\nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-2.md\n).\naccount\nAccounts are a central part of the Ethereum network and are an\nessential part of any transaction or contract. In Ethereum, there\nare two types of accounts    Externally Owned accounts (EOA) and\nContract accounts.\nHLL (obsolete)\nAcronym for Higher Level Language, which is what Serpent and\nSolidity are. HLL is what early \u00d0app developers called Ethereum\nprogramming languages that did not touch the low level elements.\nThis phrase has been phased out.\nCLL (obsolete)\nAcronym for C Like Language, which Mutan was. This acronym has been phased out.\"\nES1, ES2, and ES3 (obsolete)\n\\\"Ethereum Script\\\" versions 1,2 and 3. There were early versions of\nwhat would become the Ethereum Virtual Machine (EVM).\nlog event\nContracts are triggered by transactions executed as part of the\nblock verification. If conceived of as a function call, contract\nexecution is asynchronous, and therefore they have no return value.\nInstead contracts communicate to the outside world with log events.\nThe log events are part of the transaction receipt which is produced\nwhen the transaction is executed. The receipts are stored in the\nreceipt trie, the integrity of which is guaranteed by the fact that\nthe current root of the receipt trie is part of the block header\nalongside the roots of state and state-trie. In a broad sense from\nthe external perspective receipts are part of the Ethereum system\nstate except that they are not readable contracts internally.", 
            "title": "\u672f\u8bed"
        }, 
        {
            "location": "/glossary/#_1", 
            "text": "DAO - \u5206\u5e03\u5f0f\u81ea\u6cbb\u7ec4\u7ec7 \u5206\u5e03\u5f0f\u81ea\u6cbb\u7ec4\u7ec7DAO\u662f\u533a\u5757\u94fe\u4e0a\u7684\u5408\u7ea6\u7c7b\u578b (\u6216\u4e00\u5957\u5408\u540c) \u8fd9\u662f\u5e94\u8be5\u7f16\u7e82\u7684, \u6267\u884c\u6216\u81ea\u52a8\u5316\u7ec4\u7ec7\u7684\u8fd0\u4f5c\uff0c\u5305\u62ec\u6cbb\u7406\uff0c\u7b79\u6b3e\uff0c\u8fd0\u8425\uff0c\u652f\u51fa\u548c\u6269\u5f20\u3002 identity A set of cryptographically verifiable interactions that have the\nproperty that they were all created by the same person. digital identity The set of cryptographically verifiable transactions signed by the\nsame public key define the digital identity\\'s behavior. In many\nreal world scenarios (voting) it is desireable that digital\nidentities coincide with real world identities. Ensuring this\nwithout violence is an unsolved problem. unique identity A set of cryptographically verifiable interactions that have the\nproperty that they were all created by the same person, with the\nadded constraint that one person cannot have multiple unique\nidentities. reputation The property of an identity that other entities believe that\nidentity to be either (1) competent at some specific task, or (2)\ntrustworthy in some context, i.e., not likely to betray others even\nif short-term profitable. escrow If two mutually-untrusting entities are engaged in commerce, they\nmay wish to pass funds through a mutually trusted third party and\ninstruct that party to send the funds to the payee only when\nevidence of product delivery has been shown. This reduces the risk\nof the payer or payee committing fraud. Both this construction and\nthe third party is called escrow. deposit Digital property placed into a contract involving another party such that if certain conditions are not satisfied that property is\nautomatically forfeited and either credited to a counterparty as\ninsurance against the conditions, or destroyed (= burnt = equally\ndistributed) or donated to some charitable funds. web of trust The idea that if A highly rates B, and B highly rates C, then A is likely to trust C. Complicated and powerful mechanisms for\ndetermining the reliability of specific individuals in specific\nconcepts can theoretically be gathered from this principle. incentive compatibility A protocol is incentive-compatible if everyone is better off \\\"following the rules\\\" than attempting to cheat, at least unless a\nvery large number of people agree to cheat together at the same time\n(collusion). collusion In an incentivized protocol scenario, when a number of participants play together  (conspire) to game the rules to their own benefit. token system A fungible virtual good that can be traded. More formally, a token system is a database mapping addresses to numbers with the property\nthat the primary allowed operation is a transfer of N tokens from A\nto B, with the conditions that N is non-negative, N is not greater\nthan A\\'s current balance, and a document authorizing the transfer\nis digitally signed by A. Secondary \\\"issuance\\\" and \\\"consumption\\\"\noperations may also exist, transaction fees may also be collected,\nand simultaneous multi-transfers with many parties may be possible.\nTypical use cases include currencies, cryptographic tokens inside of\nnetworks, company shares and digital gift cards. block A block is a package of data that contains zero or more transactions, the hash of the previous block (\\\"parent\\\"), and\noptionally other data. The total set of blocks, with every block\nexcept for the initial \\\"genesis block\\\" containing the hash of its\nparent, is called the blockchain and contains the entire transaction\nhistory of a network. Note that some blockchain-based\ncryptocurrencies use the word \\\"ledger\\\" instead of blockchain; the\ntwo are roughly equivalent, although in systems that use the term\n\\\"ledger\\\" each block generally contains a full copy of the current\nstate (e.g. currency balances, partially fulfilled contracts,\nregistrations) of every account allowing users to discard outdated\nhistorical data. address An Ethereum address represents an account. For [EOA](EOAExternally%20Owned%20Account.%20An%20account%20controlled%20by%20a%20private%20key.%20If%20you%20own%20the%20private%20key%20associated%20with%20the%20EOA%20you%20have%20the%20ability%20to%20send%20ether%20and%20messages%20from%20it.%20Contract%20accounts%20also%20have%20an%20address,%20see%20:ref:%60Accounts%60.%20EOAs%20and%20contract%20accounts%20may%20be%20combined%20into%20a%20single%20account%20type%20during%20Serenity.),\nthe address is derived as the last 20 bytes of the public key\ncontrolling the account, e.g.,\ncd2a3d9f938e13cd947ec05abc7fe734df8dd826. This is a\n[hexadecimal](hexadecimalCommon%20representation%20format%20for%20byte%20sequencing.%20Its%20advantage%20is%20that%20values%20are%20represented%20in%20a%20compact%20format%20using%20two%20characters%20per%20byte%20(the%20characters%20%60%60%5B0-9%5D%5Ba-f%5D%60%60).)\nformat (base 16 notation), which is often indicated explicitly by\nappending 0x to the address. Web3.js and console functions accept\naddresses with or without this prefix but for transparency we\nencourage their use. Since each byte of the address is represented\nby 2 hex characters, a prefixed address is 42 characters long.\nSeveral apps and APIs are also meant to implement the new\n[checksum-enabled address\nscheme]( https://github.com/ethereum/EIPs/issues/55 ) introduced in\nthe Mist Ethereum wallet as of version 0.5.0. ether Ether is the name of the currency used within Ethereum. It is used to pay for computations within the EVM. Ambiguously, ether is also\nthe name of a unit in the system; transaction The signed data package that stores a message to be sent from an externally owned account. Simply put, a transaction describes a\ntransfer of information from an EOA to another EOA or a contract\naccount. message A data transfer mechanism contracts use to communicate with other contracts. Messages can also be described as virtual objects that\nare never serialized and exist only in the Ethereum execution\nenvironment. Web3 The exact definition of the Web3 paradigm is still taking form, but it generally refers to the phenomenon of increased connectedness\nbetween all kinds of devices, decentralization of services and\napplications, semantic storage of information online and application\nof artificial intelligence to the web. DAO See Decentralized Autonomous Organization. epoch Epoch is the interval between each regeneration of the DAG used as seed by the PoW algorithm Ethash. The epoch in specified as 30000\nblocks. elliptic curve (cryptography) Refers to an approach to public-key cryptography based on the algebraic structure of elliptic curves over finite fields. See\n[elliptic curve\ncryptography]( https://en.wikipedia.org/wiki/Elliptic_curve_cryptography ). wallet A wallet, in the most generic sense, refers to anything that can store ether or any other crypto token. In the crypto space in\ngeneral, the term wallet is used to mean anything from a single\nprivate/public key pair (like a single paper wallet) all the way to\napplications that manage multiple key pairs, like the Mist Ethereum\nwallet. contract A persistent piece of code on the Ethereum blockchain that encompasses a set of data and executable functions. These functions\nexecute when Ethereum transactions are made to them with certain\ninput parameters. Based on the input parameters, the functions will\nexecute and interact with data within and outside of the contract. suicide See self-destruct. selfdestruct acts as an alias to the deprecated suicide terminology in accordance with [EIP 6 - Renaming SUICIDE\nOPCODE]( https://github.com/ethereum/EIPs/blob/master/EIPS/eip-6.md ). selfdestruct A global variable in the Solidity language that allows you to [\\\"destroy the current contract, sending its funds to the given\naddress\\\"]( https://solidity.readthedocs.org/en/latest/miscellaneous.html#global-variables ).\nselfdestruct acts as an alias to the deprecated suicide terminology\nin accordance with [EIP 6 - Renaming SUICIDE\nOPCODE]( https://github.com/ethereum/EIPs/blob/master/EIPS/eip-6.md ).\nIt frees up space on the blockchain and prevents future execution of\nthe contract. The contract\\'s address will still persist, but ether\nsent to it will be lost forever. The possibility to kill a contract\nhas to be implemented by the contract creator him/herself using the\nSolidity selfdestruct function. transaction fee Also known as gas cost, it is the amount of ether that the miners will charge for the execution of your transaction. mining The process of verifying transactions and contract execution on the Ethereum blockchain in exchange for a reward in ether with the\nmining of every block. mining pool The pooling of resources by miners, who share their processing power over a network, to split the reward equally, according to the amount\nof work they contributed to solving a block. mining reward The amount of cryptographic tokens (in this case ether) that is given to the miner who mined a new block. state Refers to a snapshot of all balances and data at a particular point in time on the blockchain, normally referring to the condition at a\nparticular block. blockchain An ever-extending series of data blocks that grows as new transactions are confirmed as part of a new block. Each new block is\nchained to the existing blockchain by a cryptographic proof-of-work. peer Other computers on the network also running an Ethereum node (Geth) with an exact copy of the blockchain that you have. signing Producing a piece of data from the data to be signed using your private key, to prove that the data originates from you. discovery (peer) The process of \\'gossiping\\' with other nodes in the network to find out the state of other nodes on the network. gas price oracle A helper function of the Geth client that tries to find an appropriate default gas price when sending transactions. light client A client program that allows users in low-capacity environments to still be able to execute and check the execution of transactions\nwithout needing to run a full Ethereum node (Geth). etherbase It is the default name of the account on your node that acts as your primary account. If you do mining, mining rewards will be credited\nto this account. coinbase Coinbase is analogous to etherbase, but is a more generic term for all cryptocurrency platforms. balance The amount of cryptocurrency (in this case) belonging to an account. solidity Solidity is a high-level language whose syntax is similar to that of JavaScript and it is designed to compile to code for the Ethereum\nVirtual Machine. serpent Serpent is a high-level language whose syntax is similar to that of Python and it is designed to compile to code for the Ethereum\nVirtual Machine. EVM Ethereum Virtual Machine, the decentralized computing platform which forms the core of the Ethereum platform. virtual machine In computing, it refers to an emulation of a particular computer     system. peer to peer network A network of computers that are collectively able to perform functionalities normally only possible with centralized,\nserver-based services. decentralization The concept of moving the control and execution of computational processes away from a central entity. distributed hash table A distributed hash table (DHT) is a class of a decentralized distributed system that provides a lookup service similar to a hash\ntable    (key, value) pairs are stored in a DHT, and any participating\nnode can efficiently retrieve the value associated with a given key. NAT Network address translation (NAT) is a methodology of remapping one IP address space into another by modifying network address\ninformation in Internet Protocol (IP) datagram packet headers while\nthey are in transit across a traffic routing device. nonce Number Used Once or Number Once. A nonce, in information technology, is a number generated for a specific use, such as session\nauthentication. Typically, a nonce is some value that varies with\ntime, although a very large random number is sometimes used. In\ngeneral usage, nonce means \\\"for the immediate occasion\\\" or \\\"for\nnow.\\\" In the case of Blockchain Proof of Work scenarios, the hash\nvalue, found by a Miner, matching the network\\'s Difficulty thus\nproving the Block Validity is called Nonce as well. proof-of-work Often seen in its abbreviated form \\\"PoW\\\", it refers to a mathematical value that can act as the proof of having solved a\nresource and time consuming computational problem. proof-of-stake An alternative method of mining blocks that require miners to demonstrate their possession of a certain amount of the currency of\nthe network in question. This works on the principle that miners\nwill be disincentivized to try to undermine a network in which they\nhave a stake. PoS is less wasteful than PoW, but is still often used\ntogether with it to provide added security to the network. CASPER Casper is a security-deposit based economic consensus protocol. This means that nodes, so called \\\"bonded validators\\\", have to place a\nsecurity deposit (an action we call \\\"bonding\\\") in order to serve\nthe consensus by producing blocks. If a validator produces anything\nthat Casper considers \\\"invalid\\\", the deposit is forfeited along\nwith the privilege of participating in the consensus process. consensus The agreement among all nodes in the network about the state of the\nEthereum network. homestead Homestead is the second major version release of the Ethereum platform. Homestead includes several protocol changes and a\nnetworking change that makes possible further network upgrades:\n[EIP-2 Main homestead hardfork\nchanges]( https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2.mediawiki );\n[EIP-7 Hardfork EVM update\n(DELEGATECALL)]( https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7.md );\n[EIP-8 devp2p forward\ncompatibility]( https://github.com/ethereum/EIPs/blob/master/EIPS/eip-8.md ).\nHomestead will launch when block 1,150,000 is reached on the\nMainnet. On the Testnet, Homestead will launch at block 494,000. metropolis The third stage of Ethereum\\'s release. This is the stage when the user interfaces come out (e.g. Mist), including a dapp store, and\nnon-technical users should feel comfortable joining at this point. serenity The fourth stage of Ethereum\\'s release. This is when things are going to get fancy    the network is going to change its mining\nprocess from Proof-of-Work to Proof-of-Stake. frontier Ethereum was planned to be released in four major steps with Frontier being the name for the first phase. The Frontier release\nwent live on July 30th, 2015. The command line Frontier phase was\nmainly meant to get mining operations going with the full reward of\n5 ether per block and also to promote the emergence of ether\nexchanges. Frontier surpassed earlier modest expectations and has\nnurtured tremendous growth of the ecosystem. olympic The Frontier pre-release, which launched on May 9th 2015. It was meant for developers to help test the limits of the Ethereum\nblockchain. morden Morden is the first Ethereum alternative testnet. It is expected to continue throughout the Frontier and Homestead era. testnet A mirror network of the production Ethereum network that is meant\nfor testing. See Morden. private chain A fully private blockchain is a blockchain where write permissions are kept centralized to one organization. consortium chain A blockchain where the consensus process is controlled by a pre-selected set of nodes. micropayment A micropayment is a financial transaction involving a very small sum of money (\\ 1 USD) and usually one that occurs online. sharding The splitting of the space of possible accounts (contracts are accounts too) into subspaces, for example, based on first digits of\ntheir numerical addresses. This allows for contract executions to be\nexecuted within \\'shards\\' instead of network wide, allowing for\nfaster transactions and greater scalability. hash A cryptographic function which takes an input (or \\'message\\') and returns a fixed-size alphanumeric string, which is called the hash\nvalue (sometimes called a message digest, a digital fingerprint, a\ndigest or a checksum). A hash function (or hash algorithm) is a\nprocess by which a document (i.e. a piece of data or file) is\nprocessed into a small piece of data (usually 32 bytes) which looks\ncompletely random, and from which no meaningful data can be\nrecovered about the document, but which has the important property\nthat the result of hashing one particular document is always the\nsame. Additionally, it is crucially important that it is\ncomputationally infeasible to find two documents that have the same\nhash. Generally, changing even one letter in a document will\ncompletely randomize the hash; for example, the SHA3 hash of\n\\\"Saturday\\\" is\nc38bbc8e93c09f6ed3fe39b5135da91ad1a99d397ef16948606cdcbd14929f9d,\nwhereas the SHA3 hash of \\\"Caturday\\\" is\nb4013c0eed56d5a0b448b02ec1d10dd18c1b3832068fbbdc65b98fa9b14b6dbf.\nHashes are usually used as a way of creating a globally agreed-upon\nidentifier for a particular document that cannot be forged. crypto-fuel Similar to \\'gas\\', referring to the amount of cryptocurrency\nrequired to power a transaction. cryptoeconomics The economics of cryptocurrencies. protocol A standard used to define a method of exchanging data over a\ncomputer network. block validation The checking of the coherence of the cryptographic signature of the block with the history stored in the entire blockchain. blocktime The average time interval between the mining of two blocks. network hashrate The number of hash calculations the network can make per second\ncollectively. hashrate The number of hash calculations made per second. serialization The process of converting a data structure into a sequence of bytes. Ethereum internally uses an encoding format called recursive-length\nprefix encoding (RLP), described in the [RLP section of the\nwiki]( https://github.com/ethereum/wiki/wiki/RLP ). double spend A deliberate blockchain fork, where a user with a large amount of mining power sends a transaction to purchase some produce, then\nafter receiving the product creates another transaction sending the\nsame coins to themselves. The attacker then creates a block, at the\nsame level as the block containing the original transaction but\ncontaining the second transaction instead, and starts mining on the\nfork. If the attacker has more than 50% of all mining power, the\ndouble spend is guaranteed to succeed eventually at any block depth.\nBelow 50%, there is some probability of success, but it is usually\nonly substantial at a depth up to about 2-5; for this reason, most\ncryptocurrency exchanges, gambling sites and financial services wait\nuntil six blocks have been produced (\\\"six confirmations\\\") before\naccepting a payment. SPV client A client that downloads only a small part of the blockchain, allowing users of low-power or low-storage hardware like smartphones\nand laptops to maintain almost the same guarantee of security by\nsometimes selectively downloading small parts of the state without\nneeding to spend megabytes of bandwidth and gigabytes of storage on\nfull blockchain validation and maintenance. See light client. uncle Uncles are blockchain blocks found by a miner, when a different miner has already found another block for the corresponding place in\nthe blockchain. They are called \\\"stale blocks\\\". The parent of an\nUncle is an ancestor of the inserting block, located at the tip of\nthe blockchain. In contrast to the Bitcoin network, Ethereum rewards\nstale blocks as well in order to avoid to penalize miners with a bad\nconnection to the network. This is less critical in the Bitcoin\nnetwork, because the Block Time there is much higher (\\~10 minutes)\nthan on the Ethereum network (aimed to \\~15 seconds). GHOST Greedy Heaviest-Observed Sub-Tree is an alternative chain-selection method that is designed to incentivize stale blocks (uncles) as\nwell, thus reducing the incentive for pool mining. In GHOST, even\nthe confirmation given by stale blocks to previous blocks are\nconsidered valid, and the miners of the stale blocks are also\nrewarded with a mining reward. merkle patricia tree Merkle Patricia trees provide a cryptographically authenticated data structure that can be used to store all (key, value) bindings. They\nare fully deterministic, meaning that a Patricia tree with the same\n(key,value) bindings is guaranteed to be exactly the same down to\nthe last byte and therefore have the same root hash, provide\nO(log(n)) efficiency for inserts, lookups and deletes, and are much\neasier to understand and code than more complex comparison-based\nalternatives like red-black trees. DAG DAG stands for Directed Acyclic Graph. It is a graph, a set of nodes and links between nodes, that has very special properties. Ethereum\nuses a DAG in Ethash, the Ethereum Proof of Work (POW) algorithm.The\nEthash DAG takes a long time to be generated, which is done by a\nMiner node into a cache file for each Epoch. The file data is then\nused when a value from this graph is required by the algorithm. uncle rate The number of uncles produced per block. issuance The minting and granting of new cryptocurrency to a miner who has\nfound a new block. presale Sale of cryptocurrency before the actual launch of the network. static node A feature supported by Geth, the Golang Ethereum client, which makes it possible to always connect to specific peers. Static nodes are\nre-connected on disconnects. For details, see the [section on\nstatic nodes \\ cr-static-nodes>]{role=\\\"ref\\\"}. bootnode The nodes which can be used to initiate the discovery process when running a node. The endpoints of these nodes are recorded in the\nEthereum source code. exchange An online marketplace which facilitates the exchange of crypto or fiat currencies based on the market exchange rate. compiler A program that translates pieces of code written in high level languages into low level executable code. genesis block The first block in a blockchain. network id A number which identifies a particular version of the Ethereum\nnetwork. block header The data in a block which is unique to its content and the circumstances in which it was created. It includes the hash of the\nprevious block\\'s header, the version of the software the block is\nmined with, the timestamp and the merkle root hash of the contents\nof the block. pending transaction A transaction that is not yet confirmed by the Ethereum network. block propagation The process of transmitting a confirmed block to all other nodes in\nthe network. sidechain A blockchain that branches off a main blockchain and checks in periodically with the main blockchain. Besides that it runs\nindependently from the main chain, and any security compromises in\nthe sidechain will not affect the main chain. pegging Locking down the exchange rate of the coins/tokens in two chains (usually a main and a side chain) in a certain direction. 2-way pegging Locking down the exchange rate of the coins/tokens in two chains (usually a main and a side chain) in both directions. trustless Refers to the ability of a network to trustworthily mediate transactions without any of the involved parties needing to trust\nanyone else. faucet A website that dispenses (normally testnet) cryptocurrencies for free. checksum A count of the number of bits in a transmission that is included with the unit so that the receiving end can verify that the entirety\nof the message has been transmitted. ICAP Interexchange Client Address Protocol, an IBAN-compatible system for referencing and transacting to client accounts aimed to streamline\nthe process of transferring funds, worry-free between exchanges and,\nultimately, making KYC and AML concerns a thing of the past. private key A private key is a string of characters known only to the owner, that is paired with a public key to set off algorithms for text\nencryption and decryption. public key A string of characters derived from a private key that can be made public. The public key can be used to verify the authenticity of any\nsignature created using the private key. encryption Encryption is the conversion of electronic data into a form unreadable by anyone except the owner of the correct decryption key.\nIt can further be described as a process by which a document\n(plaintext) is combined with a shorter string of data, called a key\n(e.g.\nc85ef7d79691fe79573b1a7064c19c1a9819ebdbd1faaab1a8ec92344438aaf4),\nto produce an output (ciphertext) which can be \\\"decrypted\\\" back\ninto the original plaintext by someone else who has the key, but\nwhich is incomprehensible and computationally infeasible to decrypt\nfor anyone who does not have the key. digital signature A mathematical scheme for demonstrating the authenticity of a digital message or documents. port A network port is a communication endpoint used by a one of the existing standards of establishing a network conversation (e.g. TCP,\nUDP). RPC Remote Procedure Call, a protocol that a program uses to request a service from a program located in another computer in a network\nwithout having to understand the network details. IPC Interprocess communication (IPC) is a set of programming interfaces that allow a programmer to coordinate activities among different\nprogram processes that can run concurrently in an operating system. attach The command used to initiate the Ethereum Javascript console. daemon A computer program that runs as a background process instead of in direct control by an interactive user. system service See base layer service base layer service Services such as SWARM and Whisper which are built into the Ethereum platform. js Javascript. syncing The process of downloading the entire blockchain. fast sync Instead of processing the entire block-chain one link at a time, and replay all transactions that ever happened in history, fast syncing\ndownloads the transaction receipts along the blocks, and pulls an\nentire recent state database. ASIC Application-specific integrated circuit, in this case referring to an integrated circuit custom built for cryptocurrency mining. memory-hard Memory hard functions are processes that experience a drastic decrease in speed or feasibility when the amount of available memory\neven slightly decreases. keyfile Every account\\'s private key/address pair exists as a single keyfile. These are JSON text files which contains the encrypted\nprivate key of the account, which can only be decrypted with the\npassword entered during account creation. ICAP format The format of the IBANs defined using the [Inter-exchange Client Address Protocol]( https://github.com/ethereumjs/ethereumjs-icap ). block(chain) explorer A website that allows easy searching and extraction of data from the blockchain. geth Ethereum client implemented in the Golang programming language, based on the protocol as defined in the Ethereum Yellow Paper. eth Ethereum client implemented in the C++ programming language, based on the protocol as defined in the Ethereum Yellow Paper. ethereumjs Ethereum client implemented in the Javascript/Node programming language, based on the protocol as defined in the Ethereum Yellow\nPaper. pyethereum Ethereum client implemented in the Python programming language, based on the protocol as defined in the Ethereum Yellow Paper. ethereumj Ethereum client implemented in the Java programming language, based on the protocol as defined in the Ethereum Yellow Paper. ethereumh Ethereum client implemented in the Haskell programming language, based on the protocol as defined in the Ethereum Yellow Paper. parity Ethereum client implemented in the Rust programming language, based on the protocol as defined in the Ethereum Yellow Paper. difficulty In very general terms, the amount of effort required to mine a new block. With the launch of Homestead, the [difficulty adjustment\nalgorithm will\nchange]( https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2.md ). account Accounts are a central part of the Ethereum network and are an essential part of any transaction or contract. In Ethereum, there\nare two types of accounts    Externally Owned accounts (EOA) and\nContract accounts. HLL (obsolete) Acronym for Higher Level Language, which is what Serpent and Solidity are. HLL is what early \u00d0app developers called Ethereum\nprogramming languages that did not touch the low level elements.\nThis phrase has been phased out. CLL (obsolete) Acronym for C Like Language, which Mutan was. This acronym has been phased out.\" ES1, ES2, and ES3 (obsolete) \\\"Ethereum Script\\\" versions 1,2 and 3. There were early versions of what would become the Ethereum Virtual Machine (EVM). log event Contracts are triggered by transactions executed as part of the block verification. If conceived of as a function call, contract\nexecution is asynchronous, and therefore they have no return value.\nInstead contracts communicate to the outside world with log events.\nThe log events are part of the transaction receipt which is produced\nwhen the transaction is executed. The receipts are stored in the\nreceipt trie, the integrity of which is guaranteed by the fact that\nthe current root of the receipt trie is part of the block header\nalongside the roots of state and state-trie. In a broad sense from\nthe external perspective receipts are part of the Ethereum system\nstate except that they are not readable contracts internally.", 
            "title": "\u8bcd\u6c47\u8868"
        }, 
        {
            "location": "/about/", 
            "text": "The Homestead Documentation Initiative\n\n\n\n\nPurpose and Audience-----------\n\n\nThis guide should serve to be an entry level for all Ethereum users and\ndevelopers. The goal is to create documentation with information, short\ntutorials, and examples that will cover all of the basic and\nintermediate functionality of using Ethereum to interact with dapps or\ndevelop a dapp.\n\n\nAny information that is overly specific, technical, or not necessary to\naccomplish the documentation\\'s goal will remain on the Ethereum Github\nWiki. It may be referenced in this guide if necessary.\n\n\nAlthough much of the information will be similar between the Frontier\nGuide and the Homestead Guide, efforts need to be made to make sure the\ninformation ported over is still accurate. This document is client\nagnostic, and examples and tutorials may be based on any client that the\nauthor decides to write on, as long as a distinction is made as to what\nclient is being used in the examples/tutorials.\n\n\nAlthough overly specific and technical documentation will not be\nincluded in the first iterations of this guide, community use and\npopularity of this guide will dictate future decisions to move Github\nwiki documentation to this format.\n\n\nExamples of overly specific and technical documentation include:\n\n\n\n\nETHash, CASPER, ABI, RLP, or other technical specs.\n\n\nFull API specs for protocols. Caveat: If an example, information, or\n    tutorial needs to reference API calls for a client or interface in\n    order to fulfill its example it is acceptable to reference the\n    specific call. Be sure to make a reference where the user can find\n    remaining pieces of the specific documentation that may be on the\n    GitHub Wiki.\n\n\n\n\nResources for Exemplary Documentation----------------------------\n\n\nHere are some examples of previous Ethereum documentation + good\nexamples of documentation.\n\n\n\n\nSolidity Docs - \nhttps://ethereum.github.io/solidity/docs/home/\n\n\nFrontier Guide -\n    \nhttps://ethereum.gitbooks.io/frontier-guide/content/\n\n\nGav's TurboEthereum Guide -\n    \nhttps://gavofyork.gitbooks.io/turboethereum/content/\n\n\nAncient EthereumBuilder's Guide -\n    \nhttps://ethereumbuilders.gitbooks.io/guide/content/en/index.html\n\n\nOther Ethereum Links:\n    \nhttps://souptacular.gitbooks.io/ethereum-tutorials-and-tips-by-hudson/content/giant_ethereum_resource_list.html\n\n\nDjango Docs - \nhttps://docs.djangoproject.com/en/1.9/\n\n\n\n\nRestructured Text Markup, Sphinx-----------------------\n\n\n\n\nBest Cheat Sheet -\n    \nhttps://github.com/ralsina/rst-cheatsheet/blob/master/rst-cheatsheet.rst\n\n\nQuick Reference -\n    \nhttp://docutils.sourceforge.net/docs/user/rst/quickref.html\n\n\nOfficial Cheat Sheet -\n    \nhttp://docutils.sourceforge.net/docs/user/rst/cheatsheet.txt\n ->\n    \nhttp://docutils.sourceforge.net/docs/user/rst/cheatsheet.html\n\n\nRST Primer \nhttp://sphinx-doc.org/rest.html\n\n\nhttp://sphinx-doc.org/markup/inline.html\n\n\n\n\nCompilation and Deployment-----------------\n\n\nWe use make with the autogenerated read-the-docs Makefile to build the\ndoc.\n\n\n``` {.sourceCode .bash}\ngit clone https://github.com/ethereum/homestead-guide\ncd homestead-guide\nmake html\n\n## Processing Tips------\n\nFix section delimiter lines (always use 80-long ones to have correct\nlength, unless the title is greater than 80 chars in length)\n\n``` {.sourceCode .bash}\nfor f in `ls source/*/*.rst`; do cat $f|perl -pe \ns/\\=+$/================================================================================/\n \n $f.o; mv $f.o $f; done; done\nfor f in `ls source/*/*.rst`; do cat $f|perl -pe \ns/\\*+$/********************************************************************************/\n \n $f.o; mv $f.o $f; done\nfor f in `ls source/*/*.rst`; do cat $f|perl -pe \ns/\\-+$/--------------------------------------------------------------------------------/\n \n $f.o; mv $f.o $f; done\nfor f in `ls source/*/*.rst`; do cat $f|perl -pe \ns/\\++$/++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++/\n \n $f.o; mv $f.o $f; done\nfor f in `ls source/*/*.rst`; do cat $f|perl -pe \ns/\\#+$/################################################################################/\n \n $f.o; mv $f.o $f; done\n\n\n\nReferencing Old Documentation--------------------\n\n\nold-docs-for-reference folder has all of the Frontier Gitbook and\nEthereum Wiki doc. Feel free to copy/paste information from those\ndocuments that is still relevant.\n\n\nMigrate and Convert Old Wiki Content Using Pandoc----------------------------------------\n\n\nIf you still want to clone the absolute latest Ethereum Wiki and\nFrontier Guide docs:\n\n\n``` {.sourceCode .bash}\ngit clone git@github.com:ethereum/go-ethereum.wiki.git\ngit clone git@github.com:ethereum/wiki.wiki.git\n\n\nmkdir main-wiki.rst\nmkdir go-ethereum-wiki.rst\n\n\nfor f in \nls wiki.wiki/*.md\n; do pandoc $f -o main-wiki.rst/\nbasename $f .md\n.rst; done\nfor f in \nls go-ethereum.wiki/*.md\n; do pandoc $f -o go-ethereum-wiki.rst/\nbasename $f .md\n.rst; done\n```", 
            "title": "\u5173\u4e8e"
        }, 
        {
            "location": "/about/#the-homestead-documentation-initiative", 
            "text": "", 
            "title": "The Homestead Documentation Initiative"
        }, 
        {
            "location": "/about/#purpose-and-audience-", 
            "text": "This guide should serve to be an entry level for all Ethereum users and\ndevelopers. The goal is to create documentation with information, short\ntutorials, and examples that will cover all of the basic and\nintermediate functionality of using Ethereum to interact with dapps or\ndevelop a dapp.  Any information that is overly specific, technical, or not necessary to\naccomplish the documentation\\'s goal will remain on the Ethereum Github\nWiki. It may be referenced in this guide if necessary.  Although much of the information will be similar between the Frontier\nGuide and the Homestead Guide, efforts need to be made to make sure the\ninformation ported over is still accurate. This document is client\nagnostic, and examples and tutorials may be based on any client that the\nauthor decides to write on, as long as a distinction is made as to what\nclient is being used in the examples/tutorials.  Although overly specific and technical documentation will not be\nincluded in the first iterations of this guide, community use and\npopularity of this guide will dictate future decisions to move Github\nwiki documentation to this format.  Examples of overly specific and technical documentation include:   ETHash, CASPER, ABI, RLP, or other technical specs.  Full API specs for protocols. Caveat: If an example, information, or\n    tutorial needs to reference API calls for a client or interface in\n    order to fulfill its example it is acceptable to reference the\n    specific call. Be sure to make a reference where the user can find\n    remaining pieces of the specific documentation that may be on the\n    GitHub Wiki.", 
            "title": "Purpose and Audience-----------"
        }, 
        {
            "location": "/about/#resources-for-exemplary-documentation-", 
            "text": "Here are some examples of previous Ethereum documentation + good\nexamples of documentation.   Solidity Docs -  https://ethereum.github.io/solidity/docs/home/  Frontier Guide -\n     https://ethereum.gitbooks.io/frontier-guide/content/  Gav's TurboEthereum Guide -\n     https://gavofyork.gitbooks.io/turboethereum/content/  Ancient EthereumBuilder's Guide -\n     https://ethereumbuilders.gitbooks.io/guide/content/en/index.html  Other Ethereum Links:\n     https://souptacular.gitbooks.io/ethereum-tutorials-and-tips-by-hudson/content/giant_ethereum_resource_list.html  Django Docs -  https://docs.djangoproject.com/en/1.9/", 
            "title": "Resources for Exemplary Documentation----------------------------"
        }, 
        {
            "location": "/about/#restructured-text-markup-sphinx-", 
            "text": "Best Cheat Sheet -\n     https://github.com/ralsina/rst-cheatsheet/blob/master/rst-cheatsheet.rst  Quick Reference -\n     http://docutils.sourceforge.net/docs/user/rst/quickref.html  Official Cheat Sheet -\n     http://docutils.sourceforge.net/docs/user/rst/cheatsheet.txt  ->\n     http://docutils.sourceforge.net/docs/user/rst/cheatsheet.html  RST Primer  http://sphinx-doc.org/rest.html  http://sphinx-doc.org/markup/inline.html", 
            "title": "Restructured Text Markup, Sphinx-----------------------"
        }, 
        {
            "location": "/about/#compilation-and-deployment-", 
            "text": "We use make with the autogenerated read-the-docs Makefile to build the\ndoc.  ``` {.sourceCode .bash}\ngit clone https://github.com/ethereum/homestead-guide\ncd homestead-guide\nmake html ## Processing Tips------\n\nFix section delimiter lines (always use 80-long ones to have correct\nlength, unless the title is greater than 80 chars in length)\n\n``` {.sourceCode .bash}\nfor f in `ls source/*/*.rst`; do cat $f|perl -pe  s/\\=+$/================================================================================/    $f.o; mv $f.o $f; done; done\nfor f in `ls source/*/*.rst`; do cat $f|perl -pe  s/\\*+$/********************************************************************************/    $f.o; mv $f.o $f; done\nfor f in `ls source/*/*.rst`; do cat $f|perl -pe  s/\\-+$/--------------------------------------------------------------------------------/    $f.o; mv $f.o $f; done\nfor f in `ls source/*/*.rst`; do cat $f|perl -pe  s/\\++$/++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++/    $f.o; mv $f.o $f; done\nfor f in `ls source/*/*.rst`; do cat $f|perl -pe  s/\\#+$/################################################################################/    $f.o; mv $f.o $f; done", 
            "title": "Compilation and Deployment-----------------"
        }, 
        {
            "location": "/about/#referencing-old-documentation-", 
            "text": "old-docs-for-reference folder has all of the Frontier Gitbook and\nEthereum Wiki doc. Feel free to copy/paste information from those\ndocuments that is still relevant.", 
            "title": "Referencing Old Documentation--------------------"
        }, 
        {
            "location": "/about/#migrate-and-convert-old-wiki-content-using-pandoc-", 
            "text": "If you still want to clone the absolute latest Ethereum Wiki and\nFrontier Guide docs:  ``` {.sourceCode .bash}\ngit clone git@github.com:ethereum/go-ethereum.wiki.git\ngit clone git@github.com:ethereum/wiki.wiki.git  mkdir main-wiki.rst\nmkdir go-ethereum-wiki.rst  for f in  ls wiki.wiki/*.md ; do pandoc $f -o main-wiki.rst/ basename $f .md .rst; done\nfor f in  ls go-ethereum.wiki/*.md ; do pandoc $f -o go-ethereum-wiki.rst/ basename $f .md .rst; done\n```", 
            "title": "Migrate and Convert Old Wiki Content Using Pandoc----------------------------------------"
        }
    ]
}